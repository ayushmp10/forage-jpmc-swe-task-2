From 812138ed7405be9f6c8788eb75420873f6bab21a Mon Sep 17 00:00:00 2001
From: ayushmp10 <ayushparambath@gmail.com>
Date: Mon, 20 May 2024 11:45:03 -0400
Subject: [PATCH] Task 2

Completed task 2
Updated Graph.tsx and App.tsx
---
 .idea/.gitignore                              |    3 +
 .idea/forage-jpmc-swe-task-2.iml              |   12 +
 .../inspectionProfiles/profiles_settings.xml  |    6 +
 .idea/misc.xml                                |    4 +
 .idea/modules.xml                             |    8 +
 .idea/vcs.xml                                 |    6 +
 __pycache__/six.cpython-312.pyc               |  Bin 0 -> 41259 bytes
 dateutil/__init__.py                          |    8 +
 dateutil/__pycache__/__init__.cpython-312.pyc |  Bin 0 -> 412 bytes
 dateutil/__pycache__/_common.cpython-312.pyc  |  Bin 0 -> 1925 bytes
 dateutil/__pycache__/_version.cpython-312.pyc |  Bin 0 -> 247 bytes
 dateutil/__pycache__/easter.cpython-312.pyc   |  Bin 0 -> 2848 bytes
 .../__pycache__/relativedelta.cpython-312.pyc |  Bin 0 -> 28362 bytes
 dateutil/__pycache__/rrule.cpython-312.pyc    |  Bin 0 -> 69220 bytes
 dateutil/__pycache__/tzwin.cpython-312.pyc    |  Bin 0 -> 207 bytes
 dateutil/__pycache__/utils.cpython-312.pyc    |  Bin 0 -> 2560 bytes
 dateutil/_common.py                           |   43 +
 dateutil/_version.py                          |    5 +
 dateutil/easter.py                            |   89 +
 dateutil/parser/__init__.py                   |   61 +
 .../__pycache__/__init__.cpython-312.pyc      |  Bin 0 -> 2654 bytes
 .../__pycache__/_parser.cpython-312.pyc       |  Bin 0 -> 61847 bytes
 .../__pycache__/isoparser.cpython-312.pyc     |  Bin 0 -> 15594 bytes
 dateutil/parser/_parser.py                    | 1613 ++++++++++++++
 dateutil/parser/isoparser.py                  |  416 ++++
 dateutil/relativedelta.py                     |  599 ++++++
 dateutil/rrule.py                             | 1737 ++++++++++++++++
 dateutil/tz/__init__.py                       |   12 +
 .../tz/__pycache__/__init__.cpython-312.pyc   |  Bin 0 -> 707 bytes
 .../tz/__pycache__/_common.cpython-312.pyc    |  Bin 0 -> 14160 bytes
 .../tz/__pycache__/_factories.cpython-312.pyc |  Bin 0 -> 4593 bytes
 dateutil/tz/__pycache__/tz.cpython-312.pyc    |  Bin 0 -> 66026 bytes
 dateutil/tz/__pycache__/win.cpython-312.pyc   |  Bin 0 -> 17263 bytes
 dateutil/tz/_common.py                        |  419 ++++
 dateutil/tz/_factories.py                     |   80 +
 dateutil/tz/tz.py                             | 1849 +++++++++++++++++
 dateutil/tz/win.py                            |  370 ++++
 dateutil/tzwin.py                             |    2 +
 dateutil/utils.py                             |   71 +
 dateutil/zoneinfo/__init__.py                 |  167 ++
 .../__pycache__/__init__.cpython-312.pyc      |  Bin 0 -> 7430 bytes
 .../__pycache__/rebuild.cpython-312.pyc       |  Bin 0 -> 3956 bytes
 dateutil/zoneinfo/dateutil-zoneinfo.tar.gz    |  Bin 0 -> 174394 bytes
 dateutil/zoneinfo/rebuild.py                  |   75 +
 python_dateutil-2.8.2.dist-info/INSTALLER     |    1 +
 python_dateutil-2.8.2.dist-info/LICENSE       |   54 +
 python_dateutil-2.8.2.dist-info/METADATA      |  204 ++
 python_dateutil-2.8.2.dist-info/RECORD        |   45 +
 python_dateutil-2.8.2.dist-info/REQUESTED     |    0
 python_dateutil-2.8.2.dist-info/WHEEL         |    6 +
 python_dateutil-2.8.2.dist-info/top_level.txt |    1 +
 python_dateutil-2.8.2.dist-info/zip-safe      |    1 +
 six-1.16.0.dist-info/INSTALLER                |    1 +
 six-1.16.0.dist-info/LICENSE                  |   18 +
 six-1.16.0.dist-info/METADATA                 |   49 +
 six-1.16.0.dist-info/RECORD                   |    8 +
 six-1.16.0.dist-info/WHEEL                    |    6 +
 six-1.16.0.dist-info/top_level.txt            |    1 +
 six.py                                        |  998 +++++++++
 src/App.tsx                                   |   24 +-
 src/Graph.tsx                                 |    9 +-
 61 files changed, 9073 insertions(+), 8 deletions(-)
 create mode 100644 .idea/.gitignore
 create mode 100644 .idea/forage-jpmc-swe-task-2.iml
 create mode 100644 .idea/inspectionProfiles/profiles_settings.xml
 create mode 100644 .idea/misc.xml
 create mode 100644 .idea/modules.xml
 create mode 100644 .idea/vcs.xml
 create mode 100644 __pycache__/six.cpython-312.pyc
 create mode 100644 dateutil/__init__.py
 create mode 100644 dateutil/__pycache__/__init__.cpython-312.pyc
 create mode 100644 dateutil/__pycache__/_common.cpython-312.pyc
 create mode 100644 dateutil/__pycache__/_version.cpython-312.pyc
 create mode 100644 dateutil/__pycache__/easter.cpython-312.pyc
 create mode 100644 dateutil/__pycache__/relativedelta.cpython-312.pyc
 create mode 100644 dateutil/__pycache__/rrule.cpython-312.pyc
 create mode 100644 dateutil/__pycache__/tzwin.cpython-312.pyc
 create mode 100644 dateutil/__pycache__/utils.cpython-312.pyc
 create mode 100644 dateutil/_common.py
 create mode 100644 dateutil/_version.py
 create mode 100644 dateutil/easter.py
 create mode 100644 dateutil/parser/__init__.py
 create mode 100644 dateutil/parser/__pycache__/__init__.cpython-312.pyc
 create mode 100644 dateutil/parser/__pycache__/_parser.cpython-312.pyc
 create mode 100644 dateutil/parser/__pycache__/isoparser.cpython-312.pyc
 create mode 100644 dateutil/parser/_parser.py
 create mode 100644 dateutil/parser/isoparser.py
 create mode 100644 dateutil/relativedelta.py
 create mode 100644 dateutil/rrule.py
 create mode 100644 dateutil/tz/__init__.py
 create mode 100644 dateutil/tz/__pycache__/__init__.cpython-312.pyc
 create mode 100644 dateutil/tz/__pycache__/_common.cpython-312.pyc
 create mode 100644 dateutil/tz/__pycache__/_factories.cpython-312.pyc
 create mode 100644 dateutil/tz/__pycache__/tz.cpython-312.pyc
 create mode 100644 dateutil/tz/__pycache__/win.cpython-312.pyc
 create mode 100644 dateutil/tz/_common.py
 create mode 100644 dateutil/tz/_factories.py
 create mode 100644 dateutil/tz/tz.py
 create mode 100644 dateutil/tz/win.py
 create mode 100644 dateutil/tzwin.py
 create mode 100644 dateutil/utils.py
 create mode 100644 dateutil/zoneinfo/__init__.py
 create mode 100644 dateutil/zoneinfo/__pycache__/__init__.cpython-312.pyc
 create mode 100644 dateutil/zoneinfo/__pycache__/rebuild.cpython-312.pyc
 create mode 100644 dateutil/zoneinfo/dateutil-zoneinfo.tar.gz
 create mode 100644 dateutil/zoneinfo/rebuild.py
 create mode 100644 python_dateutil-2.8.2.dist-info/INSTALLER
 create mode 100644 python_dateutil-2.8.2.dist-info/LICENSE
 create mode 100644 python_dateutil-2.8.2.dist-info/METADATA
 create mode 100644 python_dateutil-2.8.2.dist-info/RECORD
 create mode 100644 python_dateutil-2.8.2.dist-info/REQUESTED
 create mode 100644 python_dateutil-2.8.2.dist-info/WHEEL
 create mode 100644 python_dateutil-2.8.2.dist-info/top_level.txt
 create mode 100644 python_dateutil-2.8.2.dist-info/zip-safe
 create mode 100644 six-1.16.0.dist-info/INSTALLER
 create mode 100644 six-1.16.0.dist-info/LICENSE
 create mode 100644 six-1.16.0.dist-info/METADATA
 create mode 100644 six-1.16.0.dist-info/RECORD
 create mode 100644 six-1.16.0.dist-info/WHEEL
 create mode 100644 six-1.16.0.dist-info/top_level.txt
 create mode 100644 six.py

diff --git a/.idea/.gitignore b/.idea/.gitignore
new file mode 100644
index 0000000..26d3352
--- /dev/null
+++ b/.idea/.gitignore
@@ -0,0 +1,3 @@
+# Default ignored files
+/shelf/
+/workspace.xml
diff --git a/.idea/forage-jpmc-swe-task-2.iml b/.idea/forage-jpmc-swe-task-2.iml
new file mode 100644
index 0000000..91a92ba
--- /dev/null
+++ b/.idea/forage-jpmc-swe-task-2.iml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<module type="PYTHON_MODULE" version="4">
+  <component name="NewModuleRootManager">
+    <content url="file://$MODULE_DIR$" />
+    <orderEntry type="jdk" jdkName="Python 3.12 (forage-jpmc-swe-task-1)" jdkType="Python SDK" />
+    <orderEntry type="sourceFolder" forTests="false" />
+  </component>
+  <component name="PyDocumentationSettings">
+    <option name="format" value="PLAIN" />
+    <option name="myDocStringFormat" value="Plain" />
+  </component>
+</module>
\ No newline at end of file
diff --git a/.idea/inspectionProfiles/profiles_settings.xml b/.idea/inspectionProfiles/profiles_settings.xml
new file mode 100644
index 0000000..105ce2d
--- /dev/null
+++ b/.idea/inspectionProfiles/profiles_settings.xml
@@ -0,0 +1,6 @@
+<component name="InspectionProjectProfileManager">
+  <settings>
+    <option name="USE_PROJECT_PROFILE" value="false" />
+    <version value="1.0" />
+  </settings>
+</component>
\ No newline at end of file
diff --git a/.idea/misc.xml b/.idea/misc.xml
new file mode 100644
index 0000000..94f94f8
--- /dev/null
+++ b/.idea/misc.xml
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.12 (forage-jpmc-swe-task-1)" project-jdk-type="Python SDK" />
+</project>
\ No newline at end of file
diff --git a/.idea/modules.xml b/.idea/modules.xml
new file mode 100644
index 0000000..2afa09c
--- /dev/null
+++ b/.idea/modules.xml
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectModuleManager">
+    <modules>
+      <module fileurl="file://$PROJECT_DIR$/.idea/forage-jpmc-swe-task-2.iml" filepath="$PROJECT_DIR$/.idea/forage-jpmc-swe-task-2.iml" />
+    </modules>
+  </component>
+</project>
\ No newline at end of file
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
new file mode 100644
index 0000000..35eb1dd
--- /dev/null
+++ b/.idea/vcs.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/__pycache__/six.cpython-312.pyc b/__pycache__/six.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..b1a0da4aac80e835f45463ea5c40f39ee1410f89
GIT binary patch
literal 41259
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

literal 0
HcmV?d00001

diff --git a/dateutil/__init__.py b/dateutil/__init__.py
new file mode 100644
index 0000000..0defb82
--- /dev/null
+++ b/dateutil/__init__.py
@@ -0,0 +1,8 @@
+# -*- coding: utf-8 -*-
+try:
+    from ._version import version as __version__
+except ImportError:
+    __version__ = 'unknown'
+
+__all__ = ['easter', 'parser', 'relativedelta', 'rrule', 'tz',
+           'utils', 'zoneinfo']
diff --git a/dateutil/__pycache__/__init__.cpython-312.pyc b/dateutil/__pycache__/__init__.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..75d9f282391107681ca5fd66b1f36addd6ce98ac
GIT binary patch
literal 412
zcmXv}Jxc>Y5S`84<xb;Sm?DKK1Z_@;T8IV_LDWJND=iWhmepJJaC5utZ9Y4#wbkCv
z-{K#T1#PVCf@vg`dyq^q^B&C1d+$9AXTjD;99)0d`JIz#xf3wjwBQA1Ach!mXrX2S
z!41UDD{8uZcNv(o0?I=W7n+3zJkEEa=QN;;BJT&;(+C;A!&H`t)cEc6E*0H0@=cM^
zOfzMQlB&$kP%%z*(qS><ni@~3HfN@w2gYmbgl8rgh?FJiwK$7B6OhSE<yZ+*B2!L?
zDIK?@Q2IzIp^Q%m<(!Z=80C4!7Y94|!s=z1_S@Ml-k0)_YKl+A73KJxwIr5_tZAxl
zn6CA<w>Ii^d53v&iDh5kiWJ9Gv)s`-AxWBOLe^w|9PGA4Yz^<JvQ^1rXREdi9fZ)(
ubx`%w-S`bqY3bho8~PBGe*vND$HL;nNxoAZXLEM_p%}uGUvZvM#rX$d?tCu*

literal 0
HcmV?d00001

diff --git a/dateutil/__pycache__/_common.cpython-312.pyc b/dateutil/__pycache__/_common.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..731427bdb1992e6315cbd76bab9a0533bcdee739
GIT binary patch
literal 1925
zcmZ`)%}*Ow5P$FOuD>u~YFeO;(3X!710gA`AWADF3ZztRs8m2zEUPQyU4p^(I{Vfk
zrba>)2NR`AIhmfCNR=YQg`8+lRnNVU^y031h}3_;#i>+r>ddY&vFkp`v-9TT&70qw
z8UNbc>?5$s`qc6d0wI6m=4?q7rrZrofv6-*82N~(bepJ5qX%G*E6lP&NZc6kP3g&`
zo|0p_s>vCysd79eCo>5%o=#|TQdctxjgR<Zj+aAOWmCQmOo3=5Od$+YA;@hO7F4e)
zY}2r)irXYCsS;3^>H_Lk-9SC62dFp8LO#pAu4!v(G;7h+T&!|4`)~|_`?3tAKyoxk
z6yThdW3Z!VyDZtKbNkFdb3+6Y5-gExiRE(%N1ZIorwdcpBa2)!cqE$5@Ri79Iz1gV
zqmfVbSTqq?(30s$I-b64MvdE=dHLS>*wt&-(rb}Kd?}L7nk#xLqDD<EW5yF#l$Z_N
zNIGkI6eXUDn~Jg#sN^$pCh<aG9ssgMiXGi~@qxeC_F7*2##IIxiJc*d8@#%mas(JB
z<yDl|t+h*#CIB!`a%2_l>lR4yq`H-(2bEa!#BhN!B-mJ4UPXx|qMR#=4OfU69?;r4
zjvlgXU=ElgK$NJ>(UCNRo(}+l9Gm>#iUrrM>;C)2U`PIw7r~Cg#O}nSz9++vhY#s*
z!O>&?sL=$rjZ=RBnga1+YQWX69Bm|B8;9^+;PEP$6<6?RAVm*@W~rBCSuZiGaP<*G
zpyU?G(sgoAxJA}!NSM2^08mwH%W9c4O(VXPF|`@P&<&_N#LJR&a|O!kRm5D1qTK<!
zTFz?%_dzh{vp}{;iHY8>Vr%eWZYQ^w`F``e&F8JdhvJdzsq4r7p9g*#cz$)V*m0pG
zkas?$B@YR-|MOBJf$kGRy<NWtJ4*t5PkAdG_VwsEIr2^l!Y_;hja9n?beNxASku51
zh*{PB4`vMuXqg>U{Hg_Hi7QdQa*j=i+E{S3JFgnFsjV7E@)lU}9w1xfkJez(*Ya?9
zXBa;hcP^GB;dNh`2!W;&5xh<REf~bvPN@YL=oJ_c*cX223cI@ZiP47V*S$wdt9=jL
zzm0YXAyjXB=ibcj&EwXdV^5D0w2BoNU_d+Qm%zYeg_+c-9=kxhi8>5kw>Znud6>gE
z&l>5M*#<P{Jap$=$ZfHkpIK~S(PCfBz<1VSH$J!6{3QGqH{AXFQvZ+|GTacN(zO=l
zH5o(C8d}<@Mc<M1ffv651hV#z9hyhEr@3eT={&`9ynFv{G1#7;eG$Cyh(3Dn$=Ktu
zy|11H2ao-OHY&~l@!?EJMU#M`<x>>ruL5|#qTI<u6BP~27oN~foG(5IXW)Yw*aOBJ
zNDwTe7fB})oDBB7ajFW@#$m+=fozjv+nak+#{qfk<Fd%4;E6|+-aYZVr1q15C^en<
zsnlC`Nz#yW3_8!je}P+3R6Pb4bLmT~TFi8gt_^qU`M|mVgn^;()j8e|I*ii47^C7#
PUoRcXFaJ&8W1s&o!z+TX

literal 0
HcmV?d00001

diff --git a/dateutil/__pycache__/_version.cpython-312.pyc b/dateutil/__pycache__/_version.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..8eeecc63ac1258209be3360f7bb497a2d63ce533
GIT binary patch
literal 247
zcmX@j%ge<81fTPr)B1q)V-N=h7@>^MJV3^Dh7^V<h7`sq#!4nl<|<YrJqtY}P3D(O
zK)IJ3K%xl5^3!Cx#a@<LRGgWgcZ(Owh%YHE$Vpwv@ENFp;a8}$RZM6xP)ST;WodCn
zjAKE8OJYf4j8A@YVopp*YHmSHL1uw&Nn%lYYKd-zxtW25ML~8<PG(X}L1jrseqKyU
zVo7RgNoJ0IJk$ccg34bUHo5sJr8%i~MVvreKu#|f1QH*Z85tQra4>KSHL%|hkZj~F
IVh4%>04j<@^8f$<

literal 0
HcmV?d00001

diff --git a/dateutil/__pycache__/easter.cpython-312.pyc b/dateutil/__pycache__/easter.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..4132b41e4ff1cc066f9065580b9bc1f4ec5fad62
GIT binary patch
literal 2848
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
H1>XMvR#6aw

literal 0
HcmV?d00001

diff --git a/dateutil/__pycache__/relativedelta.cpython-312.pyc b/dateutil/__pycache__/relativedelta.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..80619b007d5a6ddaeb85fd88d0a1125017443619
GIT binary patch
literal 28362
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

literal 0
HcmV?d00001

diff --git a/dateutil/__pycache__/rrule.cpython-312.pyc b/dateutil/__pycache__/rrule.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..71f3672f68835a01fc16cd3366ed8e1c8dbf20c1
GIT binary patch
literal 69220
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
L7WK_d9K!z#Hqc>;

literal 0
HcmV?d00001

diff --git a/dateutil/__pycache__/tzwin.cpython-312.pyc b/dateutil/__pycache__/tzwin.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..9501f03fc692714fe5b20cb4f663e45c936d9c4a
GIT binary patch
literal 207
zcmX@j%ge<81fTPr)2xB?V-N=hn4pZ$d_cx@h7^Vr#vF#VOpFYbOq$Fu8G(YDjJFuI
z{D34|NtIrCX5LDM&mcX&f}E{lLW@(2ienNhON%pN9199u5=#<eeDaeMb7DeLa|>b$
zG7EG|5{uGPOLQyD%?vCo3bJEzGLvEoDoZl*^I}pGOHxZqGIR7xs(|L|6;%G>u*uC&
eDa}c>E8+lJ0kXXq#Q4C>$jJDVL9~bs$N>PBK{vDj

literal 0
HcmV?d00001

diff --git a/dateutil/__pycache__/utils.cpython-312.pyc b/dateutil/__pycache__/utils.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..81025d373b76d185432486466d7ca391f4ac99df
GIT binary patch
literal 2560
zcmbVO&2Jk;6yIIjv12DqQxKxGMWcdLuV{=DXdA6)pkGu}sD~!KSeESZ?rgm2dUu(b
zO=8QHQmGOx92!mqaiE7Ds8S^Uk6uz0LABz5!~t<D7%n~WX1r_1QK%3j?|44my!YmP
z{N6m8oXjiGdj2{4yR4%8Dke$O;z4g726q)psVJ6eX|CGRDw-<BDL2(hRZ^{VB@OeO
zmAR=_GS=8lr7~t^q0hF{`gn)smzoYkE#C@Vf_&R1l%Zwf5sF=8`raz>9O9V-Vb4M#
zcU*_JksW#_cYKc_+o#AP*mb;RwC3<;-ol)4r$tyPpD&frDzF1WY+1xI3^Z3dRVwFy
z7rN_ev_JG5)3-<sm<oAJ*P>j)AW921mrXUksQ3dTC@J`QpFww5;e)-E#2m1mw63xh
z?_XDUP^Odp;eS_M5uA6mt$5DIlMPGlDi5`-SXT1CsOTyDI*7_6XjcdiDHsMLBWN3@
ziy1TO$(`zml7JFMJT45zn*^C5r7%SnZX?W5%dtFXxykdAnGs-$TZnfY&-M+uBxEeX
zIbj^s@jV#%aFAoOiHcxCABBuqV$mXC)RrSCM&;<>8o|b(Qr98hGkfV=8Y=HMR*1=8
zc!z<GJML1Fi&U8Hff|kVZ=+|Z@I;jI{Iw`+`mF|N8l{CWnt=^nqdBp!S)7TJ2tB`Y
z&Zu5x5KvXz4q3B$CJ4@Bj;kO0CU&b!q!m;HCz#=wE)zbpe(Gd-em=NXb)7~vX!EA;
zRRwnu!*7d@m4bGZ;XYWN?gI&v@Uc1QHk7|!Rq_Y!9KL;c(|$63WaI45g_nLR9C}<h
z^yS%aE`D|K>yPg9Z_j*h|8VT|lfuGwdZ7oW6mw?`iYS$ldKLzEm9DZPNOrXwT31;V
zdxCOT>#7gctvG%m!Zdszh@>GG31`x!^?Kiw^*WMqBK(bf4|&*GB@j??BEpi}?t5IO
zI%GS9h#k5zdC59%1(5k`P2!=pA0kW%3aG#8K*l0GU;`3`OCd^|c$G*+2;@6R#2#{h
zg=0D#0UD6?csz*E<A{Y2otX87fUZnLKOV-gWXCv#<v2D0IxOGhgmJ^@>n<X8VPOH;
z)Ne_xgbz!+BZT{uLy`b^F~TLUy@`cnP&hsyXD^_ZF_I8l#Kxh^YkiB4oU&}Wj!q9$
zC?37AxODV5nwgz1m&^JHbpV&-#Zh)esY>zKTzU50ner_B(CnP?P8nTYI(JMzj$#S=
zkkf8Tqg;NgT!#LC%lgl9X38go94RQqCyNg;L|{`AdLkItnhy9L;0Tb<#ZX5C7!5*W
zgw0+sw+D!V&jlRTA*vb@Uy<W6jzx_UP{^3G?7?VYiF)1QkRpx^_y{#jWCKie1mOy)
zAd}_a0C5239>QxPG4@g?xothhIZ;Xy^vcG!hWP|6OGu01j0(Jo_KijYJphYG;A3w>
zx1l^UlwAJP_Ko&-_VClG>09H!OikbE-0s|a<yPm(RB=03q*Fj>?gS7q7GLi?bUTY=
zSKCSoA^=ZU?ZE5edaA1xly1t@*0pP|DayJ^Gpf>+<3)fp6#z<CJD#*AfNugD0N4<;
zvWTrgsTp9+2ueVTdt}*lmYoJ5jOB>Og?LLyX5gy^ls|Yx0Mbyv8uCeq-M$UsZIHqZ
zrl+Hn#b-q~7iBEsavbG{Y*-pDC^Efo$_erQaJ-tNqX%K{1Nc}8IzaTiGP!><^ZBKX
z3s0wC-eg}K+_>~~V*1v}&B~93;=L1(3&rhpvENIR>gr`Z7iDWTfT3C~%GYXk2$h}G
zYE&3k7B5+-WbKfClQJJD^0-v#dG5XbyJ~?7p9<r%qtHD|sjB)%I-{olo>0`{Z^|3J
Uu}Ss)KM_*(-iK;d)g_OA08OQ_kpKVy

literal 0
HcmV?d00001

diff --git a/dateutil/_common.py b/dateutil/_common.py
new file mode 100644
index 0000000..4eb2659
--- /dev/null
+++ b/dateutil/_common.py
@@ -0,0 +1,43 @@
+"""
+Common code used in multiple modules.
+"""
+
+
+class weekday(object):
+    __slots__ = ["weekday", "n"]
+
+    def __init__(self, weekday, n=None):
+        self.weekday = weekday
+        self.n = n
+
+    def __call__(self, n):
+        if n == self.n:
+            return self
+        else:
+            return self.__class__(self.weekday, n)
+
+    def __eq__(self, other):
+        try:
+            if self.weekday != other.weekday or self.n != other.n:
+                return False
+        except AttributeError:
+            return False
+        return True
+
+    def __hash__(self):
+        return hash((
+          self.weekday,
+          self.n,
+        ))
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        s = ("MO", "TU", "WE", "TH", "FR", "SA", "SU")[self.weekday]
+        if not self.n:
+            return s
+        else:
+            return "%s(%+d)" % (s, self.n)
+
+# vim:ts=4:sw=4:et
diff --git a/dateutil/_version.py b/dateutil/_version.py
new file mode 100644
index 0000000..b723056
--- /dev/null
+++ b/dateutil/_version.py
@@ -0,0 +1,5 @@
+# coding: utf-8
+# file generated by setuptools_scm
+# don't change, don't track in version control
+version = '2.8.2'
+version_tuple = (2, 8, 2)
diff --git a/dateutil/easter.py b/dateutil/easter.py
new file mode 100644
index 0000000..f74d1f7
--- /dev/null
+++ b/dateutil/easter.py
@@ -0,0 +1,89 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers a generic Easter computing method for any given year, using
+Western, Orthodox or Julian algorithms.
+"""
+
+import datetime
+
+__all__ = ["easter", "EASTER_JULIAN", "EASTER_ORTHODOX", "EASTER_WESTERN"]
+
+EASTER_JULIAN = 1
+EASTER_ORTHODOX = 2
+EASTER_WESTERN = 3
+
+
+def easter(year, method=EASTER_WESTERN):
+    """
+    This method was ported from the work done by GM Arts,
+    on top of the algorithm by Claus Tondering, which was
+    based in part on the algorithm of Ouding (1940), as
+    quoted in "Explanatory Supplement to the Astronomical
+    Almanac", P.  Kenneth Seidelmann, editor.
+
+    This algorithm implements three different Easter
+    calculation methods:
+
+    1. Original calculation in Julian calendar, valid in
+       dates after 326 AD
+    2. Original method, with date converted to Gregorian
+       calendar, valid in years 1583 to 4099
+    3. Revised method, in Gregorian calendar, valid in
+       years 1583 to 4099 as well
+
+    These methods are represented by the constants:
+
+    * ``EASTER_JULIAN   = 1``
+    * ``EASTER_ORTHODOX = 2``
+    * ``EASTER_WESTERN  = 3``
+
+    The default method is method 3.
+
+    More about the algorithm may be found at:
+
+    `GM Arts: Easter Algorithms <http://www.gmarts.org/index.php?go=415>`_
+
+    and
+
+    `The Calendar FAQ: Easter <https://www.tondering.dk/claus/cal/easter.php>`_
+
+    """
+
+    if not (1 <= method <= 3):
+        raise ValueError("invalid method")
+
+    # g - Golden year - 1
+    # c - Century
+    # h - (23 - Epact) mod 30
+    # i - Number of days from March 21 to Paschal Full Moon
+    # j - Weekday for PFM (0=Sunday, etc)
+    # p - Number of days from March 21 to Sunday on or before PFM
+    #     (-6 to 28 methods 1 & 3, to 56 for method 2)
+    # e - Extra days to add for method 2 (converting Julian
+    #     date to Gregorian date)
+
+    y = year
+    g = y % 19
+    e = 0
+    if method < 3:
+        # Old method
+        i = (19*g + 15) % 30
+        j = (y + y//4 + i) % 7
+        if method == 2:
+            # Extra dates to convert Julian to Gregorian date
+            e = 10
+            if y > 1600:
+                e = e + y//100 - 16 - (y//100 - 16)//4
+    else:
+        # New method
+        c = y//100
+        h = (c - c//4 - (8*c + 13)//25 + 19*g + 15) % 30
+        i = h - (h//28)*(1 - (h//28)*(29//(h + 1))*((21 - g)//11))
+        j = (y + y//4 + i + 2 - c + c//4) % 7
+
+    # p can be from -6 to 56 corresponding to dates 22 March to 23 May
+    # (later dates apply to method 2, although 23 May never actually occurs)
+    p = i - j + e
+    d = 1 + (p + 27 + (p + 6)//40) % 31
+    m = 3 + (p + 26)//30
+    return datetime.date(int(y), int(m), int(d))
diff --git a/dateutil/parser/__init__.py b/dateutil/parser/__init__.py
new file mode 100644
index 0000000..d174b0e
--- /dev/null
+++ b/dateutil/parser/__init__.py
@@ -0,0 +1,61 @@
+# -*- coding: utf-8 -*-
+from ._parser import parse, parser, parserinfo, ParserError
+from ._parser import DEFAULTPARSER, DEFAULTTZPARSER
+from ._parser import UnknownTimezoneWarning
+
+from ._parser import __doc__
+
+from .isoparser import isoparser, isoparse
+
+__all__ = ['parse', 'parser', 'parserinfo',
+           'isoparse', 'isoparser',
+           'ParserError',
+           'UnknownTimezoneWarning']
+
+
+###
+# Deprecate portions of the private interface so that downstream code that
+# is improperly relying on it is given *some* notice.
+
+
+def __deprecated_private_func(f):
+    from functools import wraps
+    import warnings
+
+    msg = ('{name} is a private function and may break without warning, '
+           'it will be moved and or renamed in future versions.')
+    msg = msg.format(name=f.__name__)
+
+    @wraps(f)
+    def deprecated_func(*args, **kwargs):
+        warnings.warn(msg, DeprecationWarning)
+        return f(*args, **kwargs)
+
+    return deprecated_func
+
+def __deprecate_private_class(c):
+    import warnings
+
+    msg = ('{name} is a private class and may break without warning, '
+           'it will be moved and or renamed in future versions.')
+    msg = msg.format(name=c.__name__)
+
+    class private_class(c):
+        __doc__ = c.__doc__
+
+        def __init__(self, *args, **kwargs):
+            warnings.warn(msg, DeprecationWarning)
+            super(private_class, self).__init__(*args, **kwargs)
+
+    private_class.__name__ = c.__name__
+
+    return private_class
+
+
+from ._parser import _timelex, _resultbase
+from ._parser import _tzparser, _parsetz
+
+_timelex = __deprecate_private_class(_timelex)
+_tzparser = __deprecate_private_class(_tzparser)
+_resultbase = __deprecate_private_class(_resultbase)
+_parsetz = __deprecated_private_func(_parsetz)
diff --git a/dateutil/parser/__pycache__/__init__.cpython-312.pyc b/dateutil/parser/__pycache__/__init__.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..bc2b7e653eec6280d814bb1a68580bc779901e67
GIT binary patch
literal 2654
zcmb_e-ES0C6u);qc4xm^sK}ReihQ`mmM<eHgtRGWVt^1RflM|TraRLzWoBo+GYhnq
zWQ|R_+eE=cLV1E1A0+U=qkn>lFD31R9VI}F65cA+p!LOb?(UYhsWB$rWX_y(@45G$
zbME<_d%sJi;sn~9*VF$?gpi+5Xf(0T%zX>Y4Pp|LI>e<Kbp=guMNM=iO`_N@K)<ZX
zZbXZ4Sp+$%ML914uV@PAWhdsww3r*$;*<;!Gx8<X5@vLiXh~B6nu4`rpr6*#Zbr-S
zIdPDiv?jM%Yo<gXR?14>r8Ud6G?$we<R&g>7UT@bNvnB5ZXQZxlh1H=Rtn{!!F(%>
z@E;4~wZC2H_rk;p9AZZp^H^30Q-_bd*M0hE?}_e{r;eNqGj*|7t94{)xaM@>LczOK
z=(SyI*eh6P3|6oU127WRb<@l1IxG{jeXqWm(qOYuhGAwB5*bMnNdgI+2VpTF`MSTr
z5`vmIWv&cljEsq65}Xa?XF#t|h#57BBaBO?I4)Mj!6>LLYgIC+Eb9XCp45obxG0bj
zS|ts+LMmcK>K9FURJmK9ctscyPLXWn_%rMPN99Y*DEh<RM+L*RuBf)J8fuZ*7mdJD
z`%8s<V0#7CD442i45@w0GA^i>?BKjt3e-!rXuYZ0z}t?a_F1ayU9?QD?=h8GxTvYx
z1z0L5F-yH@F&`H6JMYj?!ohsqF8;$nw!$~p1?0MTgH)x##W93lY*jH3Y8)YV>m24-
zRTv>QMBpp>89hbr(Bp7;5*it<I&2l0l{e6t#u>|@WUv80j9dT}_|yJSbp3%)sk`O-
zXpX9u%jNl8&%3$PkXe4t7%KVabKS+_VIwedN4>n^<a#Z)m@C@FjsO<2f{x4k-rlu;
zfAK=jvHNnxAqZ9>XF@znf$i+9WztSvw+nWl>z&1+Fk{xOvrHXBKD-B#?`2p0H26^G
zK?k?=4|Oh5z&Wpht^Q^pf0W5%rRi#_n!1*s-q10vbk1a&u5Fpjv`uV#kZGG#+U78J
zSvidH<MlkpXBp^W>w$!kevi3E5GuNk#{&S6*;*XsDjSho*HGpGI;W~#U2Fr+UH6Y>
zvo;ui1wOwA$b6YRlv;m~R?kW_*-gtmkK?JU?bY^)wp;Bt+biu;@vY^aCvv>9`;)W3
z3xd3PP9%}^EON67Np6^w)-&{X3BC|@9A94m1Nfq2!Wd)_M->?tO<|l?=^$z>Yk(@m
z=CXEAY@leI3gmqPSfUl7BKAwBG^&^~psc>uxUljHRY70K(rOKJEDgI1J1apg?-)Kn
z?|;V`Yl1EFi=AsYTLYOi23LedG$=lraE9EcgBZwVO%uU=a2|?@WYSSZlPcsg)nq6n
z!u+m9r>-}0mAmsYS(kJ#IkpAJpMX8DLrJVgR)oB?666D%&0AF-A)i8YM<^5k0Sf>n
zLxin{!K}nu;KwliLfJ1BEr!`$gI_ipO1|avvo)ylDyqbEom;Q#Jk!I}65}~ad@Rl?
zFAZg$`fNLN48QYVBhlF~qZ6k4+kgOizfZPYJytz7@%nV@?&;*7ACt}3I&QZ-NbbDf
zGMVi9X3bQxi)Vi}!c>?M#&zBG%#s6G4U@Y5Vaaf6$YuCM;Fg7{x=(q_aX6&2IFsgU
zSZ+r>L_Y^~7Zkj@SA1X#4D7%`ECYXzl9^SjZ)88uR-!K?A=XXj2vTklL;bACmtt7Q
zxq%RWbZ_}qn1<)NRw^A!lZfpEMYO^H0LWiu@-KDcg(S<}^jCs(g8s(;vuU!a^_F&1
zD<7Md);~_Hos`zrVkkf=1aSE~*5xpvGs`bIL7(AUc<t-KaO2w7ITH*Y&#r=(L9KWB
z1At%qm>3K%Y5oAHodACn;PU_<6$TyvFNfSQwhMK4BiVywFOWN=7EP?F^UA^6;T~f9
zK*Y<?KMQ15q?A4-2d2n@M`Z6qvg2p6@hNG4E{Tb)<>>P@DZ1hLrY5@X#Wq5BJR)yA
oNo=`&b}G?XR%Vi0Z`)JJUFFzJdi&Rjsq|ar#7uqkV}<YhH(@M{<^TWy

literal 0
HcmV?d00001

diff --git a/dateutil/parser/__pycache__/_parser.cpython-312.pyc b/dateutil/parser/__pycache__/_parser.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..b7318dab1e14a70e7d5511bd742156dcf9673402
GIT binary patch
literal 61847
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
WS7=>=!zod%<&EKIA8<Ia?)@LBOd9C`

literal 0
HcmV?d00001

diff --git a/dateutil/parser/__pycache__/isoparser.cpython-312.pyc b/dateutil/parser/__pycache__/isoparser.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..bca395859fb0dd7db1d6ead1e1541f5b3385e1f9
GIT binary patch
literal 15594
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
U=E_z)TON3JWjwon=w|)?A0UcSr2qf`

literal 0
HcmV?d00001

diff --git a/dateutil/parser/_parser.py b/dateutil/parser/_parser.py
new file mode 100644
index 0000000..37d1663
--- /dev/null
+++ b/dateutil/parser/_parser.py
@@ -0,0 +1,1613 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers a generic date/time string parser which is able to parse
+most known formats to represent a date and/or time.
+
+This module attempts to be forgiving with regards to unlikely input formats,
+returning a datetime object even for dates which are ambiguous. If an element
+of a date/time stamp is omitted, the following rules are applied:
+
+- If AM or PM is left unspecified, a 24-hour clock is assumed, however, an hour
+  on a 12-hour clock (``0 <= hour <= 12``) *must* be specified if AM or PM is
+  specified.
+- If a time zone is omitted, a timezone-naive datetime is returned.
+
+If any other elements are missing, they are taken from the
+:class:`datetime.datetime` object passed to the parameter ``default``. If this
+results in a day number exceeding the valid number of days per month, the
+value falls back to the end of the month.
+
+Additional resources about date/time string formats can be found below:
+
+- `A summary of the international standard date and time notation
+  <https://www.cl.cam.ac.uk/~mgk25/iso-time.html>`_
+- `W3C Date and Time Formats <https://www.w3.org/TR/NOTE-datetime>`_
+- `Time Formats (Planetary Rings Node) <https://pds-rings.seti.org:443/tools/time_formats.html>`_
+- `CPAN ParseDate module
+  <https://metacpan.org/pod/release/MUIR/Time-modules-2013.0912/lib/Time/ParseDate.pm>`_
+- `Java SimpleDateFormat Class
+  <https://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html>`_
+"""
+from __future__ import unicode_literals
+
+import datetime
+import re
+import string
+import time
+import warnings
+
+from calendar import monthrange
+from io import StringIO
+
+import six
+from six import integer_types, text_type
+
+from decimal import Decimal
+
+from warnings import warn
+
+from .. import relativedelta
+from .. import tz
+
+__all__ = ["parse", "parserinfo", "ParserError"]
+
+
+# TODO: pandas.core.tools.datetimes imports this explicitly.  Might be worth
+# making public and/or figuring out if there is something we can
+# take off their plate.
+class _timelex(object):
+    # Fractional seconds are sometimes split by a comma
+    _split_decimal = re.compile("([.,])")
+
+    def __init__(self, instream):
+        if isinstance(instream, (bytes, bytearray)):
+            instream = instream.decode()
+
+        if isinstance(instream, text_type):
+            instream = StringIO(instream)
+        elif getattr(instream, 'read', None) is None:
+            raise TypeError('Parser must be a string or character stream, not '
+                            '{itype}'.format(itype=instream.__class__.__name__))
+
+        self.instream = instream
+        self.charstack = []
+        self.tokenstack = []
+        self.eof = False
+
+    def get_token(self):
+        """
+        This function breaks the time string into lexical units (tokens), which
+        can be parsed by the parser. Lexical units are demarcated by changes in
+        the character set, so any continuous string of letters is considered
+        one unit, any continuous string of numbers is considered one unit.
+
+        The main complication arises from the fact that dots ('.') can be used
+        both as separators (e.g. "Sep.20.2009") or decimal points (e.g.
+        "4:30:21.447"). As such, it is necessary to read the full context of
+        any dot-separated strings before breaking it into tokens; as such, this
+        function maintains a "token stack", for when the ambiguous context
+        demands that multiple tokens be parsed at once.
+        """
+        if self.tokenstack:
+            return self.tokenstack.pop(0)
+
+        seenletters = False
+        token = None
+        state = None
+
+        while not self.eof:
+            # We only realize that we've reached the end of a token when we
+            # find a character that's not part of the current token - since
+            # that character may be part of the next token, it's stored in the
+            # charstack.
+            if self.charstack:
+                nextchar = self.charstack.pop(0)
+            else:
+                nextchar = self.instream.read(1)
+                while nextchar == '\x00':
+                    nextchar = self.instream.read(1)
+
+            if not nextchar:
+                self.eof = True
+                break
+            elif not state:
+                # First character of the token - determines if we're starting
+                # to parse a word, a number or something else.
+                token = nextchar
+                if self.isword(nextchar):
+                    state = 'a'
+                elif self.isnum(nextchar):
+                    state = '0'
+                elif self.isspace(nextchar):
+                    token = ' '
+                    break  # emit token
+                else:
+                    break  # emit token
+            elif state == 'a':
+                # If we've already started reading a word, we keep reading
+                # letters until we find something that's not part of a word.
+                seenletters = True
+                if self.isword(nextchar):
+                    token += nextchar
+                elif nextchar == '.':
+                    token += nextchar
+                    state = 'a.'
+                else:
+                    self.charstack.append(nextchar)
+                    break  # emit token
+            elif state == '0':
+                # If we've already started reading a number, we keep reading
+                # numbers until we find something that doesn't fit.
+                if self.isnum(nextchar):
+                    token += nextchar
+                elif nextchar == '.' or (nextchar == ',' and len(token) >= 2):
+                    token += nextchar
+                    state = '0.'
+                else:
+                    self.charstack.append(nextchar)
+                    break  # emit token
+            elif state == 'a.':
+                # If we've seen some letters and a dot separator, continue
+                # parsing, and the tokens will be broken up later.
+                seenletters = True
+                if nextchar == '.' or self.isword(nextchar):
+                    token += nextchar
+                elif self.isnum(nextchar) and token[-1] == '.':
+                    token += nextchar
+                    state = '0.'
+                else:
+                    self.charstack.append(nextchar)
+                    break  # emit token
+            elif state == '0.':
+                # If we've seen at least one dot separator, keep going, we'll
+                # break up the tokens later.
+                if nextchar == '.' or self.isnum(nextchar):
+                    token += nextchar
+                elif self.isword(nextchar) and token[-1] == '.':
+                    token += nextchar
+                    state = 'a.'
+                else:
+                    self.charstack.append(nextchar)
+                    break  # emit token
+
+        if (state in ('a.', '0.') and (seenletters or token.count('.') > 1 or
+                                       token[-1] in '.,')):
+            l = self._split_decimal.split(token)
+            token = l[0]
+            for tok in l[1:]:
+                if tok:
+                    self.tokenstack.append(tok)
+
+        if state == '0.' and token.count('.') == 0:
+            token = token.replace(',', '.')
+
+        return token
+
+    def __iter__(self):
+        return self
+
+    def __next__(self):
+        token = self.get_token()
+        if token is None:
+            raise StopIteration
+
+        return token
+
+    def next(self):
+        return self.__next__()  # Python 2.x support
+
+    @classmethod
+    def split(cls, s):
+        return list(cls(s))
+
+    @classmethod
+    def isword(cls, nextchar):
+        """ Whether or not the next character is part of a word """
+        return nextchar.isalpha()
+
+    @classmethod
+    def isnum(cls, nextchar):
+        """ Whether the next character is part of a number """
+        return nextchar.isdigit()
+
+    @classmethod
+    def isspace(cls, nextchar):
+        """ Whether the next character is whitespace """
+        return nextchar.isspace()
+
+
+class _resultbase(object):
+
+    def __init__(self):
+        for attr in self.__slots__:
+            setattr(self, attr, None)
+
+    def _repr(self, classname):
+        l = []
+        for attr in self.__slots__:
+            value = getattr(self, attr)
+            if value is not None:
+                l.append("%s=%s" % (attr, repr(value)))
+        return "%s(%s)" % (classname, ", ".join(l))
+
+    def __len__(self):
+        return (sum(getattr(self, attr) is not None
+                    for attr in self.__slots__))
+
+    def __repr__(self):
+        return self._repr(self.__class__.__name__)
+
+
+class parserinfo(object):
+    """
+    Class which handles what inputs are accepted. Subclass this to customize
+    the language and acceptable values for each parameter.
+
+    :param dayfirst:
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
+        ``yearfirst`` is set to ``True``, this distinguishes between YDM
+        and YMD. Default is ``False``.
+
+    :param yearfirst:
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the year. If ``True``, the first number is taken
+        to be the year, otherwise the last number is taken to be the year.
+        Default is ``False``.
+    """
+
+    # m from a.m/p.m, t from ISO T separator
+    JUMP = [" ", ".", ",", ";", "-", "/", "'",
+            "at", "on", "and", "ad", "m", "t", "of",
+            "st", "nd", "rd", "th"]
+
+    WEEKDAYS = [("Mon", "Monday"),
+                ("Tue", "Tuesday"),     # TODO: "Tues"
+                ("Wed", "Wednesday"),
+                ("Thu", "Thursday"),    # TODO: "Thurs"
+                ("Fri", "Friday"),
+                ("Sat", "Saturday"),
+                ("Sun", "Sunday")]
+    MONTHS = [("Jan", "January"),
+              ("Feb", "February"),      # TODO: "Febr"
+              ("Mar", "March"),
+              ("Apr", "April"),
+              ("May", "May"),
+              ("Jun", "June"),
+              ("Jul", "July"),
+              ("Aug", "August"),
+              ("Sep", "Sept", "September"),
+              ("Oct", "October"),
+              ("Nov", "November"),
+              ("Dec", "December")]
+    HMS = [("h", "hour", "hours"),
+           ("m", "minute", "minutes"),
+           ("s", "second", "seconds")]
+    AMPM = [("am", "a"),
+            ("pm", "p")]
+    UTCZONE = ["UTC", "GMT", "Z", "z"]
+    PERTAIN = ["of"]
+    TZOFFSET = {}
+    # TODO: ERA = ["AD", "BC", "CE", "BCE", "Stardate",
+    #              "Anno Domini", "Year of Our Lord"]
+
+    def __init__(self, dayfirst=False, yearfirst=False):
+        self._jump = self._convert(self.JUMP)
+        self._weekdays = self._convert(self.WEEKDAYS)
+        self._months = self._convert(self.MONTHS)
+        self._hms = self._convert(self.HMS)
+        self._ampm = self._convert(self.AMPM)
+        self._utczone = self._convert(self.UTCZONE)
+        self._pertain = self._convert(self.PERTAIN)
+
+        self.dayfirst = dayfirst
+        self.yearfirst = yearfirst
+
+        self._year = time.localtime().tm_year
+        self._century = self._year // 100 * 100
+
+    def _convert(self, lst):
+        dct = {}
+        for i, v in enumerate(lst):
+            if isinstance(v, tuple):
+                for v in v:
+                    dct[v.lower()] = i
+            else:
+                dct[v.lower()] = i
+        return dct
+
+    def jump(self, name):
+        return name.lower() in self._jump
+
+    def weekday(self, name):
+        try:
+            return self._weekdays[name.lower()]
+        except KeyError:
+            pass
+        return None
+
+    def month(self, name):
+        try:
+            return self._months[name.lower()] + 1
+        except KeyError:
+            pass
+        return None
+
+    def hms(self, name):
+        try:
+            return self._hms[name.lower()]
+        except KeyError:
+            return None
+
+    def ampm(self, name):
+        try:
+            return self._ampm[name.lower()]
+        except KeyError:
+            return None
+
+    def pertain(self, name):
+        return name.lower() in self._pertain
+
+    def utczone(self, name):
+        return name.lower() in self._utczone
+
+    def tzoffset(self, name):
+        if name in self._utczone:
+            return 0
+
+        return self.TZOFFSET.get(name)
+
+    def convertyear(self, year, century_specified=False):
+        """
+        Converts two-digit years to year within [-50, 49]
+        range of self._year (current local time)
+        """
+
+        # Function contract is that the year is always positive
+        assert year >= 0
+
+        if year < 100 and not century_specified:
+            # assume current century to start
+            year += self._century
+
+            if year >= self._year + 50:  # if too far in future
+                year -= 100
+            elif year < self._year - 50:  # if too far in past
+                year += 100
+
+        return year
+
+    def validate(self, res):
+        # move to info
+        if res.year is not None:
+            res.year = self.convertyear(res.year, res.century_specified)
+
+        if ((res.tzoffset == 0 and not res.tzname) or
+             (res.tzname == 'Z' or res.tzname == 'z')):
+            res.tzname = "UTC"
+            res.tzoffset = 0
+        elif res.tzoffset != 0 and res.tzname and self.utczone(res.tzname):
+            res.tzoffset = 0
+        return True
+
+
+class _ymd(list):
+    def __init__(self, *args, **kwargs):
+        super(self.__class__, self).__init__(*args, **kwargs)
+        self.century_specified = False
+        self.dstridx = None
+        self.mstridx = None
+        self.ystridx = None
+
+    @property
+    def has_year(self):
+        return self.ystridx is not None
+
+    @property
+    def has_month(self):
+        return self.mstridx is not None
+
+    @property
+    def has_day(self):
+        return self.dstridx is not None
+
+    def could_be_day(self, value):
+        if self.has_day:
+            return False
+        elif not self.has_month:
+            return 1 <= value <= 31
+        elif not self.has_year:
+            # Be permissive, assume leap year
+            month = self[self.mstridx]
+            return 1 <= value <= monthrange(2000, month)[1]
+        else:
+            month = self[self.mstridx]
+            year = self[self.ystridx]
+            return 1 <= value <= monthrange(year, month)[1]
+
+    def append(self, val, label=None):
+        if hasattr(val, '__len__'):
+            if val.isdigit() and len(val) > 2:
+                self.century_specified = True
+                if label not in [None, 'Y']:  # pragma: no cover
+                    raise ValueError(label)
+                label = 'Y'
+        elif val > 100:
+            self.century_specified = True
+            if label not in [None, 'Y']:  # pragma: no cover
+                raise ValueError(label)
+            label = 'Y'
+
+        super(self.__class__, self).append(int(val))
+
+        if label == 'M':
+            if self.has_month:
+                raise ValueError('Month is already set')
+            self.mstridx = len(self) - 1
+        elif label == 'D':
+            if self.has_day:
+                raise ValueError('Day is already set')
+            self.dstridx = len(self) - 1
+        elif label == 'Y':
+            if self.has_year:
+                raise ValueError('Year is already set')
+            self.ystridx = len(self) - 1
+
+    def _resolve_from_stridxs(self, strids):
+        """
+        Try to resolve the identities of year/month/day elements using
+        ystridx, mstridx, and dstridx, if enough of these are specified.
+        """
+        if len(self) == 3 and len(strids) == 2:
+            # we can back out the remaining stridx value
+            missing = [x for x in range(3) if x not in strids.values()]
+            key = [x for x in ['y', 'm', 'd'] if x not in strids]
+            assert len(missing) == len(key) == 1
+            key = key[0]
+            val = missing[0]
+            strids[key] = val
+
+        assert len(self) == len(strids)  # otherwise this should not be called
+        out = {key: self[strids[key]] for key in strids}
+        return (out.get('y'), out.get('m'), out.get('d'))
+
+    def resolve_ymd(self, yearfirst, dayfirst):
+        len_ymd = len(self)
+        year, month, day = (None, None, None)
+
+        strids = (('y', self.ystridx),
+                  ('m', self.mstridx),
+                  ('d', self.dstridx))
+
+        strids = {key: val for key, val in strids if val is not None}
+        if (len(self) == len(strids) > 0 or
+                (len(self) == 3 and len(strids) == 2)):
+            return self._resolve_from_stridxs(strids)
+
+        mstridx = self.mstridx
+
+        if len_ymd > 3:
+            raise ValueError("More than three YMD values")
+        elif len_ymd == 1 or (mstridx is not None and len_ymd == 2):
+            # One member, or two members with a month string
+            if mstridx is not None:
+                month = self[mstridx]
+                # since mstridx is 0 or 1, self[mstridx-1] always
+                # looks up the other element
+                other = self[mstridx - 1]
+            else:
+                other = self[0]
+
+            if len_ymd > 1 or mstridx is None:
+                if other > 31:
+                    year = other
+                else:
+                    day = other
+
+        elif len_ymd == 2:
+            # Two members with numbers
+            if self[0] > 31:
+                # 99-01
+                year, month = self
+            elif self[1] > 31:
+                # 01-99
+                month, year = self
+            elif dayfirst and self[1] <= 12:
+                # 13-01
+                day, month = self
+            else:
+                # 01-13
+                month, day = self
+
+        elif len_ymd == 3:
+            # Three members
+            if mstridx == 0:
+                if self[1] > 31:
+                    # Apr-2003-25
+                    month, year, day = self
+                else:
+                    month, day, year = self
+            elif mstridx == 1:
+                if self[0] > 31 or (yearfirst and self[2] <= 31):
+                    # 99-Jan-01
+                    year, month, day = self
+                else:
+                    # 01-Jan-01
+                    # Give precedence to day-first, since
+                    # two-digit years is usually hand-written.
+                    day, month, year = self
+
+            elif mstridx == 2:
+                # WTF!?
+                if self[1] > 31:
+                    # 01-99-Jan
+                    day, year, month = self
+                else:
+                    # 99-01-Jan
+                    year, day, month = self
+
+            else:
+                if (self[0] > 31 or
+                    self.ystridx == 0 or
+                        (yearfirst and self[1] <= 12 and self[2] <= 31)):
+                    # 99-01-01
+                    if dayfirst and self[2] <= 12:
+                        year, day, month = self
+                    else:
+                        year, month, day = self
+                elif self[0] > 12 or (dayfirst and self[1] <= 12):
+                    # 13-01-01
+                    day, month, year = self
+                else:
+                    # 01-13-01
+                    month, day, year = self
+
+        return year, month, day
+
+
+class parser(object):
+    def __init__(self, info=None):
+        self.info = info or parserinfo()
+
+    def parse(self, timestr, default=None,
+              ignoretz=False, tzinfos=None, **kwargs):
+        """
+        Parse the date/time string into a :class:`datetime.datetime` object.
+
+        :param timestr:
+            Any date/time string using the supported formats.
+
+        :param default:
+            The default datetime object, if this is a datetime object and not
+            ``None``, elements specified in ``timestr`` replace elements in the
+            default object.
+
+        :param ignoretz:
+            If set ``True``, time zones in parsed strings are ignored and a
+            naive :class:`datetime.datetime` object is returned.
+
+        :param tzinfos:
+            Additional time zone names / aliases which may be present in the
+            string. This argument maps time zone names (and optionally offsets
+            from those time zones) to time zones. This parameter can be a
+            dictionary with timezone aliases mapping time zone names to time
+            zones or a function taking two parameters (``tzname`` and
+            ``tzoffset``) and returning a time zone.
+
+            The timezones to which the names are mapped can be an integer
+            offset from UTC in seconds or a :class:`tzinfo` object.
+
+            .. doctest::
+               :options: +NORMALIZE_WHITESPACE
+
+                >>> from dateutil.parser import parse
+                >>> from dateutil.tz import gettz
+                >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
+                >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
+                datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
+                >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
+                datetime.datetime(2012, 1, 19, 17, 21,
+                                  tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))
+
+            This parameter is ignored if ``ignoretz`` is set.
+
+        :param \\*\\*kwargs:
+            Keyword arguments as passed to ``_parse()``.
+
+        :return:
+            Returns a :class:`datetime.datetime` object or, if the
+            ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
+            first element being a :class:`datetime.datetime` object, the second
+            a tuple containing the fuzzy tokens.
+
+        :raises ParserError:
+            Raised for invalid or unknown string format, if the provided
+            :class:`tzinfo` is not in a valid format, or if an invalid date
+            would be created.
+
+        :raises TypeError:
+            Raised for non-string or character stream input.
+
+        :raises OverflowError:
+            Raised if the parsed date exceeds the largest valid C integer on
+            your system.
+        """
+
+        if default is None:
+            default = datetime.datetime.now().replace(hour=0, minute=0,
+                                                      second=0, microsecond=0)
+
+        res, skipped_tokens = self._parse(timestr, **kwargs)
+
+        if res is None:
+            raise ParserError("Unknown string format: %s", timestr)
+
+        if len(res) == 0:
+            raise ParserError("String does not contain a date: %s", timestr)
+
+        try:
+            ret = self._build_naive(res, default)
+        except ValueError as e:
+            six.raise_from(ParserError(str(e) + ": %s", timestr), e)
+
+        if not ignoretz:
+            ret = self._build_tzaware(ret, res, tzinfos)
+
+        if kwargs.get('fuzzy_with_tokens', False):
+            return ret, skipped_tokens
+        else:
+            return ret
+
+    class _result(_resultbase):
+        __slots__ = ["year", "month", "day", "weekday",
+                     "hour", "minute", "second", "microsecond",
+                     "tzname", "tzoffset", "ampm","any_unused_tokens"]
+
+    def _parse(self, timestr, dayfirst=None, yearfirst=None, fuzzy=False,
+               fuzzy_with_tokens=False):
+        """
+        Private method which performs the heavy lifting of parsing, called from
+        ``parse()``, which passes on its ``kwargs`` to this function.
+
+        :param timestr:
+            The string to parse.
+
+        :param dayfirst:
+            Whether to interpret the first value in an ambiguous 3-integer date
+            (e.g. 01/05/09) as the day (``True``) or month (``False``). If
+            ``yearfirst`` is set to ``True``, this distinguishes between YDM
+            and YMD. If set to ``None``, this value is retrieved from the
+            current :class:`parserinfo` object (which itself defaults to
+            ``False``).
+
+        :param yearfirst:
+            Whether to interpret the first value in an ambiguous 3-integer date
+            (e.g. 01/05/09) as the year. If ``True``, the first number is taken
+            to be the year, otherwise the last number is taken to be the year.
+            If this is set to ``None``, the value is retrieved from the current
+            :class:`parserinfo` object (which itself defaults to ``False``).
+
+        :param fuzzy:
+            Whether to allow fuzzy parsing, allowing for string like "Today is
+            January 1, 2047 at 8:21:00AM".
+
+        :param fuzzy_with_tokens:
+            If ``True``, ``fuzzy`` is automatically set to True, and the parser
+            will return a tuple where the first element is the parsed
+            :class:`datetime.datetime` datetimestamp and the second element is
+            a tuple containing the portions of the string which were ignored:
+
+            .. doctest::
+
+                >>> from dateutil.parser import parse
+                >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
+                (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))
+
+        """
+        if fuzzy_with_tokens:
+            fuzzy = True
+
+        info = self.info
+
+        if dayfirst is None:
+            dayfirst = info.dayfirst
+
+        if yearfirst is None:
+            yearfirst = info.yearfirst
+
+        res = self._result()
+        l = _timelex.split(timestr)         # Splits the timestr into tokens
+
+        skipped_idxs = []
+
+        # year/month/day list
+        ymd = _ymd()
+
+        len_l = len(l)
+        i = 0
+        try:
+            while i < len_l:
+
+                # Check if it's a number
+                value_repr = l[i]
+                try:
+                    value = float(value_repr)
+                except ValueError:
+                    value = None
+
+                if value is not None:
+                    # Numeric token
+                    i = self._parse_numeric_token(l, i, info, ymd, res, fuzzy)
+
+                # Check weekday
+                elif info.weekday(l[i]) is not None:
+                    value = info.weekday(l[i])
+                    res.weekday = value
+
+                # Check month name
+                elif info.month(l[i]) is not None:
+                    value = info.month(l[i])
+                    ymd.append(value, 'M')
+
+                    if i + 1 < len_l:
+                        if l[i + 1] in ('-', '/'):
+                            # Jan-01[-99]
+                            sep = l[i + 1]
+                            ymd.append(l[i + 2])
+
+                            if i + 3 < len_l and l[i + 3] == sep:
+                                # Jan-01-99
+                                ymd.append(l[i + 4])
+                                i += 2
+
+                            i += 2
+
+                        elif (i + 4 < len_l and l[i + 1] == l[i + 3] == ' ' and
+                              info.pertain(l[i + 2])):
+                            # Jan of 01
+                            # In this case, 01 is clearly year
+                            if l[i + 4].isdigit():
+                                # Convert it here to become unambiguous
+                                value = int(l[i + 4])
+                                year = str(info.convertyear(value))
+                                ymd.append(year, 'Y')
+                            else:
+                                # Wrong guess
+                                pass
+                                # TODO: not hit in tests
+                            i += 4
+
+                # Check am/pm
+                elif info.ampm(l[i]) is not None:
+                    value = info.ampm(l[i])
+                    val_is_ampm = self._ampm_valid(res.hour, res.ampm, fuzzy)
+
+                    if val_is_ampm:
+                        res.hour = self._adjust_ampm(res.hour, value)
+                        res.ampm = value
+
+                    elif fuzzy:
+                        skipped_idxs.append(i)
+
+                # Check for a timezone name
+                elif self._could_be_tzname(res.hour, res.tzname, res.tzoffset, l[i]):
+                    res.tzname = l[i]
+                    res.tzoffset = info.tzoffset(res.tzname)
+
+                    # Check for something like GMT+3, or BRST+3. Notice
+                    # that it doesn't mean "I am 3 hours after GMT", but
+                    # "my time +3 is GMT". If found, we reverse the
+                    # logic so that timezone parsing code will get it
+                    # right.
+                    if i + 1 < len_l and l[i + 1] in ('+', '-'):
+                        l[i + 1] = ('+', '-')[l[i + 1] == '+']
+                        res.tzoffset = None
+                        if info.utczone(res.tzname):
+                            # With something like GMT+3, the timezone
+                            # is *not* GMT.
+                            res.tzname = None
+
+                # Check for a numbered timezone
+                elif res.hour is not None and l[i] in ('+', '-'):
+                    signal = (-1, 1)[l[i] == '+']
+                    len_li = len(l[i + 1])
+
+                    # TODO: check that l[i + 1] is integer?
+                    if len_li == 4:
+                        # -0300
+                        hour_offset = int(l[i + 1][:2])
+                        min_offset = int(l[i + 1][2:])
+                    elif i + 2 < len_l and l[i + 2] == ':':
+                        # -03:00
+                        hour_offset = int(l[i + 1])
+                        min_offset = int(l[i + 3])  # TODO: Check that l[i+3] is minute-like?
+                        i += 2
+                    elif len_li <= 2:
+                        # -[0]3
+                        hour_offset = int(l[i + 1][:2])
+                        min_offset = 0
+                    else:
+                        raise ValueError(timestr)
+
+                    res.tzoffset = signal * (hour_offset * 3600 + min_offset * 60)
+
+                    # Look for a timezone name between parenthesis
+                    if (i + 5 < len_l and
+                            info.jump(l[i + 2]) and l[i + 3] == '(' and
+                            l[i + 5] == ')' and
+                            3 <= len(l[i + 4]) and
+                            self._could_be_tzname(res.hour, res.tzname,
+                                                  None, l[i + 4])):
+                        # -0300 (BRST)
+                        res.tzname = l[i + 4]
+                        i += 4
+
+                    i += 1
+
+                # Check jumps
+                elif not (info.jump(l[i]) or fuzzy):
+                    raise ValueError(timestr)
+
+                else:
+                    skipped_idxs.append(i)
+                i += 1
+
+            # Process year/month/day
+            year, month, day = ymd.resolve_ymd(yearfirst, dayfirst)
+
+            res.century_specified = ymd.century_specified
+            res.year = year
+            res.month = month
+            res.day = day
+
+        except (IndexError, ValueError):
+            return None, None
+
+        if not info.validate(res):
+            return None, None
+
+        if fuzzy_with_tokens:
+            skipped_tokens = self._recombine_skipped(l, skipped_idxs)
+            return res, tuple(skipped_tokens)
+        else:
+            return res, None
+
+    def _parse_numeric_token(self, tokens, idx, info, ymd, res, fuzzy):
+        # Token is a number
+        value_repr = tokens[idx]
+        try:
+            value = self._to_decimal(value_repr)
+        except Exception as e:
+            six.raise_from(ValueError('Unknown numeric token'), e)
+
+        len_li = len(value_repr)
+
+        len_l = len(tokens)
+
+        if (len(ymd) == 3 and len_li in (2, 4) and
+            res.hour is None and
+            (idx + 1 >= len_l or
+             (tokens[idx + 1] != ':' and
+              info.hms(tokens[idx + 1]) is None))):
+            # 19990101T23[59]
+            s = tokens[idx]
+            res.hour = int(s[:2])
+
+            if len_li == 4:
+                res.minute = int(s[2:])
+
+        elif len_li == 6 or (len_li > 6 and tokens[idx].find('.') == 6):
+            # YYMMDD or HHMMSS[.ss]
+            s = tokens[idx]
+
+            if not ymd and '.' not in tokens[idx]:
+                ymd.append(s[:2])
+                ymd.append(s[2:4])
+                ymd.append(s[4:])
+            else:
+                # 19990101T235959[.59]
+
+                # TODO: Check if res attributes already set.
+                res.hour = int(s[:2])
+                res.minute = int(s[2:4])
+                res.second, res.microsecond = self._parsems(s[4:])
+
+        elif len_li in (8, 12, 14):
+            # YYYYMMDD
+            s = tokens[idx]
+            ymd.append(s[:4], 'Y')
+            ymd.append(s[4:6])
+            ymd.append(s[6:8])
+
+            if len_li > 8:
+                res.hour = int(s[8:10])
+                res.minute = int(s[10:12])
+
+                if len_li > 12:
+                    res.second = int(s[12:])
+
+        elif self._find_hms_idx(idx, tokens, info, allow_jump=True) is not None:
+            # HH[ ]h or MM[ ]m or SS[.ss][ ]s
+            hms_idx = self._find_hms_idx(idx, tokens, info, allow_jump=True)
+            (idx, hms) = self._parse_hms(idx, tokens, info, hms_idx)
+            if hms is not None:
+                # TODO: checking that hour/minute/second are not
+                # already set?
+                self._assign_hms(res, value_repr, hms)
+
+        elif idx + 2 < len_l and tokens[idx + 1] == ':':
+            # HH:MM[:SS[.ss]]
+            res.hour = int(value)
+            value = self._to_decimal(tokens[idx + 2])  # TODO: try/except for this?
+            (res.minute, res.second) = self._parse_min_sec(value)
+
+            if idx + 4 < len_l and tokens[idx + 3] == ':':
+                res.second, res.microsecond = self._parsems(tokens[idx + 4])
+
+                idx += 2
+
+            idx += 2
+
+        elif idx + 1 < len_l and tokens[idx + 1] in ('-', '/', '.'):
+            sep = tokens[idx + 1]
+            ymd.append(value_repr)
+
+            if idx + 2 < len_l and not info.jump(tokens[idx + 2]):
+                if tokens[idx + 2].isdigit():
+                    # 01-01[-01]
+                    ymd.append(tokens[idx + 2])
+                else:
+                    # 01-Jan[-01]
+                    value = info.month(tokens[idx + 2])
+
+                    if value is not None:
+                        ymd.append(value, 'M')
+                    else:
+                        raise ValueError()
+
+                if idx + 3 < len_l and tokens[idx + 3] == sep:
+                    # We have three members
+                    value = info.month(tokens[idx + 4])
+
+                    if value is not None:
+                        ymd.append(value, 'M')
+                    else:
+                        ymd.append(tokens[idx + 4])
+                    idx += 2
+
+                idx += 1
+            idx += 1
+
+        elif idx + 1 >= len_l or info.jump(tokens[idx + 1]):
+            if idx + 2 < len_l and info.ampm(tokens[idx + 2]) is not None:
+                # 12 am
+                hour = int(value)
+                res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 2]))
+                idx += 1
+            else:
+                # Year, month or day
+                ymd.append(value)
+            idx += 1
+
+        elif info.ampm(tokens[idx + 1]) is not None and (0 <= value < 24):
+            # 12am
+            hour = int(value)
+            res.hour = self._adjust_ampm(hour, info.ampm(tokens[idx + 1]))
+            idx += 1
+
+        elif ymd.could_be_day(value):
+            ymd.append(value)
+
+        elif not fuzzy:
+            raise ValueError()
+
+        return idx
+
+    def _find_hms_idx(self, idx, tokens, info, allow_jump):
+        len_l = len(tokens)
+
+        if idx+1 < len_l and info.hms(tokens[idx+1]) is not None:
+            # There is an "h", "m", or "s" label following this token.  We take
+            # assign the upcoming label to the current token.
+            # e.g. the "12" in 12h"
+            hms_idx = idx + 1
+
+        elif (allow_jump and idx+2 < len_l and tokens[idx+1] == ' ' and
+              info.hms(tokens[idx+2]) is not None):
+            # There is a space and then an "h", "m", or "s" label.
+            # e.g. the "12" in "12 h"
+            hms_idx = idx + 2
+
+        elif idx > 0 and info.hms(tokens[idx-1]) is not None:
+            # There is a "h", "m", or "s" preceding this token.  Since neither
+            # of the previous cases was hit, there is no label following this
+            # token, so we use the previous label.
+            # e.g. the "04" in "12h04"
+            hms_idx = idx-1
+
+        elif (1 < idx == len_l-1 and tokens[idx-1] == ' ' and
+              info.hms(tokens[idx-2]) is not None):
+            # If we are looking at the final token, we allow for a
+            # backward-looking check to skip over a space.
+            # TODO: Are we sure this is the right condition here?
+            hms_idx = idx - 2
+
+        else:
+            hms_idx = None
+
+        return hms_idx
+
+    def _assign_hms(self, res, value_repr, hms):
+        # See GH issue #427, fixing float rounding
+        value = self._to_decimal(value_repr)
+
+        if hms == 0:
+            # Hour
+            res.hour = int(value)
+            if value % 1:
+                res.minute = int(60*(value % 1))
+
+        elif hms == 1:
+            (res.minute, res.second) = self._parse_min_sec(value)
+
+        elif hms == 2:
+            (res.second, res.microsecond) = self._parsems(value_repr)
+
+    def _could_be_tzname(self, hour, tzname, tzoffset, token):
+        return (hour is not None and
+                tzname is None and
+                tzoffset is None and
+                len(token) <= 5 and
+                (all(x in string.ascii_uppercase for x in token)
+                 or token in self.info.UTCZONE))
+
+    def _ampm_valid(self, hour, ampm, fuzzy):
+        """
+        For fuzzy parsing, 'a' or 'am' (both valid English words)
+        may erroneously trigger the AM/PM flag. Deal with that
+        here.
+        """
+        val_is_ampm = True
+
+        # If there's already an AM/PM flag, this one isn't one.
+        if fuzzy and ampm is not None:
+            val_is_ampm = False
+
+        # If AM/PM is found and hour is not, raise a ValueError
+        if hour is None:
+            if fuzzy:
+                val_is_ampm = False
+            else:
+                raise ValueError('No hour specified with AM or PM flag.')
+        elif not 0 <= hour <= 12:
+            # If AM/PM is found, it's a 12 hour clock, so raise
+            # an error for invalid range
+            if fuzzy:
+                val_is_ampm = False
+            else:
+                raise ValueError('Invalid hour specified for 12-hour clock.')
+
+        return val_is_ampm
+
+    def _adjust_ampm(self, hour, ampm):
+        if hour < 12 and ampm == 1:
+            hour += 12
+        elif hour == 12 and ampm == 0:
+            hour = 0
+        return hour
+
+    def _parse_min_sec(self, value):
+        # TODO: Every usage of this function sets res.second to the return
+        # value. Are there any cases where second will be returned as None and
+        # we *don't* want to set res.second = None?
+        minute = int(value)
+        second = None
+
+        sec_remainder = value % 1
+        if sec_remainder:
+            second = int(60 * sec_remainder)
+        return (minute, second)
+
+    def _parse_hms(self, idx, tokens, info, hms_idx):
+        # TODO: Is this going to admit a lot of false-positives for when we
+        # just happen to have digits and "h", "m" or "s" characters in non-date
+        # text?  I guess hex hashes won't have that problem, but there's plenty
+        # of random junk out there.
+        if hms_idx is None:
+            hms = None
+            new_idx = idx
+        elif hms_idx > idx:
+            hms = info.hms(tokens[hms_idx])
+            new_idx = hms_idx
+        else:
+            # Looking backwards, increment one.
+            hms = info.hms(tokens[hms_idx]) + 1
+            new_idx = idx
+
+        return (new_idx, hms)
+
+    # ------------------------------------------------------------------
+    # Handling for individual tokens.  These are kept as methods instead
+    #  of functions for the sake of customizability via subclassing.
+
+    def _parsems(self, value):
+        """Parse a I[.F] seconds value into (seconds, microseconds)."""
+        if "." not in value:
+            return int(value), 0
+        else:
+            i, f = value.split(".")
+            return int(i), int(f.ljust(6, "0")[:6])
+
+    def _to_decimal(self, val):
+        try:
+            decimal_value = Decimal(val)
+            # See GH 662, edge case, infinite value should not be converted
+            #  via `_to_decimal`
+            if not decimal_value.is_finite():
+                raise ValueError("Converted decimal value is infinite or NaN")
+        except Exception as e:
+            msg = "Could not convert %s to decimal" % val
+            six.raise_from(ValueError(msg), e)
+        else:
+            return decimal_value
+
+    # ------------------------------------------------------------------
+    # Post-Parsing construction of datetime output.  These are kept as
+    #  methods instead of functions for the sake of customizability via
+    #  subclassing.
+
+    def _build_tzinfo(self, tzinfos, tzname, tzoffset):
+        if callable(tzinfos):
+            tzdata = tzinfos(tzname, tzoffset)
+        else:
+            tzdata = tzinfos.get(tzname)
+        # handle case where tzinfo is paased an options that returns None
+        # eg tzinfos = {'BRST' : None}
+        if isinstance(tzdata, datetime.tzinfo) or tzdata is None:
+            tzinfo = tzdata
+        elif isinstance(tzdata, text_type):
+            tzinfo = tz.tzstr(tzdata)
+        elif isinstance(tzdata, integer_types):
+            tzinfo = tz.tzoffset(tzname, tzdata)
+        else:
+            raise TypeError("Offset must be tzinfo subclass, tz string, "
+                            "or int offset.")
+        return tzinfo
+
+    def _build_tzaware(self, naive, res, tzinfos):
+        if (callable(tzinfos) or (tzinfos and res.tzname in tzinfos)):
+            tzinfo = self._build_tzinfo(tzinfos, res.tzname, res.tzoffset)
+            aware = naive.replace(tzinfo=tzinfo)
+            aware = self._assign_tzname(aware, res.tzname)
+
+        elif res.tzname and res.tzname in time.tzname:
+            aware = naive.replace(tzinfo=tz.tzlocal())
+
+            # Handle ambiguous local datetime
+            aware = self._assign_tzname(aware, res.tzname)
+
+            # This is mostly relevant for winter GMT zones parsed in the UK
+            if (aware.tzname() != res.tzname and
+                    res.tzname in self.info.UTCZONE):
+                aware = aware.replace(tzinfo=tz.UTC)
+
+        elif res.tzoffset == 0:
+            aware = naive.replace(tzinfo=tz.UTC)
+
+        elif res.tzoffset:
+            aware = naive.replace(tzinfo=tz.tzoffset(res.tzname, res.tzoffset))
+
+        elif not res.tzname and not res.tzoffset:
+            # i.e. no timezone information was found.
+            aware = naive
+
+        elif res.tzname:
+            # tz-like string was parsed but we don't know what to do
+            # with it
+            warnings.warn("tzname {tzname} identified but not understood.  "
+                          "Pass `tzinfos` argument in order to correctly "
+                          "return a timezone-aware datetime.  In a future "
+                          "version, this will raise an "
+                          "exception.".format(tzname=res.tzname),
+                          category=UnknownTimezoneWarning)
+            aware = naive
+
+        return aware
+
+    def _build_naive(self, res, default):
+        repl = {}
+        for attr in ("year", "month", "day", "hour",
+                     "minute", "second", "microsecond"):
+            value = getattr(res, attr)
+            if value is not None:
+                repl[attr] = value
+
+        if 'day' not in repl:
+            # If the default day exceeds the last day of the month, fall back
+            # to the end of the month.
+            cyear = default.year if res.year is None else res.year
+            cmonth = default.month if res.month is None else res.month
+            cday = default.day if res.day is None else res.day
+
+            if cday > monthrange(cyear, cmonth)[1]:
+                repl['day'] = monthrange(cyear, cmonth)[1]
+
+        naive = default.replace(**repl)
+
+        if res.weekday is not None and not res.day:
+            naive = naive + relativedelta.relativedelta(weekday=res.weekday)
+
+        return naive
+
+    def _assign_tzname(self, dt, tzname):
+        if dt.tzname() != tzname:
+            new_dt = tz.enfold(dt, fold=1)
+            if new_dt.tzname() == tzname:
+                return new_dt
+
+        return dt
+
+    def _recombine_skipped(self, tokens, skipped_idxs):
+        """
+        >>> tokens = ["foo", " ", "bar", " ", "19June2000", "baz"]
+        >>> skipped_idxs = [0, 1, 2, 5]
+        >>> _recombine_skipped(tokens, skipped_idxs)
+        ["foo bar", "baz"]
+        """
+        skipped_tokens = []
+        for i, idx in enumerate(sorted(skipped_idxs)):
+            if i > 0 and idx - 1 == skipped_idxs[i - 1]:
+                skipped_tokens[-1] = skipped_tokens[-1] + tokens[idx]
+            else:
+                skipped_tokens.append(tokens[idx])
+
+        return skipped_tokens
+
+
+DEFAULTPARSER = parser()
+
+
+def parse(timestr, parserinfo=None, **kwargs):
+    """
+
+    Parse a string in one of the supported formats, using the
+    ``parserinfo`` parameters.
+
+    :param timestr:
+        A string containing a date/time stamp.
+
+    :param parserinfo:
+        A :class:`parserinfo` object containing parameters for the parser.
+        If ``None``, the default arguments to the :class:`parserinfo`
+        constructor are used.
+
+    The ``**kwargs`` parameter takes the following keyword arguments:
+
+    :param default:
+        The default datetime object, if this is a datetime object and not
+        ``None``, elements specified in ``timestr`` replace elements in the
+        default object.
+
+    :param ignoretz:
+        If set ``True``, time zones in parsed strings are ignored and a naive
+        :class:`datetime` object is returned.
+
+    :param tzinfos:
+        Additional time zone names / aliases which may be present in the
+        string. This argument maps time zone names (and optionally offsets
+        from those time zones) to time zones. This parameter can be a
+        dictionary with timezone aliases mapping time zone names to time
+        zones or a function taking two parameters (``tzname`` and
+        ``tzoffset``) and returning a time zone.
+
+        The timezones to which the names are mapped can be an integer
+        offset from UTC in seconds or a :class:`tzinfo` object.
+
+        .. doctest::
+           :options: +NORMALIZE_WHITESPACE
+
+            >>> from dateutil.parser import parse
+            >>> from dateutil.tz import gettz
+            >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
+            >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
+            datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
+            >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
+            datetime.datetime(2012, 1, 19, 17, 21,
+                              tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))
+
+        This parameter is ignored if ``ignoretz`` is set.
+
+    :param dayfirst:
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the day (``True``) or month (``False``). If
+        ``yearfirst`` is set to ``True``, this distinguishes between YDM and
+        YMD. If set to ``None``, this value is retrieved from the current
+        :class:`parserinfo` object (which itself defaults to ``False``).
+
+    :param yearfirst:
+        Whether to interpret the first value in an ambiguous 3-integer date
+        (e.g. 01/05/09) as the year. If ``True``, the first number is taken to
+        be the year, otherwise the last number is taken to be the year. If
+        this is set to ``None``, the value is retrieved from the current
+        :class:`parserinfo` object (which itself defaults to ``False``).
+
+    :param fuzzy:
+        Whether to allow fuzzy parsing, allowing for string like "Today is
+        January 1, 2047 at 8:21:00AM".
+
+    :param fuzzy_with_tokens:
+        If ``True``, ``fuzzy`` is automatically set to True, and the parser
+        will return a tuple where the first element is the parsed
+        :class:`datetime.datetime` datetimestamp and the second element is
+        a tuple containing the portions of the string which were ignored:
+
+        .. doctest::
+
+            >>> from dateutil.parser import parse
+            >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
+            (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))
+
+    :return:
+        Returns a :class:`datetime.datetime` object or, if the
+        ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
+        first element being a :class:`datetime.datetime` object, the second
+        a tuple containing the fuzzy tokens.
+
+    :raises ParserError:
+        Raised for invalid or unknown string formats, if the provided
+        :class:`tzinfo` is not in a valid format, or if an invalid date would
+        be created.
+
+    :raises OverflowError:
+        Raised if the parsed date exceeds the largest valid C integer on
+        your system.
+    """
+    if parserinfo:
+        return parser(parserinfo).parse(timestr, **kwargs)
+    else:
+        return DEFAULTPARSER.parse(timestr, **kwargs)
+
+
+class _tzparser(object):
+
+    class _result(_resultbase):
+
+        __slots__ = ["stdabbr", "stdoffset", "dstabbr", "dstoffset",
+                     "start", "end"]
+
+        class _attr(_resultbase):
+            __slots__ = ["month", "week", "weekday",
+                         "yday", "jyday", "day", "time"]
+
+        def __repr__(self):
+            return self._repr("")
+
+        def __init__(self):
+            _resultbase.__init__(self)
+            self.start = self._attr()
+            self.end = self._attr()
+
+    def parse(self, tzstr):
+        res = self._result()
+        l = [x for x in re.split(r'([,:.]|[a-zA-Z]+|[0-9]+)',tzstr) if x]
+        used_idxs = list()
+        try:
+
+            len_l = len(l)
+
+            i = 0
+            while i < len_l:
+                # BRST+3[BRDT[+2]]
+                j = i
+                while j < len_l and not [x for x in l[j]
+                                         if x in "0123456789:,-+"]:
+                    j += 1
+                if j != i:
+                    if not res.stdabbr:
+                        offattr = "stdoffset"
+                        res.stdabbr = "".join(l[i:j])
+                    else:
+                        offattr = "dstoffset"
+                        res.dstabbr = "".join(l[i:j])
+
+                    for ii in range(j):
+                        used_idxs.append(ii)
+                    i = j
+                    if (i < len_l and (l[i] in ('+', '-') or l[i][0] in
+                                       "0123456789")):
+                        if l[i] in ('+', '-'):
+                            # Yes, that's right.  See the TZ variable
+                            # documentation.
+                            signal = (1, -1)[l[i] == '+']
+                            used_idxs.append(i)
+                            i += 1
+                        else:
+                            signal = -1
+                        len_li = len(l[i])
+                        if len_li == 4:
+                            # -0300
+                            setattr(res, offattr, (int(l[i][:2]) * 3600 +
+                                                   int(l[i][2:]) * 60) * signal)
+                        elif i + 1 < len_l and l[i + 1] == ':':
+                            # -03:00
+                            setattr(res, offattr,
+                                    (int(l[i]) * 3600 +
+                                     int(l[i + 2]) * 60) * signal)
+                            used_idxs.append(i)
+                            i += 2
+                        elif len_li <= 2:
+                            # -[0]3
+                            setattr(res, offattr,
+                                    int(l[i][:2]) * 3600 * signal)
+                        else:
+                            return None
+                        used_idxs.append(i)
+                        i += 1
+                    if res.dstabbr:
+                        break
+                else:
+                    break
+
+
+            if i < len_l:
+                for j in range(i, len_l):
+                    if l[j] == ';':
+                        l[j] = ','
+
+                assert l[i] == ','
+
+                i += 1
+
+            if i >= len_l:
+                pass
+            elif (8 <= l.count(',') <= 9 and
+                  not [y for x in l[i:] if x != ','
+                       for y in x if y not in "0123456789+-"]):
+                # GMT0BST,3,0,30,3600,10,0,26,7200[,3600]
+                for x in (res.start, res.end):
+                    x.month = int(l[i])
+                    used_idxs.append(i)
+                    i += 2
+                    if l[i] == '-':
+                        value = int(l[i + 1]) * -1
+                        used_idxs.append(i)
+                        i += 1
+                    else:
+                        value = int(l[i])
+                    used_idxs.append(i)
+                    i += 2
+                    if value:
+                        x.week = value
+                        x.weekday = (int(l[i]) - 1) % 7
+                    else:
+                        x.day = int(l[i])
+                    used_idxs.append(i)
+                    i += 2
+                    x.time = int(l[i])
+                    used_idxs.append(i)
+                    i += 2
+                if i < len_l:
+                    if l[i] in ('-', '+'):
+                        signal = (-1, 1)[l[i] == "+"]
+                        used_idxs.append(i)
+                        i += 1
+                    else:
+                        signal = 1
+                    used_idxs.append(i)
+                    res.dstoffset = (res.stdoffset + int(l[i]) * signal)
+
+                # This was a made-up format that is not in normal use
+                warn(('Parsed time zone "%s"' % tzstr) +
+                     'is in a non-standard dateutil-specific format, which ' +
+                     'is now deprecated; support for parsing this format ' +
+                     'will be removed in future versions. It is recommended ' +
+                     'that you switch to a standard format like the GNU ' +
+                     'TZ variable format.', tz.DeprecatedTzFormatWarning)
+            elif (l.count(',') == 2 and l[i:].count('/') <= 2 and
+                  not [y for x in l[i:] if x not in (',', '/', 'J', 'M',
+                                                     '.', '-', ':')
+                       for y in x if y not in "0123456789"]):
+                for x in (res.start, res.end):
+                    if l[i] == 'J':
+                        # non-leap year day (1 based)
+                        used_idxs.append(i)
+                        i += 1
+                        x.jyday = int(l[i])
+                    elif l[i] == 'M':
+                        # month[-.]week[-.]weekday
+                        used_idxs.append(i)
+                        i += 1
+                        x.month = int(l[i])
+                        used_idxs.append(i)
+                        i += 1
+                        assert l[i] in ('-', '.')
+                        used_idxs.append(i)
+                        i += 1
+                        x.week = int(l[i])
+                        if x.week == 5:
+                            x.week = -1
+                        used_idxs.append(i)
+                        i += 1
+                        assert l[i] in ('-', '.')
+                        used_idxs.append(i)
+                        i += 1
+                        x.weekday = (int(l[i]) - 1) % 7
+                    else:
+                        # year day (zero based)
+                        x.yday = int(l[i]) + 1
+
+                    used_idxs.append(i)
+                    i += 1
+
+                    if i < len_l and l[i] == '/':
+                        used_idxs.append(i)
+                        i += 1
+                        # start time
+                        len_li = len(l[i])
+                        if len_li == 4:
+                            # -0300
+                            x.time = (int(l[i][:2]) * 3600 +
+                                      int(l[i][2:]) * 60)
+                        elif i + 1 < len_l and l[i + 1] == ':':
+                            # -03:00
+                            x.time = int(l[i]) * 3600 + int(l[i + 2]) * 60
+                            used_idxs.append(i)
+                            i += 2
+                            if i + 1 < len_l and l[i + 1] == ':':
+                                used_idxs.append(i)
+                                i += 2
+                                x.time += int(l[i])
+                        elif len_li <= 2:
+                            # -[0]3
+                            x.time = (int(l[i][:2]) * 3600)
+                        else:
+                            return None
+                        used_idxs.append(i)
+                        i += 1
+
+                    assert i == len_l or l[i] == ','
+
+                    i += 1
+
+                assert i >= len_l
+
+        except (IndexError, ValueError, AssertionError):
+            return None
+
+        unused_idxs = set(range(len_l)).difference(used_idxs)
+        res.any_unused_tokens = not {l[n] for n in unused_idxs}.issubset({",",":"})
+        return res
+
+
+DEFAULTTZPARSER = _tzparser()
+
+
+def _parsetz(tzstr):
+    return DEFAULTTZPARSER.parse(tzstr)
+
+
+class ParserError(ValueError):
+    """Exception subclass used for any failure to parse a datetime string.
+
+    This is a subclass of :py:exc:`ValueError`, and should be raised any time
+    earlier versions of ``dateutil`` would have raised ``ValueError``.
+
+    .. versionadded:: 2.8.1
+    """
+    def __str__(self):
+        try:
+            return self.args[0] % self.args[1:]
+        except (TypeError, IndexError):
+            return super(ParserError, self).__str__()
+
+    def __repr__(self):
+        args = ", ".join("'%s'" % arg for arg in self.args)
+        return "%s(%s)" % (self.__class__.__name__, args)
+
+
+class UnknownTimezoneWarning(RuntimeWarning):
+    """Raised when the parser finds a timezone it cannot parse into a tzinfo.
+
+    .. versionadded:: 2.7.0
+    """
+# vim:ts=4:sw=4:et
diff --git a/dateutil/parser/isoparser.py b/dateutil/parser/isoparser.py
new file mode 100644
index 0000000..5d7bee3
--- /dev/null
+++ b/dateutil/parser/isoparser.py
@@ -0,0 +1,416 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers a parser for ISO-8601 strings
+
+It is intended to support all valid date, time and datetime formats per the
+ISO-8601 specification.
+
+..versionadded:: 2.7.0
+"""
+from datetime import datetime, timedelta, time, date
+import calendar
+from dateutil import tz
+
+from functools import wraps
+
+import re
+import six
+
+__all__ = ["isoparse", "isoparser"]
+
+
+def _takes_ascii(f):
+    @wraps(f)
+    def func(self, str_in, *args, **kwargs):
+        # If it's a stream, read the whole thing
+        str_in = getattr(str_in, 'read', lambda: str_in)()
+
+        # If it's unicode, turn it into bytes, since ISO-8601 only covers ASCII
+        if isinstance(str_in, six.text_type):
+            # ASCII is the same in UTF-8
+            try:
+                str_in = str_in.encode('ascii')
+            except UnicodeEncodeError as e:
+                msg = 'ISO-8601 strings should contain only ASCII characters'
+                six.raise_from(ValueError(msg), e)
+
+        return f(self, str_in, *args, **kwargs)
+
+    return func
+
+
+class isoparser(object):
+    def __init__(self, sep=None):
+        """
+        :param sep:
+            A single character that separates date and time portions. If
+            ``None``, the parser will accept any single character.
+            For strict ISO-8601 adherence, pass ``'T'``.
+        """
+        if sep is not None:
+            if (len(sep) != 1 or ord(sep) >= 128 or sep in '0123456789'):
+                raise ValueError('Separator must be a single, non-numeric ' +
+                                 'ASCII character')
+
+            sep = sep.encode('ascii')
+
+        self._sep = sep
+
+    @_takes_ascii
+    def isoparse(self, dt_str):
+        """
+        Parse an ISO-8601 datetime string into a :class:`datetime.datetime`.
+
+        An ISO-8601 datetime string consists of a date portion, followed
+        optionally by a time portion - the date and time portions are separated
+        by a single character separator, which is ``T`` in the official
+        standard. Incomplete date formats (such as ``YYYY-MM``) may *not* be
+        combined with a time portion.
+
+        Supported date formats are:
+
+        Common:
+
+        - ``YYYY``
+        - ``YYYY-MM`` or ``YYYYMM``
+        - ``YYYY-MM-DD`` or ``YYYYMMDD``
+
+        Uncommon:
+
+        - ``YYYY-Www`` or ``YYYYWww`` - ISO week (day defaults to 0)
+        - ``YYYY-Www-D`` or ``YYYYWwwD`` - ISO week and day
+
+        The ISO week and day numbering follows the same logic as
+        :func:`datetime.date.isocalendar`.
+
+        Supported time formats are:
+
+        - ``hh``
+        - ``hh:mm`` or ``hhmm``
+        - ``hh:mm:ss`` or ``hhmmss``
+        - ``hh:mm:ss.ssssss`` (Up to 6 sub-second digits)
+
+        Midnight is a special case for `hh`, as the standard supports both
+        00:00 and 24:00 as a representation. The decimal separator can be
+        either a dot or a comma.
+
+
+        .. caution::
+
+            Support for fractional components other than seconds is part of the
+            ISO-8601 standard, but is not currently implemented in this parser.
+
+        Supported time zone offset formats are:
+
+        - `Z` (UTC)
+        - `±HH:MM`
+        - `±HHMM`
+        - `±HH`
+
+        Offsets will be represented as :class:`dateutil.tz.tzoffset` objects,
+        with the exception of UTC, which will be represented as
+        :class:`dateutil.tz.tzutc`. Time zone offsets equivalent to UTC (such
+        as `+00:00`) will also be represented as :class:`dateutil.tz.tzutc`.
+
+        :param dt_str:
+            A string or stream containing only an ISO-8601 datetime string
+
+        :return:
+            Returns a :class:`datetime.datetime` representing the string.
+            Unspecified components default to their lowest value.
+
+        .. warning::
+
+            As of version 2.7.0, the strictness of the parser should not be
+            considered a stable part of the contract. Any valid ISO-8601 string
+            that parses correctly with the default settings will continue to
+            parse correctly in future versions, but invalid strings that
+            currently fail (e.g. ``2017-01-01T00:00+00:00:00``) are not
+            guaranteed to continue failing in future versions if they encode
+            a valid date.
+
+        .. versionadded:: 2.7.0
+        """
+        components, pos = self._parse_isodate(dt_str)
+
+        if len(dt_str) > pos:
+            if self._sep is None or dt_str[pos:pos + 1] == self._sep:
+                components += self._parse_isotime(dt_str[pos + 1:])
+            else:
+                raise ValueError('String contains unknown ISO components')
+
+        if len(components) > 3 and components[3] == 24:
+            components[3] = 0
+            return datetime(*components) + timedelta(days=1)
+
+        return datetime(*components)
+
+    @_takes_ascii
+    def parse_isodate(self, datestr):
+        """
+        Parse the date portion of an ISO string.
+
+        :param datestr:
+            The string portion of an ISO string, without a separator
+
+        :return:
+            Returns a :class:`datetime.date` object
+        """
+        components, pos = self._parse_isodate(datestr)
+        if pos < len(datestr):
+            raise ValueError('String contains unknown ISO ' +
+                             'components: {!r}'.format(datestr.decode('ascii')))
+        return date(*components)
+
+    @_takes_ascii
+    def parse_isotime(self, timestr):
+        """
+        Parse the time portion of an ISO string.
+
+        :param timestr:
+            The time portion of an ISO string, without a separator
+
+        :return:
+            Returns a :class:`datetime.time` object
+        """
+        components = self._parse_isotime(timestr)
+        if components[0] == 24:
+            components[0] = 0
+        return time(*components)
+
+    @_takes_ascii
+    def parse_tzstr(self, tzstr, zero_as_utc=True):
+        """
+        Parse a valid ISO time zone string.
+
+        See :func:`isoparser.isoparse` for details on supported formats.
+
+        :param tzstr:
+            A string representing an ISO time zone offset
+
+        :param zero_as_utc:
+            Whether to return :class:`dateutil.tz.tzutc` for zero-offset zones
+
+        :return:
+            Returns :class:`dateutil.tz.tzoffset` for offsets and
+            :class:`dateutil.tz.tzutc` for ``Z`` and (if ``zero_as_utc`` is
+            specified) offsets equivalent to UTC.
+        """
+        return self._parse_tzstr(tzstr, zero_as_utc=zero_as_utc)
+
+    # Constants
+    _DATE_SEP = b'-'
+    _TIME_SEP = b':'
+    _FRACTION_REGEX = re.compile(b'[\\.,]([0-9]+)')
+
+    def _parse_isodate(self, dt_str):
+        try:
+            return self._parse_isodate_common(dt_str)
+        except ValueError:
+            return self._parse_isodate_uncommon(dt_str)
+
+    def _parse_isodate_common(self, dt_str):
+        len_str = len(dt_str)
+        components = [1, 1, 1]
+
+        if len_str < 4:
+            raise ValueError('ISO string too short')
+
+        # Year
+        components[0] = int(dt_str[0:4])
+        pos = 4
+        if pos >= len_str:
+            return components, pos
+
+        has_sep = dt_str[pos:pos + 1] == self._DATE_SEP
+        if has_sep:
+            pos += 1
+
+        # Month
+        if len_str - pos < 2:
+            raise ValueError('Invalid common month')
+
+        components[1] = int(dt_str[pos:pos + 2])
+        pos += 2
+
+        if pos >= len_str:
+            if has_sep:
+                return components, pos
+            else:
+                raise ValueError('Invalid ISO format')
+
+        if has_sep:
+            if dt_str[pos:pos + 1] != self._DATE_SEP:
+                raise ValueError('Invalid separator in ISO string')
+            pos += 1
+
+        # Day
+        if len_str - pos < 2:
+            raise ValueError('Invalid common day')
+        components[2] = int(dt_str[pos:pos + 2])
+        return components, pos + 2
+
+    def _parse_isodate_uncommon(self, dt_str):
+        if len(dt_str) < 4:
+            raise ValueError('ISO string too short')
+
+        # All ISO formats start with the year
+        year = int(dt_str[0:4])
+
+        has_sep = dt_str[4:5] == self._DATE_SEP
+
+        pos = 4 + has_sep       # Skip '-' if it's there
+        if dt_str[pos:pos + 1] == b'W':
+            # YYYY-?Www-?D?
+            pos += 1
+            weekno = int(dt_str[pos:pos + 2])
+            pos += 2
+
+            dayno = 1
+            if len(dt_str) > pos:
+                if (dt_str[pos:pos + 1] == self._DATE_SEP) != has_sep:
+                    raise ValueError('Inconsistent use of dash separator')
+
+                pos += has_sep
+
+                dayno = int(dt_str[pos:pos + 1])
+                pos += 1
+
+            base_date = self._calculate_weekdate(year, weekno, dayno)
+        else:
+            # YYYYDDD or YYYY-DDD
+            if len(dt_str) - pos < 3:
+                raise ValueError('Invalid ordinal day')
+
+            ordinal_day = int(dt_str[pos:pos + 3])
+            pos += 3
+
+            if ordinal_day < 1 or ordinal_day > (365 + calendar.isleap(year)):
+                raise ValueError('Invalid ordinal day' +
+                                 ' {} for year {}'.format(ordinal_day, year))
+
+            base_date = date(year, 1, 1) + timedelta(days=ordinal_day - 1)
+
+        components = [base_date.year, base_date.month, base_date.day]
+        return components, pos
+
+    def _calculate_weekdate(self, year, week, day):
+        """
+        Calculate the day of corresponding to the ISO year-week-day calendar.
+
+        This function is effectively the inverse of
+        :func:`datetime.date.isocalendar`.
+
+        :param year:
+            The year in the ISO calendar
+
+        :param week:
+            The week in the ISO calendar - range is [1, 53]
+
+        :param day:
+            The day in the ISO calendar - range is [1 (MON), 7 (SUN)]
+
+        :return:
+            Returns a :class:`datetime.date`
+        """
+        if not 0 < week < 54:
+            raise ValueError('Invalid week: {}'.format(week))
+
+        if not 0 < day < 8:     # Range is 1-7
+            raise ValueError('Invalid weekday: {}'.format(day))
+
+        # Get week 1 for the specific year:
+        jan_4 = date(year, 1, 4)   # Week 1 always has January 4th in it
+        week_1 = jan_4 - timedelta(days=jan_4.isocalendar()[2] - 1)
+
+        # Now add the specific number of weeks and days to get what we want
+        week_offset = (week - 1) * 7 + (day - 1)
+        return week_1 + timedelta(days=week_offset)
+
+    def _parse_isotime(self, timestr):
+        len_str = len(timestr)
+        components = [0, 0, 0, 0, None]
+        pos = 0
+        comp = -1
+
+        if len_str < 2:
+            raise ValueError('ISO time too short')
+
+        has_sep = False
+
+        while pos < len_str and comp < 5:
+            comp += 1
+
+            if timestr[pos:pos + 1] in b'-+Zz':
+                # Detect time zone boundary
+                components[-1] = self._parse_tzstr(timestr[pos:])
+                pos = len_str
+                break
+
+            if comp == 1 and timestr[pos:pos+1] == self._TIME_SEP:
+                has_sep = True
+                pos += 1
+            elif comp == 2 and has_sep:
+                if timestr[pos:pos+1] != self._TIME_SEP:
+                    raise ValueError('Inconsistent use of colon separator')
+                pos += 1
+
+            if comp < 3:
+                # Hour, minute, second
+                components[comp] = int(timestr[pos:pos + 2])
+                pos += 2
+
+            if comp == 3:
+                # Fraction of a second
+                frac = self._FRACTION_REGEX.match(timestr[pos:])
+                if not frac:
+                    continue
+
+                us_str = frac.group(1)[:6]  # Truncate to microseconds
+                components[comp] = int(us_str) * 10**(6 - len(us_str))
+                pos += len(frac.group())
+
+        if pos < len_str:
+            raise ValueError('Unused components in ISO string')
+
+        if components[0] == 24:
+            # Standard supports 00:00 and 24:00 as representations of midnight
+            if any(component != 0 for component in components[1:4]):
+                raise ValueError('Hour may only be 24 at 24:00:00.000')
+
+        return components
+
+    def _parse_tzstr(self, tzstr, zero_as_utc=True):
+        if tzstr == b'Z' or tzstr == b'z':
+            return tz.UTC
+
+        if len(tzstr) not in {3, 5, 6}:
+            raise ValueError('Time zone offset must be 1, 3, 5 or 6 characters')
+
+        if tzstr[0:1] == b'-':
+            mult = -1
+        elif tzstr[0:1] == b'+':
+            mult = 1
+        else:
+            raise ValueError('Time zone offset requires sign')
+
+        hours = int(tzstr[1:3])
+        if len(tzstr) == 3:
+            minutes = 0
+        else:
+            minutes = int(tzstr[(4 if tzstr[3:4] == self._TIME_SEP else 3):])
+
+        if zero_as_utc and hours == 0 and minutes == 0:
+            return tz.UTC
+        else:
+            if minutes > 59:
+                raise ValueError('Invalid minutes in time zone offset')
+
+            if hours > 23:
+                raise ValueError('Invalid hours in time zone offset')
+
+            return tz.tzoffset(None, mult * (hours * 60 + minutes) * 60)
+
+
+DEFAULT_ISOPARSER = isoparser()
+isoparse = DEFAULT_ISOPARSER.isoparse
diff --git a/dateutil/relativedelta.py b/dateutil/relativedelta.py
new file mode 100644
index 0000000..a9e85f7
--- /dev/null
+++ b/dateutil/relativedelta.py
@@ -0,0 +1,599 @@
+# -*- coding: utf-8 -*-
+import datetime
+import calendar
+
+import operator
+from math import copysign
+
+from six import integer_types
+from warnings import warn
+
+from ._common import weekday
+
+MO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))
+
+__all__ = ["relativedelta", "MO", "TU", "WE", "TH", "FR", "SA", "SU"]
+
+
+class relativedelta(object):
+    """
+    The relativedelta type is designed to be applied to an existing datetime and
+    can replace specific components of that datetime, or represents an interval
+    of time.
+
+    It is based on the specification of the excellent work done by M.-A. Lemburg
+    in his
+    `mx.DateTime <https://www.egenix.com/products/python/mxBase/mxDateTime/>`_ extension.
+    However, notice that this type does *NOT* implement the same algorithm as
+    his work. Do *NOT* expect it to behave like mx.DateTime's counterpart.
+
+    There are two different ways to build a relativedelta instance. The
+    first one is passing it two date/datetime classes::
+
+        relativedelta(datetime1, datetime2)
+
+    The second one is passing it any number of the following keyword arguments::
+
+        relativedelta(arg1=x,arg2=y,arg3=z...)
+
+        year, month, day, hour, minute, second, microsecond:
+            Absolute information (argument is singular); adding or subtracting a
+            relativedelta with absolute information does not perform an arithmetic
+            operation, but rather REPLACES the corresponding value in the
+            original datetime with the value(s) in relativedelta.
+
+        years, months, weeks, days, hours, minutes, seconds, microseconds:
+            Relative information, may be negative (argument is plural); adding
+            or subtracting a relativedelta with relative information performs
+            the corresponding arithmetic operation on the original datetime value
+            with the information in the relativedelta.
+
+        weekday: 
+            One of the weekday instances (MO, TU, etc) available in the
+            relativedelta module. These instances may receive a parameter N,
+            specifying the Nth weekday, which could be positive or negative
+            (like MO(+1) or MO(-2)). Not specifying it is the same as specifying
+            +1. You can also use an integer, where 0=MO. This argument is always
+            relative e.g. if the calculated date is already Monday, using MO(1)
+            or MO(-1) won't change the day. To effectively make it absolute, use
+            it in combination with the day argument (e.g. day=1, MO(1) for first
+            Monday of the month).
+
+        leapdays:
+            Will add given days to the date found, if year is a leap
+            year, and the date found is post 28 of february.
+
+        yearday, nlyearday:
+            Set the yearday or the non-leap year day (jump leap days).
+            These are converted to day/month/leapdays information.
+
+    There are relative and absolute forms of the keyword
+    arguments. The plural is relative, and the singular is
+    absolute. For each argument in the order below, the absolute form
+    is applied first (by setting each attribute to that value) and
+    then the relative form (by adding the value to the attribute).
+
+    The order of attributes considered when this relativedelta is
+    added to a datetime is:
+
+    1. Year
+    2. Month
+    3. Day
+    4. Hours
+    5. Minutes
+    6. Seconds
+    7. Microseconds
+
+    Finally, weekday is applied, using the rule described above.
+
+    For example
+
+    >>> from datetime import datetime
+    >>> from dateutil.relativedelta import relativedelta, MO
+    >>> dt = datetime(2018, 4, 9, 13, 37, 0)
+    >>> delta = relativedelta(hours=25, day=1, weekday=MO(1))
+    >>> dt + delta
+    datetime.datetime(2018, 4, 2, 14, 37)
+
+    First, the day is set to 1 (the first of the month), then 25 hours
+    are added, to get to the 2nd day and 14th hour, finally the
+    weekday is applied, but since the 2nd is already a Monday there is
+    no effect.
+
+    """
+
+    def __init__(self, dt1=None, dt2=None,
+                 years=0, months=0, days=0, leapdays=0, weeks=0,
+                 hours=0, minutes=0, seconds=0, microseconds=0,
+                 year=None, month=None, day=None, weekday=None,
+                 yearday=None, nlyearday=None,
+                 hour=None, minute=None, second=None, microsecond=None):
+
+        if dt1 and dt2:
+            # datetime is a subclass of date. So both must be date
+            if not (isinstance(dt1, datetime.date) and
+                    isinstance(dt2, datetime.date)):
+                raise TypeError("relativedelta only diffs datetime/date")
+
+            # We allow two dates, or two datetimes, so we coerce them to be
+            # of the same type
+            if (isinstance(dt1, datetime.datetime) !=
+                    isinstance(dt2, datetime.datetime)):
+                if not isinstance(dt1, datetime.datetime):
+                    dt1 = datetime.datetime.fromordinal(dt1.toordinal())
+                elif not isinstance(dt2, datetime.datetime):
+                    dt2 = datetime.datetime.fromordinal(dt2.toordinal())
+
+            self.years = 0
+            self.months = 0
+            self.days = 0
+            self.leapdays = 0
+            self.hours = 0
+            self.minutes = 0
+            self.seconds = 0
+            self.microseconds = 0
+            self.year = None
+            self.month = None
+            self.day = None
+            self.weekday = None
+            self.hour = None
+            self.minute = None
+            self.second = None
+            self.microsecond = None
+            self._has_time = 0
+
+            # Get year / month delta between the two
+            months = (dt1.year - dt2.year) * 12 + (dt1.month - dt2.month)
+            self._set_months(months)
+
+            # Remove the year/month delta so the timedelta is just well-defined
+            # time units (seconds, days and microseconds)
+            dtm = self.__radd__(dt2)
+
+            # If we've overshot our target, make an adjustment
+            if dt1 < dt2:
+                compare = operator.gt
+                increment = 1
+            else:
+                compare = operator.lt
+                increment = -1
+
+            while compare(dt1, dtm):
+                months += increment
+                self._set_months(months)
+                dtm = self.__radd__(dt2)
+
+            # Get the timedelta between the "months-adjusted" date and dt1
+            delta = dt1 - dtm
+            self.seconds = delta.seconds + delta.days * 86400
+            self.microseconds = delta.microseconds
+        else:
+            # Check for non-integer values in integer-only quantities
+            if any(x is not None and x != int(x) for x in (years, months)):
+                raise ValueError("Non-integer years and months are "
+                                 "ambiguous and not currently supported.")
+
+            # Relative information
+            self.years = int(years)
+            self.months = int(months)
+            self.days = days + weeks * 7
+            self.leapdays = leapdays
+            self.hours = hours
+            self.minutes = minutes
+            self.seconds = seconds
+            self.microseconds = microseconds
+
+            # Absolute information
+            self.year = year
+            self.month = month
+            self.day = day
+            self.hour = hour
+            self.minute = minute
+            self.second = second
+            self.microsecond = microsecond
+
+            if any(x is not None and int(x) != x
+                   for x in (year, month, day, hour,
+                             minute, second, microsecond)):
+                # For now we'll deprecate floats - later it'll be an error.
+                warn("Non-integer value passed as absolute information. " +
+                     "This is not a well-defined condition and will raise " +
+                     "errors in future versions.", DeprecationWarning)
+
+            if isinstance(weekday, integer_types):
+                self.weekday = weekdays[weekday]
+            else:
+                self.weekday = weekday
+
+            yday = 0
+            if nlyearday:
+                yday = nlyearday
+            elif yearday:
+                yday = yearday
+                if yearday > 59:
+                    self.leapdays = -1
+            if yday:
+                ydayidx = [31, 59, 90, 120, 151, 181, 212,
+                           243, 273, 304, 334, 366]
+                for idx, ydays in enumerate(ydayidx):
+                    if yday <= ydays:
+                        self.month = idx+1
+                        if idx == 0:
+                            self.day = yday
+                        else:
+                            self.day = yday-ydayidx[idx-1]
+                        break
+                else:
+                    raise ValueError("invalid year day (%d)" % yday)
+
+        self._fix()
+
+    def _fix(self):
+        if abs(self.microseconds) > 999999:
+            s = _sign(self.microseconds)
+            div, mod = divmod(self.microseconds * s, 1000000)
+            self.microseconds = mod * s
+            self.seconds += div * s
+        if abs(self.seconds) > 59:
+            s = _sign(self.seconds)
+            div, mod = divmod(self.seconds * s, 60)
+            self.seconds = mod * s
+            self.minutes += div * s
+        if abs(self.minutes) > 59:
+            s = _sign(self.minutes)
+            div, mod = divmod(self.minutes * s, 60)
+            self.minutes = mod * s
+            self.hours += div * s
+        if abs(self.hours) > 23:
+            s = _sign(self.hours)
+            div, mod = divmod(self.hours * s, 24)
+            self.hours = mod * s
+            self.days += div * s
+        if abs(self.months) > 11:
+            s = _sign(self.months)
+            div, mod = divmod(self.months * s, 12)
+            self.months = mod * s
+            self.years += div * s
+        if (self.hours or self.minutes or self.seconds or self.microseconds
+                or self.hour is not None or self.minute is not None or
+                self.second is not None or self.microsecond is not None):
+            self._has_time = 1
+        else:
+            self._has_time = 0
+
+    @property
+    def weeks(self):
+        return int(self.days / 7.0)
+
+    @weeks.setter
+    def weeks(self, value):
+        self.days = self.days - (self.weeks * 7) + value * 7
+
+    def _set_months(self, months):
+        self.months = months
+        if abs(self.months) > 11:
+            s = _sign(self.months)
+            div, mod = divmod(self.months * s, 12)
+            self.months = mod * s
+            self.years = div * s
+        else:
+            self.years = 0
+
+    def normalized(self):
+        """
+        Return a version of this object represented entirely using integer
+        values for the relative attributes.
+
+        >>> relativedelta(days=1.5, hours=2).normalized()
+        relativedelta(days=+1, hours=+14)
+
+        :return:
+            Returns a :class:`dateutil.relativedelta.relativedelta` object.
+        """
+        # Cascade remainders down (rounding each to roughly nearest microsecond)
+        days = int(self.days)
+
+        hours_f = round(self.hours + 24 * (self.days - days), 11)
+        hours = int(hours_f)
+
+        minutes_f = round(self.minutes + 60 * (hours_f - hours), 10)
+        minutes = int(minutes_f)
+
+        seconds_f = round(self.seconds + 60 * (minutes_f - minutes), 8)
+        seconds = int(seconds_f)
+
+        microseconds = round(self.microseconds + 1e6 * (seconds_f - seconds))
+
+        # Constructor carries overflow back up with call to _fix()
+        return self.__class__(years=self.years, months=self.months,
+                              days=days, hours=hours, minutes=minutes,
+                              seconds=seconds, microseconds=microseconds,
+                              leapdays=self.leapdays, year=self.year,
+                              month=self.month, day=self.day,
+                              weekday=self.weekday, hour=self.hour,
+                              minute=self.minute, second=self.second,
+                              microsecond=self.microsecond)
+
+    def __add__(self, other):
+        if isinstance(other, relativedelta):
+            return self.__class__(years=other.years + self.years,
+                                 months=other.months + self.months,
+                                 days=other.days + self.days,
+                                 hours=other.hours + self.hours,
+                                 minutes=other.minutes + self.minutes,
+                                 seconds=other.seconds + self.seconds,
+                                 microseconds=(other.microseconds +
+                                               self.microseconds),
+                                 leapdays=other.leapdays or self.leapdays,
+                                 year=(other.year if other.year is not None
+                                       else self.year),
+                                 month=(other.month if other.month is not None
+                                        else self.month),
+                                 day=(other.day if other.day is not None
+                                      else self.day),
+                                 weekday=(other.weekday if other.weekday is not None
+                                          else self.weekday),
+                                 hour=(other.hour if other.hour is not None
+                                       else self.hour),
+                                 minute=(other.minute if other.minute is not None
+                                         else self.minute),
+                                 second=(other.second if other.second is not None
+                                         else self.second),
+                                 microsecond=(other.microsecond if other.microsecond
+                                              is not None else
+                                              self.microsecond))
+        if isinstance(other, datetime.timedelta):
+            return self.__class__(years=self.years,
+                                  months=self.months,
+                                  days=self.days + other.days,
+                                  hours=self.hours,
+                                  minutes=self.minutes,
+                                  seconds=self.seconds + other.seconds,
+                                  microseconds=self.microseconds + other.microseconds,
+                                  leapdays=self.leapdays,
+                                  year=self.year,
+                                  month=self.month,
+                                  day=self.day,
+                                  weekday=self.weekday,
+                                  hour=self.hour,
+                                  minute=self.minute,
+                                  second=self.second,
+                                  microsecond=self.microsecond)
+        if not isinstance(other, datetime.date):
+            return NotImplemented
+        elif self._has_time and not isinstance(other, datetime.datetime):
+            other = datetime.datetime.fromordinal(other.toordinal())
+        year = (self.year or other.year)+self.years
+        month = self.month or other.month
+        if self.months:
+            assert 1 <= abs(self.months) <= 12
+            month += self.months
+            if month > 12:
+                year += 1
+                month -= 12
+            elif month < 1:
+                year -= 1
+                month += 12
+        day = min(calendar.monthrange(year, month)[1],
+                  self.day or other.day)
+        repl = {"year": year, "month": month, "day": day}
+        for attr in ["hour", "minute", "second", "microsecond"]:
+            value = getattr(self, attr)
+            if value is not None:
+                repl[attr] = value
+        days = self.days
+        if self.leapdays and month > 2 and calendar.isleap(year):
+            days += self.leapdays
+        ret = (other.replace(**repl)
+               + datetime.timedelta(days=days,
+                                    hours=self.hours,
+                                    minutes=self.minutes,
+                                    seconds=self.seconds,
+                                    microseconds=self.microseconds))
+        if self.weekday:
+            weekday, nth = self.weekday.weekday, self.weekday.n or 1
+            jumpdays = (abs(nth) - 1) * 7
+            if nth > 0:
+                jumpdays += (7 - ret.weekday() + weekday) % 7
+            else:
+                jumpdays += (ret.weekday() - weekday) % 7
+                jumpdays *= -1
+            ret += datetime.timedelta(days=jumpdays)
+        return ret
+
+    def __radd__(self, other):
+        return self.__add__(other)
+
+    def __rsub__(self, other):
+        return self.__neg__().__radd__(other)
+
+    def __sub__(self, other):
+        if not isinstance(other, relativedelta):
+            return NotImplemented   # In case the other object defines __rsub__
+        return self.__class__(years=self.years - other.years,
+                             months=self.months - other.months,
+                             days=self.days - other.days,
+                             hours=self.hours - other.hours,
+                             minutes=self.minutes - other.minutes,
+                             seconds=self.seconds - other.seconds,
+                             microseconds=self.microseconds - other.microseconds,
+                             leapdays=self.leapdays or other.leapdays,
+                             year=(self.year if self.year is not None
+                                   else other.year),
+                             month=(self.month if self.month is not None else
+                                    other.month),
+                             day=(self.day if self.day is not None else
+                                  other.day),
+                             weekday=(self.weekday if self.weekday is not None else
+                                      other.weekday),
+                             hour=(self.hour if self.hour is not None else
+                                   other.hour),
+                             minute=(self.minute if self.minute is not None else
+                                     other.minute),
+                             second=(self.second if self.second is not None else
+                                     other.second),
+                             microsecond=(self.microsecond if self.microsecond
+                                          is not None else
+                                          other.microsecond))
+
+    def __abs__(self):
+        return self.__class__(years=abs(self.years),
+                              months=abs(self.months),
+                              days=abs(self.days),
+                              hours=abs(self.hours),
+                              minutes=abs(self.minutes),
+                              seconds=abs(self.seconds),
+                              microseconds=abs(self.microseconds),
+                              leapdays=self.leapdays,
+                              year=self.year,
+                              month=self.month,
+                              day=self.day,
+                              weekday=self.weekday,
+                              hour=self.hour,
+                              minute=self.minute,
+                              second=self.second,
+                              microsecond=self.microsecond)
+
+    def __neg__(self):
+        return self.__class__(years=-self.years,
+                             months=-self.months,
+                             days=-self.days,
+                             hours=-self.hours,
+                             minutes=-self.minutes,
+                             seconds=-self.seconds,
+                             microseconds=-self.microseconds,
+                             leapdays=self.leapdays,
+                             year=self.year,
+                             month=self.month,
+                             day=self.day,
+                             weekday=self.weekday,
+                             hour=self.hour,
+                             minute=self.minute,
+                             second=self.second,
+                             microsecond=self.microsecond)
+
+    def __bool__(self):
+        return not (not self.years and
+                    not self.months and
+                    not self.days and
+                    not self.hours and
+                    not self.minutes and
+                    not self.seconds and
+                    not self.microseconds and
+                    not self.leapdays and
+                    self.year is None and
+                    self.month is None and
+                    self.day is None and
+                    self.weekday is None and
+                    self.hour is None and
+                    self.minute is None and
+                    self.second is None and
+                    self.microsecond is None)
+    # Compatibility with Python 2.x
+    __nonzero__ = __bool__
+
+    def __mul__(self, other):
+        try:
+            f = float(other)
+        except TypeError:
+            return NotImplemented
+
+        return self.__class__(years=int(self.years * f),
+                             months=int(self.months * f),
+                             days=int(self.days * f),
+                             hours=int(self.hours * f),
+                             minutes=int(self.minutes * f),
+                             seconds=int(self.seconds * f),
+                             microseconds=int(self.microseconds * f),
+                             leapdays=self.leapdays,
+                             year=self.year,
+                             month=self.month,
+                             day=self.day,
+                             weekday=self.weekday,
+                             hour=self.hour,
+                             minute=self.minute,
+                             second=self.second,
+                             microsecond=self.microsecond)
+
+    __rmul__ = __mul__
+
+    def __eq__(self, other):
+        if not isinstance(other, relativedelta):
+            return NotImplemented
+        if self.weekday or other.weekday:
+            if not self.weekday or not other.weekday:
+                return False
+            if self.weekday.weekday != other.weekday.weekday:
+                return False
+            n1, n2 = self.weekday.n, other.weekday.n
+            if n1 != n2 and not ((not n1 or n1 == 1) and (not n2 or n2 == 1)):
+                return False
+        return (self.years == other.years and
+                self.months == other.months and
+                self.days == other.days and
+                self.hours == other.hours and
+                self.minutes == other.minutes and
+                self.seconds == other.seconds and
+                self.microseconds == other.microseconds and
+                self.leapdays == other.leapdays and
+                self.year == other.year and
+                self.month == other.month and
+                self.day == other.day and
+                self.hour == other.hour and
+                self.minute == other.minute and
+                self.second == other.second and
+                self.microsecond == other.microsecond)
+
+    def __hash__(self):
+        return hash((
+            self.weekday,
+            self.years,
+            self.months,
+            self.days,
+            self.hours,
+            self.minutes,
+            self.seconds,
+            self.microseconds,
+            self.leapdays,
+            self.year,
+            self.month,
+            self.day,
+            self.hour,
+            self.minute,
+            self.second,
+            self.microsecond,
+        ))
+
+    def __ne__(self, other):
+        return not self.__eq__(other)
+
+    def __div__(self, other):
+        try:
+            reciprocal = 1 / float(other)
+        except TypeError:
+            return NotImplemented
+
+        return self.__mul__(reciprocal)
+
+    __truediv__ = __div__
+
+    def __repr__(self):
+        l = []
+        for attr in ["years", "months", "days", "leapdays",
+                     "hours", "minutes", "seconds", "microseconds"]:
+            value = getattr(self, attr)
+            if value:
+                l.append("{attr}={value:+g}".format(attr=attr, value=value))
+        for attr in ["year", "month", "day", "weekday",
+                     "hour", "minute", "second", "microsecond"]:
+            value = getattr(self, attr)
+            if value is not None:
+                l.append("{attr}={value}".format(attr=attr, value=repr(value)))
+        return "{classname}({attrs})".format(classname=self.__class__.__name__,
+                                             attrs=", ".join(l))
+
+
+def _sign(x):
+    return int(copysign(1, x))
+
+# vim:ts=4:sw=4:et
diff --git a/dateutil/rrule.py b/dateutil/rrule.py
new file mode 100644
index 0000000..b320339
--- /dev/null
+++ b/dateutil/rrule.py
@@ -0,0 +1,1737 @@
+# -*- coding: utf-8 -*-
+"""
+The rrule module offers a small, complete, and very fast, implementation of
+the recurrence rules documented in the
+`iCalendar RFC <https://tools.ietf.org/html/rfc5545>`_,
+including support for caching of results.
+"""
+import calendar
+import datetime
+import heapq
+import itertools
+import re
+import sys
+from functools import wraps
+# For warning about deprecation of until and count
+from warnings import warn
+
+from six import advance_iterator, integer_types
+
+from six.moves import _thread, range
+
+from ._common import weekday as weekdaybase
+
+try:
+    from math import gcd
+except ImportError:
+    from fractions import gcd
+
+__all__ = ["rrule", "rruleset", "rrulestr",
+           "YEARLY", "MONTHLY", "WEEKLY", "DAILY",
+           "HOURLY", "MINUTELY", "SECONDLY",
+           "MO", "TU", "WE", "TH", "FR", "SA", "SU"]
+
+# Every mask is 7 days longer to handle cross-year weekly periods.
+M366MASK = tuple([1]*31+[2]*29+[3]*31+[4]*30+[5]*31+[6]*30 +
+                 [7]*31+[8]*31+[9]*30+[10]*31+[11]*30+[12]*31+[1]*7)
+M365MASK = list(M366MASK)
+M29, M30, M31 = list(range(1, 30)), list(range(1, 31)), list(range(1, 32))
+MDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
+MDAY365MASK = list(MDAY366MASK)
+M29, M30, M31 = list(range(-29, 0)), list(range(-30, 0)), list(range(-31, 0))
+NMDAY366MASK = tuple(M31+M29+M31+M30+M31+M30+M31+M31+M30+M31+M30+M31+M31[:7])
+NMDAY365MASK = list(NMDAY366MASK)
+M366RANGE = (0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366)
+M365RANGE = (0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365)
+WDAYMASK = [0, 1, 2, 3, 4, 5, 6]*55
+del M29, M30, M31, M365MASK[59], MDAY365MASK[59], NMDAY365MASK[31]
+MDAY365MASK = tuple(MDAY365MASK)
+M365MASK = tuple(M365MASK)
+
+FREQNAMES = ['YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY', 'HOURLY', 'MINUTELY', 'SECONDLY']
+
+(YEARLY,
+ MONTHLY,
+ WEEKLY,
+ DAILY,
+ HOURLY,
+ MINUTELY,
+ SECONDLY) = list(range(7))
+
+# Imported on demand.
+easter = None
+parser = None
+
+
+class weekday(weekdaybase):
+    """
+    This version of weekday does not allow n = 0.
+    """
+    def __init__(self, wkday, n=None):
+        if n == 0:
+            raise ValueError("Can't create weekday with n==0")
+
+        super(weekday, self).__init__(wkday, n)
+
+
+MO, TU, WE, TH, FR, SA, SU = weekdays = tuple(weekday(x) for x in range(7))
+
+
+def _invalidates_cache(f):
+    """
+    Decorator for rruleset methods which may invalidate the
+    cached length.
+    """
+    @wraps(f)
+    def inner_func(self, *args, **kwargs):
+        rv = f(self, *args, **kwargs)
+        self._invalidate_cache()
+        return rv
+
+    return inner_func
+
+
+class rrulebase(object):
+    def __init__(self, cache=False):
+        if cache:
+            self._cache = []
+            self._cache_lock = _thread.allocate_lock()
+            self._invalidate_cache()
+        else:
+            self._cache = None
+            self._cache_complete = False
+            self._len = None
+
+    def __iter__(self):
+        if self._cache_complete:
+            return iter(self._cache)
+        elif self._cache is None:
+            return self._iter()
+        else:
+            return self._iter_cached()
+
+    def _invalidate_cache(self):
+        if self._cache is not None:
+            self._cache = []
+            self._cache_complete = False
+            self._cache_gen = self._iter()
+
+            if self._cache_lock.locked():
+                self._cache_lock.release()
+
+        self._len = None
+
+    def _iter_cached(self):
+        i = 0
+        gen = self._cache_gen
+        cache = self._cache
+        acquire = self._cache_lock.acquire
+        release = self._cache_lock.release
+        while gen:
+            if i == len(cache):
+                acquire()
+                if self._cache_complete:
+                    break
+                try:
+                    for j in range(10):
+                        cache.append(advance_iterator(gen))
+                except StopIteration:
+                    self._cache_gen = gen = None
+                    self._cache_complete = True
+                    break
+                release()
+            yield cache[i]
+            i += 1
+        while i < self._len:
+            yield cache[i]
+            i += 1
+
+    def __getitem__(self, item):
+        if self._cache_complete:
+            return self._cache[item]
+        elif isinstance(item, slice):
+            if item.step and item.step < 0:
+                return list(iter(self))[item]
+            else:
+                return list(itertools.islice(self,
+                                             item.start or 0,
+                                             item.stop or sys.maxsize,
+                                             item.step or 1))
+        elif item >= 0:
+            gen = iter(self)
+            try:
+                for i in range(item+1):
+                    res = advance_iterator(gen)
+            except StopIteration:
+                raise IndexError
+            return res
+        else:
+            return list(iter(self))[item]
+
+    def __contains__(self, item):
+        if self._cache_complete:
+            return item in self._cache
+        else:
+            for i in self:
+                if i == item:
+                    return True
+                elif i > item:
+                    return False
+        return False
+
+    # __len__() introduces a large performance penalty.
+    def count(self):
+        """ Returns the number of recurrences in this set. It will have go
+            trough the whole recurrence, if this hasn't been done before. """
+        if self._len is None:
+            for x in self:
+                pass
+        return self._len
+
+    def before(self, dt, inc=False):
+        """ Returns the last recurrence before the given datetime instance. The
+            inc keyword defines what happens if dt is an occurrence. With
+            inc=True, if dt itself is an occurrence, it will be returned. """
+        if self._cache_complete:
+            gen = self._cache
+        else:
+            gen = self
+        last = None
+        if inc:
+            for i in gen:
+                if i > dt:
+                    break
+                last = i
+        else:
+            for i in gen:
+                if i >= dt:
+                    break
+                last = i
+        return last
+
+    def after(self, dt, inc=False):
+        """ Returns the first recurrence after the given datetime instance. The
+            inc keyword defines what happens if dt is an occurrence. With
+            inc=True, if dt itself is an occurrence, it will be returned.  """
+        if self._cache_complete:
+            gen = self._cache
+        else:
+            gen = self
+        if inc:
+            for i in gen:
+                if i >= dt:
+                    return i
+        else:
+            for i in gen:
+                if i > dt:
+                    return i
+        return None
+
+    def xafter(self, dt, count=None, inc=False):
+        """
+        Generator which yields up to `count` recurrences after the given
+        datetime instance, equivalent to `after`.
+
+        :param dt:
+            The datetime at which to start generating recurrences.
+
+        :param count:
+            The maximum number of recurrences to generate. If `None` (default),
+            dates are generated until the recurrence rule is exhausted.
+
+        :param inc:
+            If `dt` is an instance of the rule and `inc` is `True`, it is
+            included in the output.
+
+        :yields: Yields a sequence of `datetime` objects.
+        """
+
+        if self._cache_complete:
+            gen = self._cache
+        else:
+            gen = self
+
+        # Select the comparison function
+        if inc:
+            comp = lambda dc, dtc: dc >= dtc
+        else:
+            comp = lambda dc, dtc: dc > dtc
+
+        # Generate dates
+        n = 0
+        for d in gen:
+            if comp(d, dt):
+                if count is not None:
+                    n += 1
+                    if n > count:
+                        break
+
+                yield d
+
+    def between(self, after, before, inc=False, count=1):
+        """ Returns all the occurrences of the rrule between after and before.
+        The inc keyword defines what happens if after and/or before are
+        themselves occurrences. With inc=True, they will be included in the
+        list, if they are found in the recurrence set. """
+        if self._cache_complete:
+            gen = self._cache
+        else:
+            gen = self
+        started = False
+        l = []
+        if inc:
+            for i in gen:
+                if i > before:
+                    break
+                elif not started:
+                    if i >= after:
+                        started = True
+                        l.append(i)
+                else:
+                    l.append(i)
+        else:
+            for i in gen:
+                if i >= before:
+                    break
+                elif not started:
+                    if i > after:
+                        started = True
+                        l.append(i)
+                else:
+                    l.append(i)
+        return l
+
+
+class rrule(rrulebase):
+    """
+    That's the base of the rrule operation. It accepts all the keywords
+    defined in the RFC as its constructor parameters (except byday,
+    which was renamed to byweekday) and more. The constructor prototype is::
+
+            rrule(freq)
+
+    Where freq must be one of YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY,
+    or SECONDLY.
+
+    .. note::
+        Per RFC section 3.3.10, recurrence instances falling on invalid dates
+        and times are ignored rather than coerced:
+
+            Recurrence rules may generate recurrence instances with an invalid
+            date (e.g., February 30) or nonexistent local time (e.g., 1:30 AM
+            on a day where the local time is moved forward by an hour at 1:00
+            AM).  Such recurrence instances MUST be ignored and MUST NOT be
+            counted as part of the recurrence set.
+
+        This can lead to possibly surprising behavior when, for example, the
+        start date occurs at the end of the month:
+
+        >>> from dateutil.rrule import rrule, MONTHLY
+        >>> from datetime import datetime
+        >>> start_date = datetime(2014, 12, 31)
+        >>> list(rrule(freq=MONTHLY, count=4, dtstart=start_date))
+        ... # doctest: +NORMALIZE_WHITESPACE
+        [datetime.datetime(2014, 12, 31, 0, 0),
+         datetime.datetime(2015, 1, 31, 0, 0),
+         datetime.datetime(2015, 3, 31, 0, 0),
+         datetime.datetime(2015, 5, 31, 0, 0)]
+
+    Additionally, it supports the following keyword arguments:
+
+    :param dtstart:
+        The recurrence start. Besides being the base for the recurrence,
+        missing parameters in the final recurrence instances will also be
+        extracted from this date. If not given, datetime.now() will be used
+        instead.
+    :param interval:
+        The interval between each freq iteration. For example, when using
+        YEARLY, an interval of 2 means once every two years, but with HOURLY,
+        it means once every two hours. The default interval is 1.
+    :param wkst:
+        The week start day. Must be one of the MO, TU, WE constants, or an
+        integer, specifying the first day of the week. This will affect
+        recurrences based on weekly periods. The default week start is got
+        from calendar.firstweekday(), and may be modified by
+        calendar.setfirstweekday().
+    :param count:
+        If given, this determines how many occurrences will be generated.
+
+        .. note::
+            As of version 2.5.0, the use of the keyword ``until`` in conjunction
+            with ``count`` is deprecated, to make sure ``dateutil`` is fully
+            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
+            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
+            **must not** occur in the same call to ``rrule``.
+    :param until:
+        If given, this must be a datetime instance specifying the upper-bound
+        limit of the recurrence. The last recurrence in the rule is the greatest
+        datetime that is less than or equal to the value specified in the
+        ``until`` parameter.
+
+        .. note::
+            As of version 2.5.0, the use of the keyword ``until`` in conjunction
+            with ``count`` is deprecated, to make sure ``dateutil`` is fully
+            compliant with `RFC-5545 Sec. 3.3.10 <https://tools.ietf.org/
+            html/rfc5545#section-3.3.10>`_. Therefore, ``until`` and ``count``
+            **must not** occur in the same call to ``rrule``.
+    :param bysetpos:
+        If given, it must be either an integer, or a sequence of integers,
+        positive or negative. Each given integer will specify an occurrence
+        number, corresponding to the nth occurrence of the rule inside the
+        frequency period. For example, a bysetpos of -1 if combined with a
+        MONTHLY frequency, and a byweekday of (MO, TU, WE, TH, FR), will
+        result in the last work day of every month.
+    :param bymonth:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the months to apply the recurrence to.
+    :param bymonthday:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the month days to apply the recurrence to.
+    :param byyearday:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the year days to apply the recurrence to.
+    :param byeaster:
+        If given, it must be either an integer, or a sequence of integers,
+        positive or negative. Each integer will define an offset from the
+        Easter Sunday. Passing the offset 0 to byeaster will yield the Easter
+        Sunday itself. This is an extension to the RFC specification.
+    :param byweekno:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the week numbers to apply the recurrence to. Week numbers
+        have the meaning described in ISO8601, that is, the first week of
+        the year is that containing at least four days of the new year.
+    :param byweekday:
+        If given, it must be either an integer (0 == MO), a sequence of
+        integers, one of the weekday constants (MO, TU, etc), or a sequence
+        of these constants. When given, these variables will define the
+        weekdays where the recurrence will be applied. It's also possible to
+        use an argument n for the weekday instances, which will mean the nth
+        occurrence of this weekday in the period. For example, with MONTHLY,
+        or with YEARLY and BYMONTH, using FR(+1) in byweekday will specify the
+        first friday of the month where the recurrence happens. Notice that in
+        the RFC documentation, this is specified as BYDAY, but was renamed to
+        avoid the ambiguity of that keyword.
+    :param byhour:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the hours to apply the recurrence to.
+    :param byminute:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the minutes to apply the recurrence to.
+    :param bysecond:
+        If given, it must be either an integer, or a sequence of integers,
+        meaning the seconds to apply the recurrence to.
+    :param cache:
+        If given, it must be a boolean value specifying to enable or disable
+        caching of results. If you will use the same rrule instance multiple
+        times, enabling caching will improve the performance considerably.
+     """
+    def __init__(self, freq, dtstart=None,
+                 interval=1, wkst=None, count=None, until=None, bysetpos=None,
+                 bymonth=None, bymonthday=None, byyearday=None, byeaster=None,
+                 byweekno=None, byweekday=None,
+                 byhour=None, byminute=None, bysecond=None,
+                 cache=False):
+        super(rrule, self).__init__(cache)
+        global easter
+        if not dtstart:
+            if until and until.tzinfo:
+                dtstart = datetime.datetime.now(tz=until.tzinfo).replace(microsecond=0)
+            else:
+                dtstart = datetime.datetime.now().replace(microsecond=0)
+        elif not isinstance(dtstart, datetime.datetime):
+            dtstart = datetime.datetime.fromordinal(dtstart.toordinal())
+        else:
+            dtstart = dtstart.replace(microsecond=0)
+        self._dtstart = dtstart
+        self._tzinfo = dtstart.tzinfo
+        self._freq = freq
+        self._interval = interval
+        self._count = count
+
+        # Cache the original byxxx rules, if they are provided, as the _byxxx
+        # attributes do not necessarily map to the inputs, and this can be
+        # a problem in generating the strings. Only store things if they've
+        # been supplied (the string retrieval will just use .get())
+        self._original_rule = {}
+
+        if until and not isinstance(until, datetime.datetime):
+            until = datetime.datetime.fromordinal(until.toordinal())
+        self._until = until
+
+        if self._dtstart and self._until:
+            if (self._dtstart.tzinfo is not None) != (self._until.tzinfo is not None):
+                # According to RFC5545 Section 3.3.10:
+                # https://tools.ietf.org/html/rfc5545#section-3.3.10
+                #
+                # > If the "DTSTART" property is specified as a date with UTC
+                # > time or a date with local time and time zone reference,
+                # > then the UNTIL rule part MUST be specified as a date with
+                # > UTC time.
+                raise ValueError(
+                    'RRULE UNTIL values must be specified in UTC when DTSTART '
+                    'is timezone-aware'
+                )
+
+        if count is not None and until:
+            warn("Using both 'count' and 'until' is inconsistent with RFC 5545"
+                 " and has been deprecated in dateutil. Future versions will "
+                 "raise an error.", DeprecationWarning)
+
+        if wkst is None:
+            self._wkst = calendar.firstweekday()
+        elif isinstance(wkst, integer_types):
+            self._wkst = wkst
+        else:
+            self._wkst = wkst.weekday
+
+        if bysetpos is None:
+            self._bysetpos = None
+        elif isinstance(bysetpos, integer_types):
+            if bysetpos == 0 or not (-366 <= bysetpos <= 366):
+                raise ValueError("bysetpos must be between 1 and 366, "
+                                 "or between -366 and -1")
+            self._bysetpos = (bysetpos,)
+        else:
+            self._bysetpos = tuple(bysetpos)
+            for pos in self._bysetpos:
+                if pos == 0 or not (-366 <= pos <= 366):
+                    raise ValueError("bysetpos must be between 1 and 366, "
+                                     "or between -366 and -1")
+
+        if self._bysetpos:
+            self._original_rule['bysetpos'] = self._bysetpos
+
+        if (byweekno is None and byyearday is None and bymonthday is None and
+                byweekday is None and byeaster is None):
+            if freq == YEARLY:
+                if bymonth is None:
+                    bymonth = dtstart.month
+                    self._original_rule['bymonth'] = None
+                bymonthday = dtstart.day
+                self._original_rule['bymonthday'] = None
+            elif freq == MONTHLY:
+                bymonthday = dtstart.day
+                self._original_rule['bymonthday'] = None
+            elif freq == WEEKLY:
+                byweekday = dtstart.weekday()
+                self._original_rule['byweekday'] = None
+
+        # bymonth
+        if bymonth is None:
+            self._bymonth = None
+        else:
+            if isinstance(bymonth, integer_types):
+                bymonth = (bymonth,)
+
+            self._bymonth = tuple(sorted(set(bymonth)))
+
+            if 'bymonth' not in self._original_rule:
+                self._original_rule['bymonth'] = self._bymonth
+
+        # byyearday
+        if byyearday is None:
+            self._byyearday = None
+        else:
+            if isinstance(byyearday, integer_types):
+                byyearday = (byyearday,)
+
+            self._byyearday = tuple(sorted(set(byyearday)))
+            self._original_rule['byyearday'] = self._byyearday
+
+        # byeaster
+        if byeaster is not None:
+            if not easter:
+                from dateutil import easter
+            if isinstance(byeaster, integer_types):
+                self._byeaster = (byeaster,)
+            else:
+                self._byeaster = tuple(sorted(byeaster))
+
+            self._original_rule['byeaster'] = self._byeaster
+        else:
+            self._byeaster = None
+
+        # bymonthday
+        if bymonthday is None:
+            self._bymonthday = ()
+            self._bynmonthday = ()
+        else:
+            if isinstance(bymonthday, integer_types):
+                bymonthday = (bymonthday,)
+
+            bymonthday = set(bymonthday)            # Ensure it's unique
+
+            self._bymonthday = tuple(sorted(x for x in bymonthday if x > 0))
+            self._bynmonthday = tuple(sorted(x for x in bymonthday if x < 0))
+
+            # Storing positive numbers first, then negative numbers
+            if 'bymonthday' not in self._original_rule:
+                self._original_rule['bymonthday'] = tuple(
+                    itertools.chain(self._bymonthday, self._bynmonthday))
+
+        # byweekno
+        if byweekno is None:
+            self._byweekno = None
+        else:
+            if isinstance(byweekno, integer_types):
+                byweekno = (byweekno,)
+
+            self._byweekno = tuple(sorted(set(byweekno)))
+
+            self._original_rule['byweekno'] = self._byweekno
+
+        # byweekday / bynweekday
+        if byweekday is None:
+            self._byweekday = None
+            self._bynweekday = None
+        else:
+            # If it's one of the valid non-sequence types, convert to a
+            # single-element sequence before the iterator that builds the
+            # byweekday set.
+            if isinstance(byweekday, integer_types) or hasattr(byweekday, "n"):
+                byweekday = (byweekday,)
+
+            self._byweekday = set()
+            self._bynweekday = set()
+            for wday in byweekday:
+                if isinstance(wday, integer_types):
+                    self._byweekday.add(wday)
+                elif not wday.n or freq > MONTHLY:
+                    self._byweekday.add(wday.weekday)
+                else:
+                    self._bynweekday.add((wday.weekday, wday.n))
+
+            if not self._byweekday:
+                self._byweekday = None
+            elif not self._bynweekday:
+                self._bynweekday = None
+
+            if self._byweekday is not None:
+                self._byweekday = tuple(sorted(self._byweekday))
+                orig_byweekday = [weekday(x) for x in self._byweekday]
+            else:
+                orig_byweekday = ()
+
+            if self._bynweekday is not None:
+                self._bynweekday = tuple(sorted(self._bynweekday))
+                orig_bynweekday = [weekday(*x) for x in self._bynweekday]
+            else:
+                orig_bynweekday = ()
+
+            if 'byweekday' not in self._original_rule:
+                self._original_rule['byweekday'] = tuple(itertools.chain(
+                    orig_byweekday, orig_bynweekday))
+
+        # byhour
+        if byhour is None:
+            if freq < HOURLY:
+                self._byhour = {dtstart.hour}
+            else:
+                self._byhour = None
+        else:
+            if isinstance(byhour, integer_types):
+                byhour = (byhour,)
+
+            if freq == HOURLY:
+                self._byhour = self.__construct_byset(start=dtstart.hour,
+                                                      byxxx=byhour,
+                                                      base=24)
+            else:
+                self._byhour = set(byhour)
+
+            self._byhour = tuple(sorted(self._byhour))
+            self._original_rule['byhour'] = self._byhour
+
+        # byminute
+        if byminute is None:
+            if freq < MINUTELY:
+                self._byminute = {dtstart.minute}
+            else:
+                self._byminute = None
+        else:
+            if isinstance(byminute, integer_types):
+                byminute = (byminute,)
+
+            if freq == MINUTELY:
+                self._byminute = self.__construct_byset(start=dtstart.minute,
+                                                        byxxx=byminute,
+                                                        base=60)
+            else:
+                self._byminute = set(byminute)
+
+            self._byminute = tuple(sorted(self._byminute))
+            self._original_rule['byminute'] = self._byminute
+
+        # bysecond
+        if bysecond is None:
+            if freq < SECONDLY:
+                self._bysecond = ((dtstart.second,))
+            else:
+                self._bysecond = None
+        else:
+            if isinstance(bysecond, integer_types):
+                bysecond = (bysecond,)
+
+            self._bysecond = set(bysecond)
+
+            if freq == SECONDLY:
+                self._bysecond = self.__construct_byset(start=dtstart.second,
+                                                        byxxx=bysecond,
+                                                        base=60)
+            else:
+                self._bysecond = set(bysecond)
+
+            self._bysecond = tuple(sorted(self._bysecond))
+            self._original_rule['bysecond'] = self._bysecond
+
+        if self._freq >= HOURLY:
+            self._timeset = None
+        else:
+            self._timeset = []
+            for hour in self._byhour:
+                for minute in self._byminute:
+                    for second in self._bysecond:
+                        self._timeset.append(
+                            datetime.time(hour, minute, second,
+                                          tzinfo=self._tzinfo))
+            self._timeset.sort()
+            self._timeset = tuple(self._timeset)
+
+    def __str__(self):
+        """
+        Output a string that would generate this RRULE if passed to rrulestr.
+        This is mostly compatible with RFC5545, except for the
+        dateutil-specific extension BYEASTER.
+        """
+
+        output = []
+        h, m, s = [None] * 3
+        if self._dtstart:
+            output.append(self._dtstart.strftime('DTSTART:%Y%m%dT%H%M%S'))
+            h, m, s = self._dtstart.timetuple()[3:6]
+
+        parts = ['FREQ=' + FREQNAMES[self._freq]]
+        if self._interval != 1:
+            parts.append('INTERVAL=' + str(self._interval))
+
+        if self._wkst:
+            parts.append('WKST=' + repr(weekday(self._wkst))[0:2])
+
+        if self._count is not None:
+            parts.append('COUNT=' + str(self._count))
+
+        if self._until:
+            parts.append(self._until.strftime('UNTIL=%Y%m%dT%H%M%S'))
+
+        if self._original_rule.get('byweekday') is not None:
+            # The str() method on weekday objects doesn't generate
+            # RFC5545-compliant strings, so we should modify that.
+            original_rule = dict(self._original_rule)
+            wday_strings = []
+            for wday in original_rule['byweekday']:
+                if wday.n:
+                    wday_strings.append('{n:+d}{wday}'.format(
+                        n=wday.n,
+                        wday=repr(wday)[0:2]))
+                else:
+                    wday_strings.append(repr(wday))
+
+            original_rule['byweekday'] = wday_strings
+        else:
+            original_rule = self._original_rule
+
+        partfmt = '{name}={vals}'
+        for name, key in [('BYSETPOS', 'bysetpos'),
+                          ('BYMONTH', 'bymonth'),
+                          ('BYMONTHDAY', 'bymonthday'),
+                          ('BYYEARDAY', 'byyearday'),
+                          ('BYWEEKNO', 'byweekno'),
+                          ('BYDAY', 'byweekday'),
+                          ('BYHOUR', 'byhour'),
+                          ('BYMINUTE', 'byminute'),
+                          ('BYSECOND', 'bysecond'),
+                          ('BYEASTER', 'byeaster')]:
+            value = original_rule.get(key)
+            if value:
+                parts.append(partfmt.format(name=name, vals=(','.join(str(v)
+                                                             for v in value))))
+
+        output.append('RRULE:' + ';'.join(parts))
+        return '\n'.join(output)
+
+    def replace(self, **kwargs):
+        """Return new rrule with same attributes except for those attributes given new
+           values by whichever keyword arguments are specified."""
+        new_kwargs = {"interval": self._interval,
+                      "count": self._count,
+                      "dtstart": self._dtstart,
+                      "freq": self._freq,
+                      "until": self._until,
+                      "wkst": self._wkst,
+                      "cache": False if self._cache is None else True }
+        new_kwargs.update(self._original_rule)
+        new_kwargs.update(kwargs)
+        return rrule(**new_kwargs)
+
+    def _iter(self):
+        year, month, day, hour, minute, second, weekday, yearday, _ = \
+            self._dtstart.timetuple()
+
+        # Some local variables to speed things up a bit
+        freq = self._freq
+        interval = self._interval
+        wkst = self._wkst
+        until = self._until
+        bymonth = self._bymonth
+        byweekno = self._byweekno
+        byyearday = self._byyearday
+        byweekday = self._byweekday
+        byeaster = self._byeaster
+        bymonthday = self._bymonthday
+        bynmonthday = self._bynmonthday
+        bysetpos = self._bysetpos
+        byhour = self._byhour
+        byminute = self._byminute
+        bysecond = self._bysecond
+
+        ii = _iterinfo(self)
+        ii.rebuild(year, month)
+
+        getdayset = {YEARLY: ii.ydayset,
+                     MONTHLY: ii.mdayset,
+                     WEEKLY: ii.wdayset,
+                     DAILY: ii.ddayset,
+                     HOURLY: ii.ddayset,
+                     MINUTELY: ii.ddayset,
+                     SECONDLY: ii.ddayset}[freq]
+
+        if freq < HOURLY:
+            timeset = self._timeset
+        else:
+            gettimeset = {HOURLY: ii.htimeset,
+                          MINUTELY: ii.mtimeset,
+                          SECONDLY: ii.stimeset}[freq]
+            if ((freq >= HOURLY and
+                 self._byhour and hour not in self._byhour) or
+                (freq >= MINUTELY and
+                 self._byminute and minute not in self._byminute) or
+                (freq >= SECONDLY and
+                 self._bysecond and second not in self._bysecond)):
+                timeset = ()
+            else:
+                timeset = gettimeset(hour, minute, second)
+
+        total = 0
+        count = self._count
+        while True:
+            # Get dayset with the right frequency
+            dayset, start, end = getdayset(year, month, day)
+
+            # Do the "hard" work ;-)
+            filtered = False
+            for i in dayset[start:end]:
+                if ((bymonth and ii.mmask[i] not in bymonth) or
+                    (byweekno and not ii.wnomask[i]) or
+                    (byweekday and ii.wdaymask[i] not in byweekday) or
+                    (ii.nwdaymask and not ii.nwdaymask[i]) or
+                    (byeaster and not ii.eastermask[i]) or
+                    ((bymonthday or bynmonthday) and
+                     ii.mdaymask[i] not in bymonthday and
+                     ii.nmdaymask[i] not in bynmonthday) or
+                    (byyearday and
+                     ((i < ii.yearlen and i+1 not in byyearday and
+                       -ii.yearlen+i not in byyearday) or
+                      (i >= ii.yearlen and i+1-ii.yearlen not in byyearday and
+                       -ii.nextyearlen+i-ii.yearlen not in byyearday)))):
+                    dayset[i] = None
+                    filtered = True
+
+            # Output results
+            if bysetpos and timeset:
+                poslist = []
+                for pos in bysetpos:
+                    if pos < 0:
+                        daypos, timepos = divmod(pos, len(timeset))
+                    else:
+                        daypos, timepos = divmod(pos-1, len(timeset))
+                    try:
+                        i = [x for x in dayset[start:end]
+                             if x is not None][daypos]
+                        time = timeset[timepos]
+                    except IndexError:
+                        pass
+                    else:
+                        date = datetime.date.fromordinal(ii.yearordinal+i)
+                        res = datetime.datetime.combine(date, time)
+                        if res not in poslist:
+                            poslist.append(res)
+                poslist.sort()
+                for res in poslist:
+                    if until and res > until:
+                        self._len = total
+                        return
+                    elif res >= self._dtstart:
+                        if count is not None:
+                            count -= 1
+                            if count < 0:
+                                self._len = total
+                                return
+                        total += 1
+                        yield res
+            else:
+                for i in dayset[start:end]:
+                    if i is not None:
+                        date = datetime.date.fromordinal(ii.yearordinal + i)
+                        for time in timeset:
+                            res = datetime.datetime.combine(date, time)
+                            if until and res > until:
+                                self._len = total
+                                return
+                            elif res >= self._dtstart:
+                                if count is not None:
+                                    count -= 1
+                                    if count < 0:
+                                        self._len = total
+                                        return
+
+                                total += 1
+                                yield res
+
+            # Handle frequency and interval
+            fixday = False
+            if freq == YEARLY:
+                year += interval
+                if year > datetime.MAXYEAR:
+                    self._len = total
+                    return
+                ii.rebuild(year, month)
+            elif freq == MONTHLY:
+                month += interval
+                if month > 12:
+                    div, mod = divmod(month, 12)
+                    month = mod
+                    year += div
+                    if month == 0:
+                        month = 12
+                        year -= 1
+                    if year > datetime.MAXYEAR:
+                        self._len = total
+                        return
+                ii.rebuild(year, month)
+            elif freq == WEEKLY:
+                if wkst > weekday:
+                    day += -(weekday+1+(6-wkst))+self._interval*7
+                else:
+                    day += -(weekday-wkst)+self._interval*7
+                weekday = wkst
+                fixday = True
+            elif freq == DAILY:
+                day += interval
+                fixday = True
+            elif freq == HOURLY:
+                if filtered:
+                    # Jump to one iteration before next day
+                    hour += ((23-hour)//interval)*interval
+
+                if byhour:
+                    ndays, hour = self.__mod_distance(value=hour,
+                                                      byxxx=self._byhour,
+                                                      base=24)
+                else:
+                    ndays, hour = divmod(hour+interval, 24)
+
+                if ndays:
+                    day += ndays
+                    fixday = True
+
+                timeset = gettimeset(hour, minute, second)
+            elif freq == MINUTELY:
+                if filtered:
+                    # Jump to one iteration before next day
+                    minute += ((1439-(hour*60+minute))//interval)*interval
+
+                valid = False
+                rep_rate = (24*60)
+                for j in range(rep_rate // gcd(interval, rep_rate)):
+                    if byminute:
+                        nhours, minute = \
+                            self.__mod_distance(value=minute,
+                                                byxxx=self._byminute,
+                                                base=60)
+                    else:
+                        nhours, minute = divmod(minute+interval, 60)
+
+                    div, hour = divmod(hour+nhours, 24)
+                    if div:
+                        day += div
+                        fixday = True
+                        filtered = False
+
+                    if not byhour or hour in byhour:
+                        valid = True
+                        break
+
+                if not valid:
+                    raise ValueError('Invalid combination of interval and ' +
+                                     'byhour resulting in empty rule.')
+
+                timeset = gettimeset(hour, minute, second)
+            elif freq == SECONDLY:
+                if filtered:
+                    # Jump to one iteration before next day
+                    second += (((86399 - (hour * 3600 + minute * 60 + second))
+                                // interval) * interval)
+
+                rep_rate = (24 * 3600)
+                valid = False
+                for j in range(0, rep_rate // gcd(interval, rep_rate)):
+                    if bysecond:
+                        nminutes, second = \
+                            self.__mod_distance(value=second,
+                                                byxxx=self._bysecond,
+                                                base=60)
+                    else:
+                        nminutes, second = divmod(second+interval, 60)
+
+                    div, minute = divmod(minute+nminutes, 60)
+                    if div:
+                        hour += div
+                        div, hour = divmod(hour, 24)
+                        if div:
+                            day += div
+                            fixday = True
+
+                    if ((not byhour or hour in byhour) and
+                            (not byminute or minute in byminute) and
+                            (not bysecond or second in bysecond)):
+                        valid = True
+                        break
+
+                if not valid:
+                    raise ValueError('Invalid combination of interval, ' +
+                                     'byhour and byminute resulting in empty' +
+                                     ' rule.')
+
+                timeset = gettimeset(hour, minute, second)
+
+            if fixday and day > 28:
+                daysinmonth = calendar.monthrange(year, month)[1]
+                if day > daysinmonth:
+                    while day > daysinmonth:
+                        day -= daysinmonth
+                        month += 1
+                        if month == 13:
+                            month = 1
+                            year += 1
+                            if year > datetime.MAXYEAR:
+                                self._len = total
+                                return
+                        daysinmonth = calendar.monthrange(year, month)[1]
+                    ii.rebuild(year, month)
+
+    def __construct_byset(self, start, byxxx, base):
+        """
+        If a `BYXXX` sequence is passed to the constructor at the same level as
+        `FREQ` (e.g. `FREQ=HOURLY,BYHOUR={2,4,7},INTERVAL=3`), there are some
+        specifications which cannot be reached given some starting conditions.
+
+        This occurs whenever the interval is not coprime with the base of a
+        given unit and the difference between the starting position and the
+        ending position is not coprime with the greatest common denominator
+        between the interval and the base. For example, with a FREQ of hourly
+        starting at 17:00 and an interval of 4, the only valid values for
+        BYHOUR would be {21, 1, 5, 9, 13, 17}, because 4 and 24 are not
+        coprime.
+
+        :param start:
+            Specifies the starting position.
+        :param byxxx:
+            An iterable containing the list of allowed values.
+        :param base:
+            The largest allowable value for the specified frequency (e.g.
+            24 hours, 60 minutes).
+
+        This does not preserve the type of the iterable, returning a set, since
+        the values should be unique and the order is irrelevant, this will
+        speed up later lookups.
+
+        In the event of an empty set, raises a :exception:`ValueError`, as this
+        results in an empty rrule.
+        """
+
+        cset = set()
+
+        # Support a single byxxx value.
+        if isinstance(byxxx, integer_types):
+            byxxx = (byxxx, )
+
+        for num in byxxx:
+            i_gcd = gcd(self._interval, base)
+            # Use divmod rather than % because we need to wrap negative nums.
+            if i_gcd == 1 or divmod(num - start, i_gcd)[1] == 0:
+                cset.add(num)
+
+        if len(cset) == 0:
+            raise ValueError("Invalid rrule byxxx generates an empty set.")
+
+        return cset
+
+    def __mod_distance(self, value, byxxx, base):
+        """
+        Calculates the next value in a sequence where the `FREQ` parameter is
+        specified along with a `BYXXX` parameter at the same "level"
+        (e.g. `HOURLY` specified with `BYHOUR`).
+
+        :param value:
+            The old value of the component.
+        :param byxxx:
+            The `BYXXX` set, which should have been generated by
+            `rrule._construct_byset`, or something else which checks that a
+            valid rule is present.
+        :param base:
+            The largest allowable value for the specified frequency (e.g.
+            24 hours, 60 minutes).
+
+        If a valid value is not found after `base` iterations (the maximum
+        number before the sequence would start to repeat), this raises a
+        :exception:`ValueError`, as no valid values were found.
+
+        This returns a tuple of `divmod(n*interval, base)`, where `n` is the
+        smallest number of `interval` repetitions until the next specified
+        value in `byxxx` is found.
+        """
+        accumulator = 0
+        for ii in range(1, base + 1):
+            # Using divmod() over % to account for negative intervals
+            div, value = divmod(value + self._interval, base)
+            accumulator += div
+            if value in byxxx:
+                return (accumulator, value)
+
+
+class _iterinfo(object):
+    __slots__ = ["rrule", "lastyear", "lastmonth",
+                 "yearlen", "nextyearlen", "yearordinal", "yearweekday",
+                 "mmask", "mrange", "mdaymask", "nmdaymask",
+                 "wdaymask", "wnomask", "nwdaymask", "eastermask"]
+
+    def __init__(self, rrule):
+        for attr in self.__slots__:
+            setattr(self, attr, None)
+        self.rrule = rrule
+
+    def rebuild(self, year, month):
+        # Every mask is 7 days longer to handle cross-year weekly periods.
+        rr = self.rrule
+        if year != self.lastyear:
+            self.yearlen = 365 + calendar.isleap(year)
+            self.nextyearlen = 365 + calendar.isleap(year + 1)
+            firstyday = datetime.date(year, 1, 1)
+            self.yearordinal = firstyday.toordinal()
+            self.yearweekday = firstyday.weekday()
+
+            wday = datetime.date(year, 1, 1).weekday()
+            if self.yearlen == 365:
+                self.mmask = M365MASK
+                self.mdaymask = MDAY365MASK
+                self.nmdaymask = NMDAY365MASK
+                self.wdaymask = WDAYMASK[wday:]
+                self.mrange = M365RANGE
+            else:
+                self.mmask = M366MASK
+                self.mdaymask = MDAY366MASK
+                self.nmdaymask = NMDAY366MASK
+                self.wdaymask = WDAYMASK[wday:]
+                self.mrange = M366RANGE
+
+            if not rr._byweekno:
+                self.wnomask = None
+            else:
+                self.wnomask = [0]*(self.yearlen+7)
+                # no1wkst = firstwkst = self.wdaymask.index(rr._wkst)
+                no1wkst = firstwkst = (7-self.yearweekday+rr._wkst) % 7
+                if no1wkst >= 4:
+                    no1wkst = 0
+                    # Number of days in the year, plus the days we got
+                    # from last year.
+                    wyearlen = self.yearlen+(self.yearweekday-rr._wkst) % 7
+                else:
+                    # Number of days in the year, minus the days we
+                    # left in last year.
+                    wyearlen = self.yearlen-no1wkst
+                div, mod = divmod(wyearlen, 7)
+                numweeks = div+mod//4
+                for n in rr._byweekno:
+                    if n < 0:
+                        n += numweeks+1
+                    if not (0 < n <= numweeks):
+                        continue
+                    if n > 1:
+                        i = no1wkst+(n-1)*7
+                        if no1wkst != firstwkst:
+                            i -= 7-firstwkst
+                    else:
+                        i = no1wkst
+                    for j in range(7):
+                        self.wnomask[i] = 1
+                        i += 1
+                        if self.wdaymask[i] == rr._wkst:
+                            break
+                if 1 in rr._byweekno:
+                    # Check week number 1 of next year as well
+                    # TODO: Check -numweeks for next year.
+                    i = no1wkst+numweeks*7
+                    if no1wkst != firstwkst:
+                        i -= 7-firstwkst
+                    if i < self.yearlen:
+                        # If week starts in next year, we
+                        # don't care about it.
+                        for j in range(7):
+                            self.wnomask[i] = 1
+                            i += 1
+                            if self.wdaymask[i] == rr._wkst:
+                                break
+                if no1wkst:
+                    # Check last week number of last year as
+                    # well. If no1wkst is 0, either the year
+                    # started on week start, or week number 1
+                    # got days from last year, so there are no
+                    # days from last year's last week number in
+                    # this year.
+                    if -1 not in rr._byweekno:
+                        lyearweekday = datetime.date(year-1, 1, 1).weekday()
+                        lno1wkst = (7-lyearweekday+rr._wkst) % 7
+                        lyearlen = 365+calendar.isleap(year-1)
+                        if lno1wkst >= 4:
+                            lno1wkst = 0
+                            lnumweeks = 52+(lyearlen +
+                                            (lyearweekday-rr._wkst) % 7) % 7//4
+                        else:
+                            lnumweeks = 52+(self.yearlen-no1wkst) % 7//4
+                    else:
+                        lnumweeks = -1
+                    if lnumweeks in rr._byweekno:
+                        for i in range(no1wkst):
+                            self.wnomask[i] = 1
+
+        if (rr._bynweekday and (month != self.lastmonth or
+                                year != self.lastyear)):
+            ranges = []
+            if rr._freq == YEARLY:
+                if rr._bymonth:
+                    for month in rr._bymonth:
+                        ranges.append(self.mrange[month-1:month+1])
+                else:
+                    ranges = [(0, self.yearlen)]
+            elif rr._freq == MONTHLY:
+                ranges = [self.mrange[month-1:month+1]]
+            if ranges:
+                # Weekly frequency won't get here, so we may not
+                # care about cross-year weekly periods.
+                self.nwdaymask = [0]*self.yearlen
+                for first, last in ranges:
+                    last -= 1
+                    for wday, n in rr._bynweekday:
+                        if n < 0:
+                            i = last+(n+1)*7
+                            i -= (self.wdaymask[i]-wday) % 7
+                        else:
+                            i = first+(n-1)*7
+                            i += (7-self.wdaymask[i]+wday) % 7
+                        if first <= i <= last:
+                            self.nwdaymask[i] = 1
+
+        if rr._byeaster:
+            self.eastermask = [0]*(self.yearlen+7)
+            eyday = easter.easter(year).toordinal()-self.yearordinal
+            for offset in rr._byeaster:
+                self.eastermask[eyday+offset] = 1
+
+        self.lastyear = year
+        self.lastmonth = month
+
+    def ydayset(self, year, month, day):
+        return list(range(self.yearlen)), 0, self.yearlen
+
+    def mdayset(self, year, month, day):
+        dset = [None]*self.yearlen
+        start, end = self.mrange[month-1:month+1]
+        for i in range(start, end):
+            dset[i] = i
+        return dset, start, end
+
+    def wdayset(self, year, month, day):
+        # We need to handle cross-year weeks here.
+        dset = [None]*(self.yearlen+7)
+        i = datetime.date(year, month, day).toordinal()-self.yearordinal
+        start = i
+        for j in range(7):
+            dset[i] = i
+            i += 1
+            # if (not (0 <= i < self.yearlen) or
+            #    self.wdaymask[i] == self.rrule._wkst):
+            # This will cross the year boundary, if necessary.
+            if self.wdaymask[i] == self.rrule._wkst:
+                break
+        return dset, start, i
+
+    def ddayset(self, year, month, day):
+        dset = [None] * self.yearlen
+        i = datetime.date(year, month, day).toordinal() - self.yearordinal
+        dset[i] = i
+        return dset, i, i + 1
+
+    def htimeset(self, hour, minute, second):
+        tset = []
+        rr = self.rrule
+        for minute in rr._byminute:
+            for second in rr._bysecond:
+                tset.append(datetime.time(hour, minute, second,
+                                          tzinfo=rr._tzinfo))
+        tset.sort()
+        return tset
+
+    def mtimeset(self, hour, minute, second):
+        tset = []
+        rr = self.rrule
+        for second in rr._bysecond:
+            tset.append(datetime.time(hour, minute, second, tzinfo=rr._tzinfo))
+        tset.sort()
+        return tset
+
+    def stimeset(self, hour, minute, second):
+        return (datetime.time(hour, minute, second,
+                tzinfo=self.rrule._tzinfo),)
+
+
+class rruleset(rrulebase):
+    """ The rruleset type allows more complex recurrence setups, mixing
+    multiple rules, dates, exclusion rules, and exclusion dates. The type
+    constructor takes the following keyword arguments:
+
+    :param cache: If True, caching of results will be enabled, improving
+                  performance of multiple queries considerably. """
+
+    class _genitem(object):
+        def __init__(self, genlist, gen):
+            try:
+                self.dt = advance_iterator(gen)
+                genlist.append(self)
+            except StopIteration:
+                pass
+            self.genlist = genlist
+            self.gen = gen
+
+        def __next__(self):
+            try:
+                self.dt = advance_iterator(self.gen)
+            except StopIteration:
+                if self.genlist[0] is self:
+                    heapq.heappop(self.genlist)
+                else:
+                    self.genlist.remove(self)
+                    heapq.heapify(self.genlist)
+
+        next = __next__
+
+        def __lt__(self, other):
+            return self.dt < other.dt
+
+        def __gt__(self, other):
+            return self.dt > other.dt
+
+        def __eq__(self, other):
+            return self.dt == other.dt
+
+        def __ne__(self, other):
+            return self.dt != other.dt
+
+    def __init__(self, cache=False):
+        super(rruleset, self).__init__(cache)
+        self._rrule = []
+        self._rdate = []
+        self._exrule = []
+        self._exdate = []
+
+    @_invalidates_cache
+    def rrule(self, rrule):
+        """ Include the given :py:class:`rrule` instance in the recurrence set
+            generation. """
+        self._rrule.append(rrule)
+
+    @_invalidates_cache
+    def rdate(self, rdate):
+        """ Include the given :py:class:`datetime` instance in the recurrence
+            set generation. """
+        self._rdate.append(rdate)
+
+    @_invalidates_cache
+    def exrule(self, exrule):
+        """ Include the given rrule instance in the recurrence set exclusion
+            list. Dates which are part of the given recurrence rules will not
+            be generated, even if some inclusive rrule or rdate matches them.
+        """
+        self._exrule.append(exrule)
+
+    @_invalidates_cache
+    def exdate(self, exdate):
+        """ Include the given datetime instance in the recurrence set
+            exclusion list. Dates included that way will not be generated,
+            even if some inclusive rrule or rdate matches them. """
+        self._exdate.append(exdate)
+
+    def _iter(self):
+        rlist = []
+        self._rdate.sort()
+        self._genitem(rlist, iter(self._rdate))
+        for gen in [iter(x) for x in self._rrule]:
+            self._genitem(rlist, gen)
+        exlist = []
+        self._exdate.sort()
+        self._genitem(exlist, iter(self._exdate))
+        for gen in [iter(x) for x in self._exrule]:
+            self._genitem(exlist, gen)
+        lastdt = None
+        total = 0
+        heapq.heapify(rlist)
+        heapq.heapify(exlist)
+        while rlist:
+            ritem = rlist[0]
+            if not lastdt or lastdt != ritem.dt:
+                while exlist and exlist[0] < ritem:
+                    exitem = exlist[0]
+                    advance_iterator(exitem)
+                    if exlist and exlist[0] is exitem:
+                        heapq.heapreplace(exlist, exitem)
+                if not exlist or ritem != exlist[0]:
+                    total += 1
+                    yield ritem.dt
+                lastdt = ritem.dt
+            advance_iterator(ritem)
+            if rlist and rlist[0] is ritem:
+                heapq.heapreplace(rlist, ritem)
+        self._len = total
+
+
+
+
+class _rrulestr(object):
+    """ Parses a string representation of a recurrence rule or set of
+    recurrence rules.
+
+    :param s:
+        Required, a string defining one or more recurrence rules.
+
+    :param dtstart:
+        If given, used as the default recurrence start if not specified in the
+        rule string.
+
+    :param cache:
+        If set ``True`` caching of results will be enabled, improving
+        performance of multiple queries considerably.
+
+    :param unfold:
+        If set ``True`` indicates that a rule string is split over more
+        than one line and should be joined before processing.
+
+    :param forceset:
+        If set ``True`` forces a :class:`dateutil.rrule.rruleset` to
+        be returned.
+
+    :param compatible:
+        If set ``True`` forces ``unfold`` and ``forceset`` to be ``True``.
+
+    :param ignoretz:
+        If set ``True``, time zones in parsed strings are ignored and a naive
+        :class:`datetime.datetime` object is returned.
+
+    :param tzids:
+        If given, a callable or mapping used to retrieve a
+        :class:`datetime.tzinfo` from a string representation.
+        Defaults to :func:`dateutil.tz.gettz`.
+
+    :param tzinfos:
+        Additional time zone names / aliases which may be present in a string
+        representation.  See :func:`dateutil.parser.parse` for more
+        information.
+
+    :return:
+        Returns a :class:`dateutil.rrule.rruleset` or
+        :class:`dateutil.rrule.rrule`
+    """
+
+    _freq_map = {"YEARLY": YEARLY,
+                 "MONTHLY": MONTHLY,
+                 "WEEKLY": WEEKLY,
+                 "DAILY": DAILY,
+                 "HOURLY": HOURLY,
+                 "MINUTELY": MINUTELY,
+                 "SECONDLY": SECONDLY}
+
+    _weekday_map = {"MO": 0, "TU": 1, "WE": 2, "TH": 3,
+                    "FR": 4, "SA": 5, "SU": 6}
+
+    def _handle_int(self, rrkwargs, name, value, **kwargs):
+        rrkwargs[name.lower()] = int(value)
+
+    def _handle_int_list(self, rrkwargs, name, value, **kwargs):
+        rrkwargs[name.lower()] = [int(x) for x in value.split(',')]
+
+    _handle_INTERVAL = _handle_int
+    _handle_COUNT = _handle_int
+    _handle_BYSETPOS = _handle_int_list
+    _handle_BYMONTH = _handle_int_list
+    _handle_BYMONTHDAY = _handle_int_list
+    _handle_BYYEARDAY = _handle_int_list
+    _handle_BYEASTER = _handle_int_list
+    _handle_BYWEEKNO = _handle_int_list
+    _handle_BYHOUR = _handle_int_list
+    _handle_BYMINUTE = _handle_int_list
+    _handle_BYSECOND = _handle_int_list
+
+    def _handle_FREQ(self, rrkwargs, name, value, **kwargs):
+        rrkwargs["freq"] = self._freq_map[value]
+
+    def _handle_UNTIL(self, rrkwargs, name, value, **kwargs):
+        global parser
+        if not parser:
+            from dateutil import parser
+        try:
+            rrkwargs["until"] = parser.parse(value,
+                                             ignoretz=kwargs.get("ignoretz"),
+                                             tzinfos=kwargs.get("tzinfos"))
+        except ValueError:
+            raise ValueError("invalid until date")
+
+    def _handle_WKST(self, rrkwargs, name, value, **kwargs):
+        rrkwargs["wkst"] = self._weekday_map[value]
+
+    def _handle_BYWEEKDAY(self, rrkwargs, name, value, **kwargs):
+        """
+        Two ways to specify this: +1MO or MO(+1)
+        """
+        l = []
+        for wday in value.split(','):
+            if '(' in wday:
+                # If it's of the form TH(+1), etc.
+                splt = wday.split('(')
+                w = splt[0]
+                n = int(splt[1][:-1])
+            elif len(wday):
+                # If it's of the form +1MO
+                for i in range(len(wday)):
+                    if wday[i] not in '+-0123456789':
+                        break
+                n = wday[:i] or None
+                w = wday[i:]
+                if n:
+                    n = int(n)
+            else:
+                raise ValueError("Invalid (empty) BYDAY specification.")
+
+            l.append(weekdays[self._weekday_map[w]](n))
+        rrkwargs["byweekday"] = l
+
+    _handle_BYDAY = _handle_BYWEEKDAY
+
+    def _parse_rfc_rrule(self, line,
+                         dtstart=None,
+                         cache=False,
+                         ignoretz=False,
+                         tzinfos=None):
+        if line.find(':') != -1:
+            name, value = line.split(':')
+            if name != "RRULE":
+                raise ValueError("unknown parameter name")
+        else:
+            value = line
+        rrkwargs = {}
+        for pair in value.split(';'):
+            name, value = pair.split('=')
+            name = name.upper()
+            value = value.upper()
+            try:
+                getattr(self, "_handle_"+name)(rrkwargs, name, value,
+                                               ignoretz=ignoretz,
+                                               tzinfos=tzinfos)
+            except AttributeError:
+                raise ValueError("unknown parameter '%s'" % name)
+            except (KeyError, ValueError):
+                raise ValueError("invalid '%s': %s" % (name, value))
+        return rrule(dtstart=dtstart, cache=cache, **rrkwargs)
+
+    def _parse_date_value(self, date_value, parms, rule_tzids,
+                          ignoretz, tzids, tzinfos):
+        global parser
+        if not parser:
+            from dateutil import parser
+
+        datevals = []
+        value_found = False
+        TZID = None
+
+        for parm in parms:
+            if parm.startswith("TZID="):
+                try:
+                    tzkey = rule_tzids[parm.split('TZID=')[-1]]
+                except KeyError:
+                    continue
+                if tzids is None:
+                    from . import tz
+                    tzlookup = tz.gettz
+                elif callable(tzids):
+                    tzlookup = tzids
+                else:
+                    tzlookup = getattr(tzids, 'get', None)
+                    if tzlookup is None:
+                        msg = ('tzids must be a callable, mapping, or None, '
+                               'not %s' % tzids)
+                        raise ValueError(msg)
+
+                TZID = tzlookup(tzkey)
+                continue
+
+            # RFC 5445 3.8.2.4: The VALUE parameter is optional, but may be found
+            # only once.
+            if parm not in {"VALUE=DATE-TIME", "VALUE=DATE"}:
+                raise ValueError("unsupported parm: " + parm)
+            else:
+                if value_found:
+                    msg = ("Duplicate value parameter found in: " + parm)
+                    raise ValueError(msg)
+                value_found = True
+
+        for datestr in date_value.split(','):
+            date = parser.parse(datestr, ignoretz=ignoretz, tzinfos=tzinfos)
+            if TZID is not None:
+                if date.tzinfo is None:
+                    date = date.replace(tzinfo=TZID)
+                else:
+                    raise ValueError('DTSTART/EXDATE specifies multiple timezone')
+            datevals.append(date)
+
+        return datevals
+
+    def _parse_rfc(self, s,
+                   dtstart=None,
+                   cache=False,
+                   unfold=False,
+                   forceset=False,
+                   compatible=False,
+                   ignoretz=False,
+                   tzids=None,
+                   tzinfos=None):
+        global parser
+        if compatible:
+            forceset = True
+            unfold = True
+
+        TZID_NAMES = dict(map(
+            lambda x: (x.upper(), x),
+            re.findall('TZID=(?P<name>[^:]+):', s)
+        ))
+        s = s.upper()
+        if not s.strip():
+            raise ValueError("empty string")
+        if unfold:
+            lines = s.splitlines()
+            i = 0
+            while i < len(lines):
+                line = lines[i].rstrip()
+                if not line:
+                    del lines[i]
+                elif i > 0 and line[0] == " ":
+                    lines[i-1] += line[1:]
+                    del lines[i]
+                else:
+                    i += 1
+        else:
+            lines = s.split()
+        if (not forceset and len(lines) == 1 and (s.find(':') == -1 or
+                                                  s.startswith('RRULE:'))):
+            return self._parse_rfc_rrule(lines[0], cache=cache,
+                                         dtstart=dtstart, ignoretz=ignoretz,
+                                         tzinfos=tzinfos)
+        else:
+            rrulevals = []
+            rdatevals = []
+            exrulevals = []
+            exdatevals = []
+            for line in lines:
+                if not line:
+                    continue
+                if line.find(':') == -1:
+                    name = "RRULE"
+                    value = line
+                else:
+                    name, value = line.split(':', 1)
+                parms = name.split(';')
+                if not parms:
+                    raise ValueError("empty property name")
+                name = parms[0]
+                parms = parms[1:]
+                if name == "RRULE":
+                    for parm in parms:
+                        raise ValueError("unsupported RRULE parm: "+parm)
+                    rrulevals.append(value)
+                elif name == "RDATE":
+                    for parm in parms:
+                        if parm != "VALUE=DATE-TIME":
+                            raise ValueError("unsupported RDATE parm: "+parm)
+                    rdatevals.append(value)
+                elif name == "EXRULE":
+                    for parm in parms:
+                        raise ValueError("unsupported EXRULE parm: "+parm)
+                    exrulevals.append(value)
+                elif name == "EXDATE":
+                    exdatevals.extend(
+                        self._parse_date_value(value, parms,
+                                               TZID_NAMES, ignoretz,
+                                               tzids, tzinfos)
+                    )
+                elif name == "DTSTART":
+                    dtvals = self._parse_date_value(value, parms, TZID_NAMES,
+                                                    ignoretz, tzids, tzinfos)
+                    if len(dtvals) != 1:
+                        raise ValueError("Multiple DTSTART values specified:" +
+                                         value)
+                    dtstart = dtvals[0]
+                else:
+                    raise ValueError("unsupported property: "+name)
+            if (forceset or len(rrulevals) > 1 or rdatevals
+                    or exrulevals or exdatevals):
+                if not parser and (rdatevals or exdatevals):
+                    from dateutil import parser
+                rset = rruleset(cache=cache)
+                for value in rrulevals:
+                    rset.rrule(self._parse_rfc_rrule(value, dtstart=dtstart,
+                                                     ignoretz=ignoretz,
+                                                     tzinfos=tzinfos))
+                for value in rdatevals:
+                    for datestr in value.split(','):
+                        rset.rdate(parser.parse(datestr,
+                                                ignoretz=ignoretz,
+                                                tzinfos=tzinfos))
+                for value in exrulevals:
+                    rset.exrule(self._parse_rfc_rrule(value, dtstart=dtstart,
+                                                      ignoretz=ignoretz,
+                                                      tzinfos=tzinfos))
+                for value in exdatevals:
+                    rset.exdate(value)
+                if compatible and dtstart:
+                    rset.rdate(dtstart)
+                return rset
+            else:
+                return self._parse_rfc_rrule(rrulevals[0],
+                                             dtstart=dtstart,
+                                             cache=cache,
+                                             ignoretz=ignoretz,
+                                             tzinfos=tzinfos)
+
+    def __call__(self, s, **kwargs):
+        return self._parse_rfc(s, **kwargs)
+
+
+rrulestr = _rrulestr()
+
+# vim:ts=4:sw=4:et
diff --git a/dateutil/tz/__init__.py b/dateutil/tz/__init__.py
new file mode 100644
index 0000000..af1352c
--- /dev/null
+++ b/dateutil/tz/__init__.py
@@ -0,0 +1,12 @@
+# -*- coding: utf-8 -*-
+from .tz import *
+from .tz import __doc__
+
+__all__ = ["tzutc", "tzoffset", "tzlocal", "tzfile", "tzrange",
+           "tzstr", "tzical", "tzwin", "tzwinlocal", "gettz",
+           "enfold", "datetime_ambiguous", "datetime_exists",
+           "resolve_imaginary", "UTC", "DeprecatedTzFormatWarning"]
+
+
+class DeprecatedTzFormatWarning(Warning):
+    """Warning raised when time zones are parsed from deprecated formats."""
diff --git a/dateutil/tz/__pycache__/__init__.cpython-312.pyc b/dateutil/tz/__pycache__/__init__.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..eaf62da083b5a517e445f3bd5fde538e1ef6f0f5
GIT binary patch
literal 707
zcmX|9KX2496t|Py<#cUDi;z%ZAdEq3%T!LNLV`QNQaW7)iXvI=*~wWraj>1X$;8m_
z&=s*E#5dp@@C__6!NP_(SUO?nj=tgf_uljS_p`rlYz%>wg&1dFAOPQ;@n3o?uoziz
z2?!vNgU=px$m5`Z34|aA#Qy*j&jT+22`&KXQU8;_%uIr&ABR6}T@XV9A6OM4M8piC
zc+>QBTkDw_=vHKzqS}PI<zj}p>FYLQoH~cZWlr5yrKR&T7q{jaE6uPwmMOiQYTcSX
zEi=K1xk<35niUk`;)Lb3sFk^K?W5;RX=Sz~Rf3;V#0s3V63fQ;$J4Rdp3q9tnXN#k
z?Q<autY2YSvNE5o80ikTmXpP%RhNK*1QL*V1SWpt#lE~{-R-kgW+X9FltgE9T1IZL
zs1+qu5tcNnuymnJiXtM{t)r~#tagv$zzh&7vE2rlAwq>9HFtO&p|>^W%ZLnYzmH&H
zHMn{`ew-dFDpiV`TFuj^RW-pHr-zQ;bV`dVtys0Av9!GHoIl!sI2u)NQqE4&s?l>%
zrjD#yGrp(WJ%m`vG(x*o({0tMHQPtIFLD7)a47Fs)cKF%p7HF%xpCZcW6tfU;fjZ4
z{<gc^W!$ysYH+Yz>505&O~<RcZ`Cg!Lihu0eFL|D2maawz6<}XL--QD5B~ypb|wA+
DYNXQH

literal 0
HcmV?d00001

diff --git a/dateutil/tz/__pycache__/_common.cpython-312.pyc b/dateutil/tz/__pycache__/_common.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..dd3025d30f817634f274a6451c7d2aa22423ba3a
GIT binary patch
literal 14160
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

literal 0
HcmV?d00001

diff --git a/dateutil/tz/__pycache__/_factories.cpython-312.pyc b/dateutil/tz/__pycache__/_factories.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..b6fee43f63f90c0e1e7fbd6406a07ee45514c5d4
GIT binary patch
literal 4593
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
F{|2qMq7DE6

literal 0
HcmV?d00001

diff --git a/dateutil/tz/__pycache__/tz.cpython-312.pyc b/dateutil/tz/__pycache__/tz.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..f01a7530506c74148d7f83ecd73e7a13e759589f
GIT binary patch
literal 66026
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
Yu31dIIofO4Jcaowy>;4aP9EX^00*lV&j0`b

literal 0
HcmV?d00001

diff --git a/dateutil/tz/__pycache__/win.cpython-312.pyc b/dateutil/tz/__pycache__/win.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..ca4ed1769f99fd30f685985047fa8561ae3fa03a
GIT binary patch
literal 17263
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

literal 0
HcmV?d00001

diff --git a/dateutil/tz/_common.py b/dateutil/tz/_common.py
new file mode 100644
index 0000000..e6ac118
--- /dev/null
+++ b/dateutil/tz/_common.py
@@ -0,0 +1,419 @@
+from six import PY2
+
+from functools import wraps
+
+from datetime import datetime, timedelta, tzinfo
+
+
+ZERO = timedelta(0)
+
+__all__ = ['tzname_in_python2', 'enfold']
+
+
+def tzname_in_python2(namefunc):
+    """Change unicode output into bytestrings in Python 2
+
+    tzname() API changed in Python 3. It used to return bytes, but was changed
+    to unicode strings
+    """
+    if PY2:
+        @wraps(namefunc)
+        def adjust_encoding(*args, **kwargs):
+            name = namefunc(*args, **kwargs)
+            if name is not None:
+                name = name.encode()
+
+            return name
+
+        return adjust_encoding
+    else:
+        return namefunc
+
+
+# The following is adapted from Alexander Belopolsky's tz library
+# https://github.com/abalkin/tz
+if hasattr(datetime, 'fold'):
+    # This is the pre-python 3.6 fold situation
+    def enfold(dt, fold=1):
+        """
+        Provides a unified interface for assigning the ``fold`` attribute to
+        datetimes both before and after the implementation of PEP-495.
+
+        :param fold:
+            The value for the ``fold`` attribute in the returned datetime. This
+            should be either 0 or 1.
+
+        :return:
+            Returns an object for which ``getattr(dt, 'fold', 0)`` returns
+            ``fold`` for all versions of Python. In versions prior to
+            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a
+            subclass of :py:class:`datetime.datetime` with the ``fold``
+            attribute added, if ``fold`` is 1.
+
+        .. versionadded:: 2.6.0
+        """
+        return dt.replace(fold=fold)
+
+else:
+    class _DatetimeWithFold(datetime):
+        """
+        This is a class designed to provide a PEP 495-compliant interface for
+        Python versions before 3.6. It is used only for dates in a fold, so
+        the ``fold`` attribute is fixed at ``1``.
+
+        .. versionadded:: 2.6.0
+        """
+        __slots__ = ()
+
+        def replace(self, *args, **kwargs):
+            """
+            Return a datetime with the same attributes, except for those
+            attributes given new values by whichever keyword arguments are
+            specified. Note that tzinfo=None can be specified to create a naive
+            datetime from an aware datetime with no conversion of date and time
+            data.
+
+            This is reimplemented in ``_DatetimeWithFold`` because pypy3 will
+            return a ``datetime.datetime`` even if ``fold`` is unchanged.
+            """
+            argnames = (
+                'year', 'month', 'day', 'hour', 'minute', 'second',
+                'microsecond', 'tzinfo'
+            )
+
+            for arg, argname in zip(args, argnames):
+                if argname in kwargs:
+                    raise TypeError('Duplicate argument: {}'.format(argname))
+
+                kwargs[argname] = arg
+
+            for argname in argnames:
+                if argname not in kwargs:
+                    kwargs[argname] = getattr(self, argname)
+
+            dt_class = self.__class__ if kwargs.get('fold', 1) else datetime
+
+            return dt_class(**kwargs)
+
+        @property
+        def fold(self):
+            return 1
+
+    def enfold(dt, fold=1):
+        """
+        Provides a unified interface for assigning the ``fold`` attribute to
+        datetimes both before and after the implementation of PEP-495.
+
+        :param fold:
+            The value for the ``fold`` attribute in the returned datetime. This
+            should be either 0 or 1.
+
+        :return:
+            Returns an object for which ``getattr(dt, 'fold', 0)`` returns
+            ``fold`` for all versions of Python. In versions prior to
+            Python 3.6, this is a ``_DatetimeWithFold`` object, which is a
+            subclass of :py:class:`datetime.datetime` with the ``fold``
+            attribute added, if ``fold`` is 1.
+
+        .. versionadded:: 2.6.0
+        """
+        if getattr(dt, 'fold', 0) == fold:
+            return dt
+
+        args = dt.timetuple()[:6]
+        args += (dt.microsecond, dt.tzinfo)
+
+        if fold:
+            return _DatetimeWithFold(*args)
+        else:
+            return datetime(*args)
+
+
+def _validate_fromutc_inputs(f):
+    """
+    The CPython version of ``fromutc`` checks that the input is a ``datetime``
+    object and that ``self`` is attached as its ``tzinfo``.
+    """
+    @wraps(f)
+    def fromutc(self, dt):
+        if not isinstance(dt, datetime):
+            raise TypeError("fromutc() requires a datetime argument")
+        if dt.tzinfo is not self:
+            raise ValueError("dt.tzinfo is not self")
+
+        return f(self, dt)
+
+    return fromutc
+
+
+class _tzinfo(tzinfo):
+    """
+    Base class for all ``dateutil`` ``tzinfo`` objects.
+    """
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+
+        dt = dt.replace(tzinfo=self)
+
+        wall_0 = enfold(dt, fold=0)
+        wall_1 = enfold(dt, fold=1)
+
+        same_offset = wall_0.utcoffset() == wall_1.utcoffset()
+        same_dt = wall_0.replace(tzinfo=None) == wall_1.replace(tzinfo=None)
+
+        return same_dt and not same_offset
+
+    def _fold_status(self, dt_utc, dt_wall):
+        """
+        Determine the fold status of a "wall" datetime, given a representation
+        of the same datetime as a (naive) UTC datetime. This is calculated based
+        on the assumption that ``dt.utcoffset() - dt.dst()`` is constant for all
+        datetimes, and that this offset is the actual number of hours separating
+        ``dt_utc`` and ``dt_wall``.
+
+        :param dt_utc:
+            Representation of the datetime as UTC
+
+        :param dt_wall:
+            Representation of the datetime as "wall time". This parameter must
+            either have a `fold` attribute or have a fold-naive
+            :class:`datetime.tzinfo` attached, otherwise the calculation may
+            fail.
+        """
+        if self.is_ambiguous(dt_wall):
+            delta_wall = dt_wall - dt_utc
+            _fold = int(delta_wall == (dt_utc.utcoffset() - dt_utc.dst()))
+        else:
+            _fold = 0
+
+        return _fold
+
+    def _fold(self, dt):
+        return getattr(dt, 'fold', 0)
+
+    def _fromutc(self, dt):
+        """
+        Given a timezone-aware datetime in a given timezone, calculates a
+        timezone-aware datetime in a new timezone.
+
+        Since this is the one time that we *know* we have an unambiguous
+        datetime object, we take this opportunity to determine whether the
+        datetime is ambiguous and in a "fold" state (e.g. if it's the first
+        occurrence, chronologically, of the ambiguous datetime).
+
+        :param dt:
+            A timezone-aware :class:`datetime.datetime` object.
+        """
+
+        # Re-implement the algorithm from Python's datetime.py
+        dtoff = dt.utcoffset()
+        if dtoff is None:
+            raise ValueError("fromutc() requires a non-None utcoffset() "
+                             "result")
+
+        # The original datetime.py code assumes that `dst()` defaults to
+        # zero during ambiguous times. PEP 495 inverts this presumption, so
+        # for pre-PEP 495 versions of python, we need to tweak the algorithm.
+        dtdst = dt.dst()
+        if dtdst is None:
+            raise ValueError("fromutc() requires a non-None dst() result")
+        delta = dtoff - dtdst
+
+        dt += delta
+        # Set fold=1 so we can default to being in the fold for
+        # ambiguous dates.
+        dtdst = enfold(dt, fold=1).dst()
+        if dtdst is None:
+            raise ValueError("fromutc(): dt.dst gave inconsistent "
+                             "results; cannot convert")
+        return dt + dtdst
+
+    @_validate_fromutc_inputs
+    def fromutc(self, dt):
+        """
+        Given a timezone-aware datetime in a given timezone, calculates a
+        timezone-aware datetime in a new timezone.
+
+        Since this is the one time that we *know* we have an unambiguous
+        datetime object, we take this opportunity to determine whether the
+        datetime is ambiguous and in a "fold" state (e.g. if it's the first
+        occurrence, chronologically, of the ambiguous datetime).
+
+        :param dt:
+            A timezone-aware :class:`datetime.datetime` object.
+        """
+        dt_wall = self._fromutc(dt)
+
+        # Calculate the fold status given the two datetimes.
+        _fold = self._fold_status(dt, dt_wall)
+
+        # Set the default fold value for ambiguous dates
+        return enfold(dt_wall, fold=_fold)
+
+
+class tzrangebase(_tzinfo):
+    """
+    This is an abstract base class for time zones represented by an annual
+    transition into and out of DST. Child classes should implement the following
+    methods:
+
+        * ``__init__(self, *args, **kwargs)``
+        * ``transitions(self, year)`` - this is expected to return a tuple of
+          datetimes representing the DST on and off transitions in standard
+          time.
+
+    A fully initialized ``tzrangebase`` subclass should also provide the
+    following attributes:
+        * ``hasdst``: Boolean whether or not the zone uses DST.
+        * ``_dst_offset`` / ``_std_offset``: :class:`datetime.timedelta` objects
+          representing the respective UTC offsets.
+        * ``_dst_abbr`` / ``_std_abbr``: Strings representing the timezone short
+          abbreviations in DST and STD, respectively.
+        * ``_hasdst``: Whether or not the zone has DST.
+
+    .. versionadded:: 2.6.0
+    """
+    def __init__(self):
+        raise NotImplementedError('tzrangebase is an abstract base class')
+
+    def utcoffset(self, dt):
+        isdst = self._isdst(dt)
+
+        if isdst is None:
+            return None
+        elif isdst:
+            return self._dst_offset
+        else:
+            return self._std_offset
+
+    def dst(self, dt):
+        isdst = self._isdst(dt)
+
+        if isdst is None:
+            return None
+        elif isdst:
+            return self._dst_base_offset
+        else:
+            return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        if self._isdst(dt):
+            return self._dst_abbr
+        else:
+            return self._std_abbr
+
+    def fromutc(self, dt):
+        """ Given a datetime in UTC, return local time """
+        if not isinstance(dt, datetime):
+            raise TypeError("fromutc() requires a datetime argument")
+
+        if dt.tzinfo is not self:
+            raise ValueError("dt.tzinfo is not self")
+
+        # Get transitions - if there are none, fixed offset
+        transitions = self.transitions(dt.year)
+        if transitions is None:
+            return dt + self.utcoffset(dt)
+
+        # Get the transition times in UTC
+        dston, dstoff = transitions
+
+        dston -= self._std_offset
+        dstoff -= self._std_offset
+
+        utc_transitions = (dston, dstoff)
+        dt_utc = dt.replace(tzinfo=None)
+
+        isdst = self._naive_isdst(dt_utc, utc_transitions)
+
+        if isdst:
+            dt_wall = dt + self._dst_offset
+        else:
+            dt_wall = dt + self._std_offset
+
+        _fold = int(not isdst and self.is_ambiguous(dt_wall))
+
+        return enfold(dt_wall, fold=_fold)
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        if not self.hasdst:
+            return False
+
+        start, end = self.transitions(dt.year)
+
+        dt = dt.replace(tzinfo=None)
+        return (end <= dt < end + self._dst_base_offset)
+
+    def _isdst(self, dt):
+        if not self.hasdst:
+            return False
+        elif dt is None:
+            return None
+
+        transitions = self.transitions(dt.year)
+
+        if transitions is None:
+            return False
+
+        dt = dt.replace(tzinfo=None)
+
+        isdst = self._naive_isdst(dt, transitions)
+
+        # Handle ambiguous dates
+        if not isdst and self.is_ambiguous(dt):
+            return not self._fold(dt)
+        else:
+            return isdst
+
+    def _naive_isdst(self, dt, transitions):
+        dston, dstoff = transitions
+
+        dt = dt.replace(tzinfo=None)
+
+        if dston < dstoff:
+            isdst = dston <= dt < dstoff
+        else:
+            isdst = not dstoff <= dt < dston
+
+        return isdst
+
+    @property
+    def _dst_base_offset(self):
+        return self._dst_offset - self._std_offset
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s(...)" % self.__class__.__name__
+
+    __reduce__ = object.__reduce__
diff --git a/dateutil/tz/_factories.py b/dateutil/tz/_factories.py
new file mode 100644
index 0000000..f8a6589
--- /dev/null
+++ b/dateutil/tz/_factories.py
@@ -0,0 +1,80 @@
+from datetime import timedelta
+import weakref
+from collections import OrderedDict
+
+from six.moves import _thread
+
+
+class _TzSingleton(type):
+    def __init__(cls, *args, **kwargs):
+        cls.__instance = None
+        super(_TzSingleton, cls).__init__(*args, **kwargs)
+
+    def __call__(cls):
+        if cls.__instance is None:
+            cls.__instance = super(_TzSingleton, cls).__call__()
+        return cls.__instance
+
+
+class _TzFactory(type):
+    def instance(cls, *args, **kwargs):
+        """Alternate constructor that returns a fresh instance"""
+        return type.__call__(cls, *args, **kwargs)
+
+
+class _TzOffsetFactory(_TzFactory):
+    def __init__(cls, *args, **kwargs):
+        cls.__instances = weakref.WeakValueDictionary()
+        cls.__strong_cache = OrderedDict()
+        cls.__strong_cache_size = 8
+
+        cls._cache_lock = _thread.allocate_lock()
+
+    def __call__(cls, name, offset):
+        if isinstance(offset, timedelta):
+            key = (name, offset.total_seconds())
+        else:
+            key = (name, offset)
+
+        instance = cls.__instances.get(key, None)
+        if instance is None:
+            instance = cls.__instances.setdefault(key,
+                                                  cls.instance(name, offset))
+
+        # This lock may not be necessary in Python 3. See GH issue #901
+        with cls._cache_lock:
+            cls.__strong_cache[key] = cls.__strong_cache.pop(key, instance)
+
+            # Remove an item if the strong cache is overpopulated
+            if len(cls.__strong_cache) > cls.__strong_cache_size:
+                cls.__strong_cache.popitem(last=False)
+
+        return instance
+
+
+class _TzStrFactory(_TzFactory):
+    def __init__(cls, *args, **kwargs):
+        cls.__instances = weakref.WeakValueDictionary()
+        cls.__strong_cache = OrderedDict()
+        cls.__strong_cache_size = 8
+
+        cls.__cache_lock = _thread.allocate_lock()
+
+    def __call__(cls, s, posix_offset=False):
+        key = (s, posix_offset)
+        instance = cls.__instances.get(key, None)
+
+        if instance is None:
+            instance = cls.__instances.setdefault(key,
+                cls.instance(s, posix_offset))
+
+        # This lock may not be necessary in Python 3. See GH issue #901
+        with cls.__cache_lock:
+            cls.__strong_cache[key] = cls.__strong_cache.pop(key, instance)
+
+            # Remove an item if the strong cache is overpopulated
+            if len(cls.__strong_cache) > cls.__strong_cache_size:
+                cls.__strong_cache.popitem(last=False)
+
+        return instance
+
diff --git a/dateutil/tz/tz.py b/dateutil/tz/tz.py
new file mode 100644
index 0000000..c67f56d
--- /dev/null
+++ b/dateutil/tz/tz.py
@@ -0,0 +1,1849 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers timezone implementations subclassing the abstract
+:py:class:`datetime.tzinfo` type. There are classes to handle tzfile format
+files (usually are in :file:`/etc/localtime`, :file:`/usr/share/zoneinfo`,
+etc), TZ environment string (in all known formats), given ranges (with help
+from relative deltas), local machine timezone, fixed offset timezone, and UTC
+timezone.
+"""
+import datetime
+import struct
+import time
+import sys
+import os
+import bisect
+import weakref
+from collections import OrderedDict
+
+import six
+from six import string_types
+from six.moves import _thread
+from ._common import tzname_in_python2, _tzinfo
+from ._common import tzrangebase, enfold
+from ._common import _validate_fromutc_inputs
+
+from ._factories import _TzSingleton, _TzOffsetFactory
+from ._factories import _TzStrFactory
+try:
+    from .win import tzwin, tzwinlocal
+except ImportError:
+    tzwin = tzwinlocal = None
+
+# For warning about rounding tzinfo
+from warnings import warn
+
+ZERO = datetime.timedelta(0)
+EPOCH = datetime.datetime.utcfromtimestamp(0)
+EPOCHORDINAL = EPOCH.toordinal()
+
+
+@six.add_metaclass(_TzSingleton)
+class tzutc(datetime.tzinfo):
+    """
+    This is a tzinfo object that represents the UTC time zone.
+
+    **Examples:**
+
+    .. doctest::
+
+        >>> from datetime import *
+        >>> from dateutil.tz import *
+
+        >>> datetime.now()
+        datetime.datetime(2003, 9, 27, 9, 40, 1, 521290)
+
+        >>> datetime.now(tzutc())
+        datetime.datetime(2003, 9, 27, 12, 40, 12, 156379, tzinfo=tzutc())
+
+        >>> datetime.now(tzutc()).tzname()
+        'UTC'
+
+    .. versionchanged:: 2.7.0
+        ``tzutc()`` is now a singleton, so the result of ``tzutc()`` will
+        always return the same object.
+
+        .. doctest::
+
+            >>> from dateutil.tz import tzutc, UTC
+            >>> tzutc() is tzutc()
+            True
+            >>> tzutc() is UTC
+            True
+    """
+    def utcoffset(self, dt):
+        return ZERO
+
+    def dst(self, dt):
+        return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        return "UTC"
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        return False
+
+    @_validate_fromutc_inputs
+    def fromutc(self, dt):
+        """
+        Fast track version of fromutc() returns the original ``dt`` object for
+        any valid :py:class:`datetime.datetime` object.
+        """
+        return dt
+
+    def __eq__(self, other):
+        if not isinstance(other, (tzutc, tzoffset)):
+            return NotImplemented
+
+        return (isinstance(other, tzutc) or
+                (isinstance(other, tzoffset) and other._offset == ZERO))
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s()" % self.__class__.__name__
+
+    __reduce__ = object.__reduce__
+
+
+#: Convenience constant providing a :class:`tzutc()` instance
+#:
+#: .. versionadded:: 2.7.0
+UTC = tzutc()
+
+
+@six.add_metaclass(_TzOffsetFactory)
+class tzoffset(datetime.tzinfo):
+    """
+    A simple class for representing a fixed offset from UTC.
+
+    :param name:
+        The timezone name, to be returned when ``tzname()`` is called.
+    :param offset:
+        The time zone offset in seconds, or (since version 2.6.0, represented
+        as a :py:class:`datetime.timedelta` object).
+    """
+    def __init__(self, name, offset):
+        self._name = name
+
+        try:
+            # Allow a timedelta
+            offset = offset.total_seconds()
+        except (TypeError, AttributeError):
+            pass
+
+        self._offset = datetime.timedelta(seconds=_get_supported_offset(offset))
+
+    def utcoffset(self, dt):
+        return self._offset
+
+    def dst(self, dt):
+        return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        return self._name
+
+    @_validate_fromutc_inputs
+    def fromutc(self, dt):
+        return dt + self._offset
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        return False
+
+    def __eq__(self, other):
+        if not isinstance(other, tzoffset):
+            return NotImplemented
+
+        return self._offset == other._offset
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s(%s, %s)" % (self.__class__.__name__,
+                               repr(self._name),
+                               int(self._offset.total_seconds()))
+
+    __reduce__ = object.__reduce__
+
+
+class tzlocal(_tzinfo):
+    """
+    A :class:`tzinfo` subclass built around the ``time`` timezone functions.
+    """
+    def __init__(self):
+        super(tzlocal, self).__init__()
+
+        self._std_offset = datetime.timedelta(seconds=-time.timezone)
+        if time.daylight:
+            self._dst_offset = datetime.timedelta(seconds=-time.altzone)
+        else:
+            self._dst_offset = self._std_offset
+
+        self._dst_saved = self._dst_offset - self._std_offset
+        self._hasdst = bool(self._dst_saved)
+        self._tznames = tuple(time.tzname)
+
+    def utcoffset(self, dt):
+        if dt is None and self._hasdst:
+            return None
+
+        if self._isdst(dt):
+            return self._dst_offset
+        else:
+            return self._std_offset
+
+    def dst(self, dt):
+        if dt is None and self._hasdst:
+            return None
+
+        if self._isdst(dt):
+            return self._dst_offset - self._std_offset
+        else:
+            return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        return self._tznames[self._isdst(dt)]
+
+    def is_ambiguous(self, dt):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        naive_dst = self._naive_is_dst(dt)
+        return (not naive_dst and
+                (naive_dst != self._naive_is_dst(dt - self._dst_saved)))
+
+    def _naive_is_dst(self, dt):
+        timestamp = _datetime_to_timestamp(dt)
+        return time.localtime(timestamp + time.timezone).tm_isdst
+
+    def _isdst(self, dt, fold_naive=True):
+        # We can't use mktime here. It is unstable when deciding if
+        # the hour near to a change is DST or not.
+        #
+        # timestamp = time.mktime((dt.year, dt.month, dt.day, dt.hour,
+        #                         dt.minute, dt.second, dt.weekday(), 0, -1))
+        # return time.localtime(timestamp).tm_isdst
+        #
+        # The code above yields the following result:
+        #
+        # >>> import tz, datetime
+        # >>> t = tz.tzlocal()
+        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
+        # 'BRDT'
+        # >>> datetime.datetime(2003,2,16,0,tzinfo=t).tzname()
+        # 'BRST'
+        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
+        # 'BRST'
+        # >>> datetime.datetime(2003,2,15,22,tzinfo=t).tzname()
+        # 'BRDT'
+        # >>> datetime.datetime(2003,2,15,23,tzinfo=t).tzname()
+        # 'BRDT'
+        #
+        # Here is a more stable implementation:
+        #
+        if not self._hasdst:
+            return False
+
+        # Check for ambiguous times:
+        dstval = self._naive_is_dst(dt)
+        fold = getattr(dt, 'fold', None)
+
+        if self.is_ambiguous(dt):
+            if fold is not None:
+                return not self._fold(dt)
+            else:
+                return True
+
+        return dstval
+
+    def __eq__(self, other):
+        if isinstance(other, tzlocal):
+            return (self._std_offset == other._std_offset and
+                    self._dst_offset == other._dst_offset)
+        elif isinstance(other, tzutc):
+            return (not self._hasdst and
+                    self._tznames[0] in {'UTC', 'GMT'} and
+                    self._std_offset == ZERO)
+        elif isinstance(other, tzoffset):
+            return (not self._hasdst and
+                    self._tznames[0] == other._name and
+                    self._std_offset == other._offset)
+        else:
+            return NotImplemented
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s()" % self.__class__.__name__
+
+    __reduce__ = object.__reduce__
+
+
+class _ttinfo(object):
+    __slots__ = ["offset", "delta", "isdst", "abbr",
+                 "isstd", "isgmt", "dstoffset"]
+
+    def __init__(self):
+        for attr in self.__slots__:
+            setattr(self, attr, None)
+
+    def __repr__(self):
+        l = []
+        for attr in self.__slots__:
+            value = getattr(self, attr)
+            if value is not None:
+                l.append("%s=%s" % (attr, repr(value)))
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(l))
+
+    def __eq__(self, other):
+        if not isinstance(other, _ttinfo):
+            return NotImplemented
+
+        return (self.offset == other.offset and
+                self.delta == other.delta and
+                self.isdst == other.isdst and
+                self.abbr == other.abbr and
+                self.isstd == other.isstd and
+                self.isgmt == other.isgmt and
+                self.dstoffset == other.dstoffset)
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __getstate__(self):
+        state = {}
+        for name in self.__slots__:
+            state[name] = getattr(self, name, None)
+        return state
+
+    def __setstate__(self, state):
+        for name in self.__slots__:
+            if name in state:
+                setattr(self, name, state[name])
+
+
+class _tzfile(object):
+    """
+    Lightweight class for holding the relevant transition and time zone
+    information read from binary tzfiles.
+    """
+    attrs = ['trans_list', 'trans_list_utc', 'trans_idx', 'ttinfo_list',
+             'ttinfo_std', 'ttinfo_dst', 'ttinfo_before', 'ttinfo_first']
+
+    def __init__(self, **kwargs):
+        for attr in self.attrs:
+            setattr(self, attr, kwargs.get(attr, None))
+
+
+class tzfile(_tzinfo):
+    """
+    This is a ``tzinfo`` subclass that allows one to use the ``tzfile(5)``
+    format timezone files to extract current and historical zone information.
+
+    :param fileobj:
+        This can be an opened file stream or a file name that the time zone
+        information can be read from.
+
+    :param filename:
+        This is an optional parameter specifying the source of the time zone
+        information in the event that ``fileobj`` is a file object. If omitted
+        and ``fileobj`` is a file stream, this parameter will be set either to
+        ``fileobj``'s ``name`` attribute or to ``repr(fileobj)``.
+
+    See `Sources for Time Zone and Daylight Saving Time Data
+    <https://data.iana.org/time-zones/tz-link.html>`_ for more information.
+    Time zone files can be compiled from the `IANA Time Zone database files
+    <https://www.iana.org/time-zones>`_ with the `zic time zone compiler
+    <https://www.freebsd.org/cgi/man.cgi?query=zic&sektion=8>`_
+
+    .. note::
+
+        Only construct a ``tzfile`` directly if you have a specific timezone
+        file on disk that you want to read into a Python ``tzinfo`` object.
+        If you want to get a ``tzfile`` representing a specific IANA zone,
+        (e.g. ``'America/New_York'``), you should call
+        :func:`dateutil.tz.gettz` with the zone identifier.
+
+
+    **Examples:**
+
+    Using the US Eastern time zone as an example, we can see that a ``tzfile``
+    provides time zone information for the standard Daylight Saving offsets:
+
+    .. testsetup:: tzfile
+
+        from dateutil.tz import gettz
+        from datetime import datetime
+
+    .. doctest:: tzfile
+
+        >>> NYC = gettz('America/New_York')
+        >>> NYC
+        tzfile('/usr/share/zoneinfo/America/New_York')
+
+        >>> print(datetime(2016, 1, 3, tzinfo=NYC))     # EST
+        2016-01-03 00:00:00-05:00
+
+        >>> print(datetime(2016, 7, 7, tzinfo=NYC))     # EDT
+        2016-07-07 00:00:00-04:00
+
+
+    The ``tzfile`` structure contains a fully history of the time zone,
+    so historical dates will also have the right offsets. For example, before
+    the adoption of the UTC standards, New York used local solar  mean time:
+
+    .. doctest:: tzfile
+
+       >>> print(datetime(1901, 4, 12, tzinfo=NYC))    # LMT
+       1901-04-12 00:00:00-04:56
+
+    And during World War II, New York was on "Eastern War Time", which was a
+    state of permanent daylight saving time:
+
+    .. doctest:: tzfile
+
+        >>> print(datetime(1944, 2, 7, tzinfo=NYC))    # EWT
+        1944-02-07 00:00:00-04:00
+
+    """
+
+    def __init__(self, fileobj, filename=None):
+        super(tzfile, self).__init__()
+
+        file_opened_here = False
+        if isinstance(fileobj, string_types):
+            self._filename = fileobj
+            fileobj = open(fileobj, 'rb')
+            file_opened_here = True
+        elif filename is not None:
+            self._filename = filename
+        elif hasattr(fileobj, "name"):
+            self._filename = fileobj.name
+        else:
+            self._filename = repr(fileobj)
+
+        if fileobj is not None:
+            if not file_opened_here:
+                fileobj = _nullcontext(fileobj)
+
+            with fileobj as file_stream:
+                tzobj = self._read_tzfile(file_stream)
+
+            self._set_tzdata(tzobj)
+
+    def _set_tzdata(self, tzobj):
+        """ Set the time zone data of this object from a _tzfile object """
+        # Copy the relevant attributes over as private attributes
+        for attr in _tzfile.attrs:
+            setattr(self, '_' + attr, getattr(tzobj, attr))
+
+    def _read_tzfile(self, fileobj):
+        out = _tzfile()
+
+        # From tzfile(5):
+        #
+        # The time zone information files used by tzset(3)
+        # begin with the magic characters "TZif" to identify
+        # them as time zone information files, followed by
+        # sixteen bytes reserved for future use, followed by
+        # six four-byte values of type long, written in a
+        # ``standard'' byte order (the high-order  byte
+        # of the value is written first).
+        if fileobj.read(4).decode() != "TZif":
+            raise ValueError("magic not found")
+
+        fileobj.read(16)
+
+        (
+            # The number of UTC/local indicators stored in the file.
+            ttisgmtcnt,
+
+            # The number of standard/wall indicators stored in the file.
+            ttisstdcnt,
+
+            # The number of leap seconds for which data is
+            # stored in the file.
+            leapcnt,
+
+            # The number of "transition times" for which data
+            # is stored in the file.
+            timecnt,
+
+            # The number of "local time types" for which data
+            # is stored in the file (must not be zero).
+            typecnt,
+
+            # The  number  of  characters  of "time zone
+            # abbreviation strings" stored in the file.
+            charcnt,
+
+        ) = struct.unpack(">6l", fileobj.read(24))
+
+        # The above header is followed by tzh_timecnt four-byte
+        # values  of  type long,  sorted  in ascending order.
+        # These values are written in ``standard'' byte order.
+        # Each is used as a transition time (as  returned  by
+        # time(2)) at which the rules for computing local time
+        # change.
+
+        if timecnt:
+            out.trans_list_utc = list(struct.unpack(">%dl" % timecnt,
+                                                    fileobj.read(timecnt*4)))
+        else:
+            out.trans_list_utc = []
+
+        # Next come tzh_timecnt one-byte values of type unsigned
+        # char; each one tells which of the different types of
+        # ``local time'' types described in the file is associated
+        # with the same-indexed transition time. These values
+        # serve as indices into an array of ttinfo structures that
+        # appears next in the file.
+
+        if timecnt:
+            out.trans_idx = struct.unpack(">%dB" % timecnt,
+                                          fileobj.read(timecnt))
+        else:
+            out.trans_idx = []
+
+        # Each ttinfo structure is written as a four-byte value
+        # for tt_gmtoff  of  type long,  in  a  standard  byte
+        # order, followed  by a one-byte value for tt_isdst
+        # and a one-byte  value  for  tt_abbrind.   In  each
+        # structure, tt_gmtoff  gives  the  number  of
+        # seconds to be added to UTC, tt_isdst tells whether
+        # tm_isdst should be set by  localtime(3),  and
+        # tt_abbrind serves  as an index into the array of
+        # time zone abbreviation characters that follow the
+        # ttinfo structure(s) in the file.
+
+        ttinfo = []
+
+        for i in range(typecnt):
+            ttinfo.append(struct.unpack(">lbb", fileobj.read(6)))
+
+        abbr = fileobj.read(charcnt).decode()
+
+        # Then there are tzh_leapcnt pairs of four-byte
+        # values, written in  standard byte  order;  the
+        # first  value  of  each pair gives the time (as
+        # returned by time(2)) at which a leap second
+        # occurs;  the  second  gives the  total  number of
+        # leap seconds to be applied after the given time.
+        # The pairs of values are sorted in ascending order
+        # by time.
+
+        # Not used, for now (but seek for correct file position)
+        if leapcnt:
+            fileobj.seek(leapcnt * 8, os.SEEK_CUR)
+
+        # Then there are tzh_ttisstdcnt standard/wall
+        # indicators, each stored as a one-byte value;
+        # they tell whether the transition times associated
+        # with local time types were specified as standard
+        # time or wall clock time, and are used when
+        # a time zone file is used in handling POSIX-style
+        # time zone environment variables.
+
+        if ttisstdcnt:
+            isstd = struct.unpack(">%db" % ttisstdcnt,
+                                  fileobj.read(ttisstdcnt))
+
+        # Finally, there are tzh_ttisgmtcnt UTC/local
+        # indicators, each stored as a one-byte value;
+        # they tell whether the transition times associated
+        # with local time types were specified as UTC or
+        # local time, and are used when a time zone file
+        # is used in handling POSIX-style time zone envi-
+        # ronment variables.
+
+        if ttisgmtcnt:
+            isgmt = struct.unpack(">%db" % ttisgmtcnt,
+                                  fileobj.read(ttisgmtcnt))
+
+        # Build ttinfo list
+        out.ttinfo_list = []
+        for i in range(typecnt):
+            gmtoff, isdst, abbrind = ttinfo[i]
+            gmtoff = _get_supported_offset(gmtoff)
+            tti = _ttinfo()
+            tti.offset = gmtoff
+            tti.dstoffset = datetime.timedelta(0)
+            tti.delta = datetime.timedelta(seconds=gmtoff)
+            tti.isdst = isdst
+            tti.abbr = abbr[abbrind:abbr.find('\x00', abbrind)]
+            tti.isstd = (ttisstdcnt > i and isstd[i] != 0)
+            tti.isgmt = (ttisgmtcnt > i and isgmt[i] != 0)
+            out.ttinfo_list.append(tti)
+
+        # Replace ttinfo indexes for ttinfo objects.
+        out.trans_idx = [out.ttinfo_list[idx] for idx in out.trans_idx]
+
+        # Set standard, dst, and before ttinfos. before will be
+        # used when a given time is before any transitions,
+        # and will be set to the first non-dst ttinfo, or to
+        # the first dst, if all of them are dst.
+        out.ttinfo_std = None
+        out.ttinfo_dst = None
+        out.ttinfo_before = None
+        if out.ttinfo_list:
+            if not out.trans_list_utc:
+                out.ttinfo_std = out.ttinfo_first = out.ttinfo_list[0]
+            else:
+                for i in range(timecnt-1, -1, -1):
+                    tti = out.trans_idx[i]
+                    if not out.ttinfo_std and not tti.isdst:
+                        out.ttinfo_std = tti
+                    elif not out.ttinfo_dst and tti.isdst:
+                        out.ttinfo_dst = tti
+
+                    if out.ttinfo_std and out.ttinfo_dst:
+                        break
+                else:
+                    if out.ttinfo_dst and not out.ttinfo_std:
+                        out.ttinfo_std = out.ttinfo_dst
+
+                for tti in out.ttinfo_list:
+                    if not tti.isdst:
+                        out.ttinfo_before = tti
+                        break
+                else:
+                    out.ttinfo_before = out.ttinfo_list[0]
+
+        # Now fix transition times to become relative to wall time.
+        #
+        # I'm not sure about this. In my tests, the tz source file
+        # is setup to wall time, and in the binary file isstd and
+        # isgmt are off, so it should be in wall time. OTOH, it's
+        # always in gmt time. Let me know if you have comments
+        # about this.
+        lastdst = None
+        lastoffset = None
+        lastdstoffset = None
+        lastbaseoffset = None
+        out.trans_list = []
+
+        for i, tti in enumerate(out.trans_idx):
+            offset = tti.offset
+            dstoffset = 0
+
+            if lastdst is not None:
+                if tti.isdst:
+                    if not lastdst:
+                        dstoffset = offset - lastoffset
+
+                    if not dstoffset and lastdstoffset:
+                        dstoffset = lastdstoffset
+
+                    tti.dstoffset = datetime.timedelta(seconds=dstoffset)
+                    lastdstoffset = dstoffset
+
+            # If a time zone changes its base offset during a DST transition,
+            # then you need to adjust by the previous base offset to get the
+            # transition time in local time. Otherwise you use the current
+            # base offset. Ideally, I would have some mathematical proof of
+            # why this is true, but I haven't really thought about it enough.
+            baseoffset = offset - dstoffset
+            adjustment = baseoffset
+            if (lastbaseoffset is not None and baseoffset != lastbaseoffset
+                    and tti.isdst != lastdst):
+                # The base DST has changed
+                adjustment = lastbaseoffset
+
+            lastdst = tti.isdst
+            lastoffset = offset
+            lastbaseoffset = baseoffset
+
+            out.trans_list.append(out.trans_list_utc[i] + adjustment)
+
+        out.trans_idx = tuple(out.trans_idx)
+        out.trans_list = tuple(out.trans_list)
+        out.trans_list_utc = tuple(out.trans_list_utc)
+
+        return out
+
+    def _find_last_transition(self, dt, in_utc=False):
+        # If there's no list, there are no transitions to find
+        if not self._trans_list:
+            return None
+
+        timestamp = _datetime_to_timestamp(dt)
+
+        # Find where the timestamp fits in the transition list - if the
+        # timestamp is a transition time, it's part of the "after" period.
+        trans_list = self._trans_list_utc if in_utc else self._trans_list
+        idx = bisect.bisect_right(trans_list, timestamp)
+
+        # We want to know when the previous transition was, so subtract off 1
+        return idx - 1
+
+    def _get_ttinfo(self, idx):
+        # For no list or after the last transition, default to _ttinfo_std
+        if idx is None or (idx + 1) >= len(self._trans_list):
+            return self._ttinfo_std
+
+        # If there is a list and the time is before it, return _ttinfo_before
+        if idx < 0:
+            return self._ttinfo_before
+
+        return self._trans_idx[idx]
+
+    def _find_ttinfo(self, dt):
+        idx = self._resolve_ambiguous_time(dt)
+
+        return self._get_ttinfo(idx)
+
+    def fromutc(self, dt):
+        """
+        The ``tzfile`` implementation of :py:func:`datetime.tzinfo.fromutc`.
+
+        :param dt:
+            A :py:class:`datetime.datetime` object.
+
+        :raises TypeError:
+            Raised if ``dt`` is not a :py:class:`datetime.datetime` object.
+
+        :raises ValueError:
+            Raised if this is called with a ``dt`` which does not have this
+            ``tzinfo`` attached.
+
+        :return:
+            Returns a :py:class:`datetime.datetime` object representing the
+            wall time in ``self``'s time zone.
+        """
+        # These isinstance checks are in datetime.tzinfo, so we'll preserve
+        # them, even if we don't care about duck typing.
+        if not isinstance(dt, datetime.datetime):
+            raise TypeError("fromutc() requires a datetime argument")
+
+        if dt.tzinfo is not self:
+            raise ValueError("dt.tzinfo is not self")
+
+        # First treat UTC as wall time and get the transition we're in.
+        idx = self._find_last_transition(dt, in_utc=True)
+        tti = self._get_ttinfo(idx)
+
+        dt_out = dt + datetime.timedelta(seconds=tti.offset)
+
+        fold = self.is_ambiguous(dt_out, idx=idx)
+
+        return enfold(dt_out, fold=int(fold))
+
+    def is_ambiguous(self, dt, idx=None):
+        """
+        Whether or not the "wall time" of a given datetime is ambiguous in this
+        zone.
+
+        :param dt:
+            A :py:class:`datetime.datetime`, naive or time zone aware.
+
+
+        :return:
+            Returns ``True`` if ambiguous, ``False`` otherwise.
+
+        .. versionadded:: 2.6.0
+        """
+        if idx is None:
+            idx = self._find_last_transition(dt)
+
+        # Calculate the difference in offsets from current to previous
+        timestamp = _datetime_to_timestamp(dt)
+        tti = self._get_ttinfo(idx)
+
+        if idx is None or idx <= 0:
+            return False
+
+        od = self._get_ttinfo(idx - 1).offset - tti.offset
+        tt = self._trans_list[idx]          # Transition time
+
+        return timestamp < tt + od
+
+    def _resolve_ambiguous_time(self, dt):
+        idx = self._find_last_transition(dt)
+
+        # If we have no transitions, return the index
+        _fold = self._fold(dt)
+        if idx is None or idx == 0:
+            return idx
+
+        # If it's ambiguous and we're in a fold, shift to a different index.
+        idx_offset = int(not _fold and self.is_ambiguous(dt, idx))
+
+        return idx - idx_offset
+
+    def utcoffset(self, dt):
+        if dt is None:
+            return None
+
+        if not self._ttinfo_std:
+            return ZERO
+
+        return self._find_ttinfo(dt).delta
+
+    def dst(self, dt):
+        if dt is None:
+            return None
+
+        if not self._ttinfo_dst:
+            return ZERO
+
+        tti = self._find_ttinfo(dt)
+
+        if not tti.isdst:
+            return ZERO
+
+        # The documentation says that utcoffset()-dst() must
+        # be constant for every dt.
+        return tti.dstoffset
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        if not self._ttinfo_std or dt is None:
+            return None
+        return self._find_ttinfo(dt).abbr
+
+    def __eq__(self, other):
+        if not isinstance(other, tzfile):
+            return NotImplemented
+        return (self._trans_list == other._trans_list and
+                self._trans_idx == other._trans_idx and
+                self._ttinfo_list == other._ttinfo_list)
+
+    __hash__ = None
+
+    def __ne__(self, other):
+        return not (self == other)
+
+    def __repr__(self):
+        return "%s(%s)" % (self.__class__.__name__, repr(self._filename))
+
+    def __reduce__(self):
+        return self.__reduce_ex__(None)
+
+    def __reduce_ex__(self, protocol):
+        return (self.__class__, (None, self._filename), self.__dict__)
+
+
+class tzrange(tzrangebase):
+    """
+    The ``tzrange`` object is a time zone specified by a set of offsets and
+    abbreviations, equivalent to the way the ``TZ`` variable can be specified
+    in POSIX-like systems, but using Python delta objects to specify DST
+    start, end and offsets.
+
+    :param stdabbr:
+        The abbreviation for standard time (e.g. ``'EST'``).
+
+    :param stdoffset:
+        An integer or :class:`datetime.timedelta` object or equivalent
+        specifying the base offset from UTC.
+
+        If unspecified, +00:00 is used.
+
+    :param dstabbr:
+        The abbreviation for DST / "Summer" time (e.g. ``'EDT'``).
+
+        If specified, with no other DST information, DST is assumed to occur
+        and the default behavior or ``dstoffset``, ``start`` and ``end`` is
+        used. If unspecified and no other DST information is specified, it
+        is assumed that this zone has no DST.
+
+        If this is unspecified and other DST information is *is* specified,
+        DST occurs in the zone but the time zone abbreviation is left
+        unchanged.
+
+    :param dstoffset:
+        A an integer or :class:`datetime.timedelta` object or equivalent
+        specifying the UTC offset during DST. If unspecified and any other DST
+        information is specified, it is assumed to be the STD offset +1 hour.
+
+    :param start:
+        A :class:`relativedelta.relativedelta` object or equivalent specifying
+        the time and time of year that daylight savings time starts. To
+        specify, for example, that DST starts at 2AM on the 2nd Sunday in
+        March, pass:
+
+            ``relativedelta(hours=2, month=3, day=1, weekday=SU(+2))``
+
+        If unspecified and any other DST information is specified, the default
+        value is 2 AM on the first Sunday in April.
+
+    :param end:
+        A :class:`relativedelta.relativedelta` object or equivalent
+        representing the time and time of year that daylight savings time
+        ends, with the same specification method as in ``start``. One note is
+        that this should point to the first time in the *standard* zone, so if
+        a transition occurs at 2AM in the DST zone and the clocks are set back
+        1 hour to 1AM, set the ``hours`` parameter to +1.
+
+
+    **Examples:**
+
+    .. testsetup:: tzrange
+
+        from dateutil.tz import tzrange, tzstr
+
+    .. doctest:: tzrange
+
+        >>> tzstr('EST5EDT') == tzrange("EST", -18000, "EDT")
+        True
+
+        >>> from dateutil.relativedelta import *
+        >>> range1 = tzrange("EST", -18000, "EDT")
+        >>> range2 = tzrange("EST", -18000, "EDT", -14400,
+        ...                  relativedelta(hours=+2, month=4, day=1,
+        ...                                weekday=SU(+1)),
+        ...                  relativedelta(hours=+1, month=10, day=31,
+        ...                                weekday=SU(-1)))
+        >>> tzstr('EST5EDT') == range1 == range2
+        True
+
+    """
+    def __init__(self, stdabbr, stdoffset=None,
+                 dstabbr=None, dstoffset=None,
+                 start=None, end=None):
+
+        global relativedelta
+        from dateutil import relativedelta
+
+        self._std_abbr = stdabbr
+        self._dst_abbr = dstabbr
+
+        try:
+            stdoffset = stdoffset.total_seconds()
+        except (TypeError, AttributeError):
+            pass
+
+        try:
+            dstoffset = dstoffset.total_seconds()
+        except (TypeError, AttributeError):
+            pass
+
+        if stdoffset is not None:
+            self._std_offset = datetime.timedelta(seconds=stdoffset)
+        else:
+            self._std_offset = ZERO
+
+        if dstoffset is not None:
+            self._dst_offset = datetime.timedelta(seconds=dstoffset)
+        elif dstabbr and stdoffset is not None:
+            self._dst_offset = self._std_offset + datetime.timedelta(hours=+1)
+        else:
+            self._dst_offset = ZERO
+
+        if dstabbr and start is None:
+            self._start_delta = relativedelta.relativedelta(
+                hours=+2, month=4, day=1, weekday=relativedelta.SU(+1))
+        else:
+            self._start_delta = start
+
+        if dstabbr and end is None:
+            self._end_delta = relativedelta.relativedelta(
+                hours=+1, month=10, day=31, weekday=relativedelta.SU(-1))
+        else:
+            self._end_delta = end
+
+        self._dst_base_offset_ = self._dst_offset - self._std_offset
+        self.hasdst = bool(self._start_delta)
+
+    def transitions(self, year):
+        """
+        For a given year, get the DST on and off transition times, expressed
+        always on the standard time side. For zones with no transitions, this
+        function returns ``None``.
+
+        :param year:
+            The year whose transitions you would like to query.
+
+        :return:
+            Returns a :class:`tuple` of :class:`datetime.datetime` objects,
+            ``(dston, dstoff)`` for zones with an annual DST transition, or
+            ``None`` for fixed offset zones.
+        """
+        if not self.hasdst:
+            return None
+
+        base_year = datetime.datetime(year, 1, 1)
+
+        start = base_year + self._start_delta
+        end = base_year + self._end_delta
+
+        return (start, end)
+
+    def __eq__(self, other):
+        if not isinstance(other, tzrange):
+            return NotImplemented
+
+        return (self._std_abbr == other._std_abbr and
+                self._dst_abbr == other._dst_abbr and
+                self._std_offset == other._std_offset and
+                self._dst_offset == other._dst_offset and
+                self._start_delta == other._start_delta and
+                self._end_delta == other._end_delta)
+
+    @property
+    def _dst_base_offset(self):
+        return self._dst_base_offset_
+
+
+@six.add_metaclass(_TzStrFactory)
+class tzstr(tzrange):
+    """
+    ``tzstr`` objects are time zone objects specified by a time-zone string as
+    it would be passed to a ``TZ`` variable on POSIX-style systems (see
+    the `GNU C Library: TZ Variable`_ for more details).
+
+    There is one notable exception, which is that POSIX-style time zones use an
+    inverted offset format, so normally ``GMT+3`` would be parsed as an offset
+    3 hours *behind* GMT. The ``tzstr`` time zone object will parse this as an
+    offset 3 hours *ahead* of GMT. If you would like to maintain the POSIX
+    behavior, pass a ``True`` value to ``posix_offset``.
+
+    The :class:`tzrange` object provides the same functionality, but is
+    specified using :class:`relativedelta.relativedelta` objects. rather than
+    strings.
+
+    :param s:
+        A time zone string in ``TZ`` variable format. This can be a
+        :class:`bytes` (2.x: :class:`str`), :class:`str` (2.x:
+        :class:`unicode`) or a stream emitting unicode characters
+        (e.g. :class:`StringIO`).
+
+    :param posix_offset:
+        Optional. If set to ``True``, interpret strings such as ``GMT+3`` or
+        ``UTC+3`` as being 3 hours *behind* UTC rather than ahead, per the
+        POSIX standard.
+
+    .. caution::
+
+        Prior to version 2.7.0, this function also supported time zones
+        in the format:
+
+            * ``EST5EDT,4,0,6,7200,10,0,26,7200,3600``
+            * ``EST5EDT,4,1,0,7200,10,-1,0,7200,3600``
+
+        This format is non-standard and has been deprecated; this function
+        will raise a :class:`DeprecatedTZFormatWarning` until
+        support is removed in a future version.
+
+    .. _`GNU C Library: TZ Variable`:
+        https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
+    """
+    def __init__(self, s, posix_offset=False):
+        global parser
+        from dateutil.parser import _parser as parser
+
+        self._s = s
+
+        res = parser._parsetz(s)
+        if res is None or res.any_unused_tokens:
+            raise ValueError("unknown string format")
+
+        # Here we break the compatibility with the TZ variable handling.
+        # GMT-3 actually *means* the timezone -3.
+        if res.stdabbr in ("GMT", "UTC") and not posix_offset:
+            res.stdoffset *= -1
+
+        # We must initialize it first, since _delta() needs
+        # _std_offset and _dst_offset set. Use False in start/end
+        # to avoid building it two times.
+        tzrange.__init__(self, res.stdabbr, res.stdoffset,
+                         res.dstabbr, res.dstoffset,
+                         start=False, end=False)
+
+        if not res.dstabbr:
+            self._start_delta = None
+            self._end_delta = None
+        else:
+            self._start_delta = self._delta(res.start)
+            if self._start_delta:
+                self._end_delta = self._delta(res.end, isend=1)
+
+        self.hasdst = bool(self._start_delta)
+
+    def _delta(self, x, isend=0):
+        from dateutil import relativedelta
+        kwargs = {}
+        if x.month is not None:
+            kwargs["month"] = x.month
+            if x.weekday is not None:
+                kwargs["weekday"] = relativedelta.weekday(x.weekday, x.week)
+                if x.week > 0:
+                    kwargs["day"] = 1
+                else:
+                    kwargs["day"] = 31
+            elif x.day:
+                kwargs["day"] = x.day
+        elif x.yday is not None:
+            kwargs["yearday"] = x.yday
+        elif x.jyday is not None:
+            kwargs["nlyearday"] = x.jyday
+        if not kwargs:
+            # Default is to start on first sunday of april, and end
+            # on last sunday of october.
+            if not isend:
+                kwargs["month"] = 4
+                kwargs["day"] = 1
+                kwargs["weekday"] = relativedelta.SU(+1)
+            else:
+                kwargs["month"] = 10
+                kwargs["day"] = 31
+                kwargs["weekday"] = relativedelta.SU(-1)
+        if x.time is not None:
+            kwargs["seconds"] = x.time
+        else:
+            # Default is 2AM.
+            kwargs["seconds"] = 7200
+        if isend:
+            # Convert to standard time, to follow the documented way
+            # of working with the extra hour. See the documentation
+            # of the tzinfo class.
+            delta = self._dst_offset - self._std_offset
+            kwargs["seconds"] -= delta.seconds + delta.days * 86400
+        return relativedelta.relativedelta(**kwargs)
+
+    def __repr__(self):
+        return "%s(%s)" % (self.__class__.__name__, repr(self._s))
+
+
+class _tzicalvtzcomp(object):
+    def __init__(self, tzoffsetfrom, tzoffsetto, isdst,
+                 tzname=None, rrule=None):
+        self.tzoffsetfrom = datetime.timedelta(seconds=tzoffsetfrom)
+        self.tzoffsetto = datetime.timedelta(seconds=tzoffsetto)
+        self.tzoffsetdiff = self.tzoffsetto - self.tzoffsetfrom
+        self.isdst = isdst
+        self.tzname = tzname
+        self.rrule = rrule
+
+
+class _tzicalvtz(_tzinfo):
+    def __init__(self, tzid, comps=[]):
+        super(_tzicalvtz, self).__init__()
+
+        self._tzid = tzid
+        self._comps = comps
+        self._cachedate = []
+        self._cachecomp = []
+        self._cache_lock = _thread.allocate_lock()
+
+    def _find_comp(self, dt):
+        if len(self._comps) == 1:
+            return self._comps[0]
+
+        dt = dt.replace(tzinfo=None)
+
+        try:
+            with self._cache_lock:
+                return self._cachecomp[self._cachedate.index(
+                    (dt, self._fold(dt)))]
+        except ValueError:
+            pass
+
+        lastcompdt = None
+        lastcomp = None
+
+        for comp in self._comps:
+            compdt = self._find_compdt(comp, dt)
+
+            if compdt and (not lastcompdt or lastcompdt < compdt):
+                lastcompdt = compdt
+                lastcomp = comp
+
+        if not lastcomp:
+            # RFC says nothing about what to do when a given
+            # time is before the first onset date. We'll look for the
+            # first standard component, or the first component, if
+            # none is found.
+            for comp in self._comps:
+                if not comp.isdst:
+                    lastcomp = comp
+                    break
+            else:
+                lastcomp = comp[0]
+
+        with self._cache_lock:
+            self._cachedate.insert(0, (dt, self._fold(dt)))
+            self._cachecomp.insert(0, lastcomp)
+
+            if len(self._cachedate) > 10:
+                self._cachedate.pop()
+                self._cachecomp.pop()
+
+        return lastcomp
+
+    def _find_compdt(self, comp, dt):
+        if comp.tzoffsetdiff < ZERO and self._fold(dt):
+            dt -= comp.tzoffsetdiff
+
+        compdt = comp.rrule.before(dt, inc=True)
+
+        return compdt
+
+    def utcoffset(self, dt):
+        if dt is None:
+            return None
+
+        return self._find_comp(dt).tzoffsetto
+
+    def dst(self, dt):
+        comp = self._find_comp(dt)
+        if comp.isdst:
+            return comp.tzoffsetdiff
+        else:
+            return ZERO
+
+    @tzname_in_python2
+    def tzname(self, dt):
+        return self._find_comp(dt).tzname
+
+    def __repr__(self):
+        return "<tzicalvtz %s>" % repr(self._tzid)
+
+    __reduce__ = object.__reduce__
+
+
+class tzical(object):
+    """
+    This object is designed to parse an iCalendar-style ``VTIMEZONE`` structure
+    as set out in `RFC 5545`_ Section 4.6.5 into one or more `tzinfo` objects.
+
+    :param `fileobj`:
+        A file or stream in iCalendar format, which should be UTF-8 encoded
+        with CRLF endings.
+
+    .. _`RFC 5545`: https://tools.ietf.org/html/rfc5545
+    """
+    def __init__(self, fileobj):
+        global rrule
+        from dateutil import rrule
+
+        if isinstance(fileobj, string_types):
+            self._s = fileobj
+            # ical should be encoded in UTF-8 with CRLF
+            fileobj = open(fileobj, 'r')
+        else:
+            self._s = getattr(fileobj, 'name', repr(fileobj))
+            fileobj = _nullcontext(fileobj)
+
+        self._vtz = {}
+
+        with fileobj as fobj:
+            self._parse_rfc(fobj.read())
+
+    def keys(self):
+        """
+        Retrieves the available time zones as a list.
+        """
+        return list(self._vtz.keys())
+
+    def get(self, tzid=None):
+        """
+        Retrieve a :py:class:`datetime.tzinfo` object by its ``tzid``.
+
+        :param tzid:
+            If there is exactly one time zone available, omitting ``tzid``
+            or passing :py:const:`None` value returns it. Otherwise a valid
+            key (which can be retrieved from :func:`keys`) is required.
+
+        :raises ValueError:
+            Raised if ``tzid`` is not specified but there are either more
+            or fewer than 1 zone defined.
+
+        :returns:
+            Returns either a :py:class:`datetime.tzinfo` object representing
+            the relevant time zone or :py:const:`None` if the ``tzid`` was
+            not found.
+        """
+        if tzid is None:
+            if len(self._vtz) == 0:
+                raise ValueError("no timezones defined")
+            elif len(self._vtz) > 1:
+                raise ValueError("more than one timezone available")
+            tzid = next(iter(self._vtz))
+
+        return self._vtz.get(tzid)
+
+    def _parse_offset(self, s):
+        s = s.strip()
+        if not s:
+            raise ValueError("empty offset")
+        if s[0] in ('+', '-'):
+            signal = (-1, +1)[s[0] == '+']
+            s = s[1:]
+        else:
+            signal = +1
+        if len(s) == 4:
+            return (int(s[:2]) * 3600 + int(s[2:]) * 60) * signal
+        elif len(s) == 6:
+            return (int(s[:2]) * 3600 + int(s[2:4]) * 60 + int(s[4:])) * signal
+        else:
+            raise ValueError("invalid offset: " + s)
+
+    def _parse_rfc(self, s):
+        lines = s.splitlines()
+        if not lines:
+            raise ValueError("empty string")
+
+        # Unfold
+        i = 0
+        while i < len(lines):
+            line = lines[i].rstrip()
+            if not line:
+                del lines[i]
+            elif i > 0 and line[0] == " ":
+                lines[i-1] += line[1:]
+                del lines[i]
+            else:
+                i += 1
+
+        tzid = None
+        comps = []
+        invtz = False
+        comptype = None
+        for line in lines:
+            if not line:
+                continue
+            name, value = line.split(':', 1)
+            parms = name.split(';')
+            if not parms:
+                raise ValueError("empty property name")
+            name = parms[0].upper()
+            parms = parms[1:]
+            if invtz:
+                if name == "BEGIN":
+                    if value in ("STANDARD", "DAYLIGHT"):
+                        # Process component
+                        pass
+                    else:
+                        raise ValueError("unknown component: "+value)
+                    comptype = value
+                    founddtstart = False
+                    tzoffsetfrom = None
+                    tzoffsetto = None
+                    rrulelines = []
+                    tzname = None
+                elif name == "END":
+                    if value == "VTIMEZONE":
+                        if comptype:
+                            raise ValueError("component not closed: "+comptype)
+                        if not tzid:
+                            raise ValueError("mandatory TZID not found")
+                        if not comps:
+                            raise ValueError(
+                                "at least one component is needed")
+                        # Process vtimezone
+                        self._vtz[tzid] = _tzicalvtz(tzid, comps)
+                        invtz = False
+                    elif value == comptype:
+                        if not founddtstart:
+                            raise ValueError("mandatory DTSTART not found")
+                        if tzoffsetfrom is None:
+                            raise ValueError(
+                                "mandatory TZOFFSETFROM not found")
+                        if tzoffsetto is None:
+                            raise ValueError(
+                                "mandatory TZOFFSETFROM not found")
+                        # Process component
+                        rr = None
+                        if rrulelines:
+                            rr = rrule.rrulestr("\n".join(rrulelines),
+                                                compatible=True,
+                                                ignoretz=True,
+                                                cache=True)
+                        comp = _tzicalvtzcomp(tzoffsetfrom, tzoffsetto,
+                                              (comptype == "DAYLIGHT"),
+                                              tzname, rr)
+                        comps.append(comp)
+                        comptype = None
+                    else:
+                        raise ValueError("invalid component end: "+value)
+                elif comptype:
+                    if name == "DTSTART":
+                        # DTSTART in VTIMEZONE takes a subset of valid RRULE
+                        # values under RFC 5545.
+                        for parm in parms:
+                            if parm != 'VALUE=DATE-TIME':
+                                msg = ('Unsupported DTSTART param in ' +
+                                       'VTIMEZONE: ' + parm)
+                                raise ValueError(msg)
+                        rrulelines.append(line)
+                        founddtstart = True
+                    elif name in ("RRULE", "RDATE", "EXRULE", "EXDATE"):
+                        rrulelines.append(line)
+                    elif name == "TZOFFSETFROM":
+                        if parms:
+                            raise ValueError(
+                                "unsupported %s parm: %s " % (name, parms[0]))
+                        tzoffsetfrom = self._parse_offset(value)
+                    elif name == "TZOFFSETTO":
+                        if parms:
+                            raise ValueError(
+                                "unsupported TZOFFSETTO parm: "+parms[0])
+                        tzoffsetto = self._parse_offset(value)
+                    elif name == "TZNAME":
+                        if parms:
+                            raise ValueError(
+                                "unsupported TZNAME parm: "+parms[0])
+                        tzname = value
+                    elif name == "COMMENT":
+                        pass
+                    else:
+                        raise ValueError("unsupported property: "+name)
+                else:
+                    if name == "TZID":
+                        if parms:
+                            raise ValueError(
+                                "unsupported TZID parm: "+parms[0])
+                        tzid = value
+                    elif name in ("TZURL", "LAST-MODIFIED", "COMMENT"):
+                        pass
+                    else:
+                        raise ValueError("unsupported property: "+name)
+            elif name == "BEGIN" and value == "VTIMEZONE":
+                tzid = None
+                comps = []
+                invtz = True
+
+    def __repr__(self):
+        return "%s(%s)" % (self.__class__.__name__, repr(self._s))
+
+
+if sys.platform != "win32":
+    TZFILES = ["/etc/localtime", "localtime"]
+    TZPATHS = ["/usr/share/zoneinfo",
+               "/usr/lib/zoneinfo",
+               "/usr/share/lib/zoneinfo",
+               "/etc/zoneinfo"]
+else:
+    TZFILES = []
+    TZPATHS = []
+
+
+def __get_gettz():
+    tzlocal_classes = (tzlocal,)
+    if tzwinlocal is not None:
+        tzlocal_classes += (tzwinlocal,)
+
+    class GettzFunc(object):
+        """
+        Retrieve a time zone object from a string representation
+
+        This function is intended to retrieve the :py:class:`tzinfo` subclass
+        that best represents the time zone that would be used if a POSIX
+        `TZ variable`_ were set to the same value.
+
+        If no argument or an empty string is passed to ``gettz``, local time
+        is returned:
+
+        .. code-block:: python3
+
+            >>> gettz()
+            tzfile('/etc/localtime')
+
+        This function is also the preferred way to map IANA tz database keys
+        to :class:`tzfile` objects:
+
+        .. code-block:: python3
+
+            >>> gettz('Pacific/Kiritimati')
+            tzfile('/usr/share/zoneinfo/Pacific/Kiritimati')
+
+        On Windows, the standard is extended to include the Windows-specific
+        zone names provided by the operating system:
+
+        .. code-block:: python3
+
+            >>> gettz('Egypt Standard Time')
+            tzwin('Egypt Standard Time')
+
+        Passing a GNU ``TZ`` style string time zone specification returns a
+        :class:`tzstr` object:
+
+        .. code-block:: python3
+
+            >>> gettz('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')
+            tzstr('AEST-10AEDT-11,M10.1.0/2,M4.1.0/3')
+
+        :param name:
+            A time zone name (IANA, or, on Windows, Windows keys), location of
+            a ``tzfile(5)`` zoneinfo file or ``TZ`` variable style time zone
+            specifier. An empty string, no argument or ``None`` is interpreted
+            as local time.
+
+        :return:
+            Returns an instance of one of ``dateutil``'s :py:class:`tzinfo`
+            subclasses.
+
+        .. versionchanged:: 2.7.0
+
+            After version 2.7.0, any two calls to ``gettz`` using the same
+            input strings will return the same object:
+
+            .. code-block:: python3
+
+                >>> tz.gettz('America/Chicago') is tz.gettz('America/Chicago')
+                True
+
+            In addition to improving performance, this ensures that
+            `"same zone" semantics`_ are used for datetimes in the same zone.
+
+
+        .. _`TZ variable`:
+            https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
+
+        .. _`"same zone" semantics`:
+            https://blog.ganssle.io/articles/2018/02/aware-datetime-arithmetic.html
+        """
+        def __init__(self):
+
+            self.__instances = weakref.WeakValueDictionary()
+            self.__strong_cache_size = 8
+            self.__strong_cache = OrderedDict()
+            self._cache_lock = _thread.allocate_lock()
+
+        def __call__(self, name=None):
+            with self._cache_lock:
+                rv = self.__instances.get(name, None)
+
+                if rv is None:
+                    rv = self.nocache(name=name)
+                    if not (name is None
+                            or isinstance(rv, tzlocal_classes)
+                            or rv is None):
+                        # tzlocal is slightly more complicated than the other
+                        # time zone providers because it depends on environment
+                        # at construction time, so don't cache that.
+                        #
+                        # We also cannot store weak references to None, so we
+                        # will also not store that.
+                        self.__instances[name] = rv
+                    else:
+                        # No need for strong caching, return immediately
+                        return rv
+
+                self.__strong_cache[name] = self.__strong_cache.pop(name, rv)
+
+                if len(self.__strong_cache) > self.__strong_cache_size:
+                    self.__strong_cache.popitem(last=False)
+
+            return rv
+
+        def set_cache_size(self, size):
+            with self._cache_lock:
+                self.__strong_cache_size = size
+                while len(self.__strong_cache) > size:
+                    self.__strong_cache.popitem(last=False)
+
+        def cache_clear(self):
+            with self._cache_lock:
+                self.__instances = weakref.WeakValueDictionary()
+                self.__strong_cache.clear()
+
+        @staticmethod
+        def nocache(name=None):
+            """A non-cached version of gettz"""
+            tz = None
+            if not name:
+                try:
+                    name = os.environ["TZ"]
+                except KeyError:
+                    pass
+            if name is None or name in ("", ":"):
+                for filepath in TZFILES:
+                    if not os.path.isabs(filepath):
+                        filename = filepath
+                        for path in TZPATHS:
+                            filepath = os.path.join(path, filename)
+                            if os.path.isfile(filepath):
+                                break
+                        else:
+                            continue
+                    if os.path.isfile(filepath):
+                        try:
+                            tz = tzfile(filepath)
+                            break
+                        except (IOError, OSError, ValueError):
+                            pass
+                else:
+                    tz = tzlocal()
+            else:
+                try:
+                    if name.startswith(":"):
+                        name = name[1:]
+                except TypeError as e:
+                    if isinstance(name, bytes):
+                        new_msg = "gettz argument should be str, not bytes"
+                        six.raise_from(TypeError(new_msg), e)
+                    else:
+                        raise
+                if os.path.isabs(name):
+                    if os.path.isfile(name):
+                        tz = tzfile(name)
+                    else:
+                        tz = None
+                else:
+                    for path in TZPATHS:
+                        filepath = os.path.join(path, name)
+                        if not os.path.isfile(filepath):
+                            filepath = filepath.replace(' ', '_')
+                            if not os.path.isfile(filepath):
+                                continue
+                        try:
+                            tz = tzfile(filepath)
+                            break
+                        except (IOError, OSError, ValueError):
+                            pass
+                    else:
+                        tz = None
+                        if tzwin is not None:
+                            try:
+                                tz = tzwin(name)
+                            except (WindowsError, UnicodeEncodeError):
+                                # UnicodeEncodeError is for Python 2.7 compat
+                                tz = None
+
+                        if not tz:
+                            from dateutil.zoneinfo import get_zonefile_instance
+                            tz = get_zonefile_instance().get(name)
+
+                        if not tz:
+                            for c in name:
+                                # name is not a tzstr unless it has at least
+                                # one offset. For short values of "name", an
+                                # explicit for loop seems to be the fastest way
+                                # To determine if a string contains a digit
+                                if c in "0123456789":
+                                    try:
+                                        tz = tzstr(name)
+                                    except ValueError:
+                                        pass
+                                    break
+                            else:
+                                if name in ("GMT", "UTC"):
+                                    tz = UTC
+                                elif name in time.tzname:
+                                    tz = tzlocal()
+            return tz
+
+    return GettzFunc()
+
+
+gettz = __get_gettz()
+del __get_gettz
+
+
+def datetime_exists(dt, tz=None):
+    """
+    Given a datetime and a time zone, determine whether or not a given datetime
+    would fall in a gap.
+
+    :param dt:
+        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``
+        is provided.)
+
+    :param tz:
+        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If
+        ``None`` or not provided, the datetime's own time zone will be used.
+
+    :return:
+        Returns a boolean value whether or not the "wall time" exists in
+        ``tz``.
+
+    .. versionadded:: 2.7.0
+    """
+    if tz is None:
+        if dt.tzinfo is None:
+            raise ValueError('Datetime is naive and no time zone provided.')
+        tz = dt.tzinfo
+
+    dt = dt.replace(tzinfo=None)
+
+    # This is essentially a test of whether or not the datetime can survive
+    # a round trip to UTC.
+    dt_rt = dt.replace(tzinfo=tz).astimezone(UTC).astimezone(tz)
+    dt_rt = dt_rt.replace(tzinfo=None)
+
+    return dt == dt_rt
+
+
+def datetime_ambiguous(dt, tz=None):
+    """
+    Given a datetime and a time zone, determine whether or not a given datetime
+    is ambiguous (i.e if there are two times differentiated only by their DST
+    status).
+
+    :param dt:
+        A :class:`datetime.datetime` (whose time zone will be ignored if ``tz``
+        is provided.)
+
+    :param tz:
+        A :class:`datetime.tzinfo` with support for the ``fold`` attribute. If
+        ``None`` or not provided, the datetime's own time zone will be used.
+
+    :return:
+        Returns a boolean value whether or not the "wall time" is ambiguous in
+        ``tz``.
+
+    .. versionadded:: 2.6.0
+    """
+    if tz is None:
+        if dt.tzinfo is None:
+            raise ValueError('Datetime is naive and no time zone provided.')
+
+        tz = dt.tzinfo
+
+    # If a time zone defines its own "is_ambiguous" function, we'll use that.
+    is_ambiguous_fn = getattr(tz, 'is_ambiguous', None)
+    if is_ambiguous_fn is not None:
+        try:
+            return tz.is_ambiguous(dt)
+        except Exception:
+            pass
+
+    # If it doesn't come out and tell us it's ambiguous, we'll just check if
+    # the fold attribute has any effect on this particular date and time.
+    dt = dt.replace(tzinfo=tz)
+    wall_0 = enfold(dt, fold=0)
+    wall_1 = enfold(dt, fold=1)
+
+    same_offset = wall_0.utcoffset() == wall_1.utcoffset()
+    same_dst = wall_0.dst() == wall_1.dst()
+
+    return not (same_offset and same_dst)
+
+
+def resolve_imaginary(dt):
+    """
+    Given a datetime that may be imaginary, return an existing datetime.
+
+    This function assumes that an imaginary datetime represents what the
+    wall time would be in a zone had the offset transition not occurred, so
+    it will always fall forward by the transition's change in offset.
+
+    .. doctest::
+
+        >>> from dateutil import tz
+        >>> from datetime import datetime
+        >>> NYC = tz.gettz('America/New_York')
+        >>> print(tz.resolve_imaginary(datetime(2017, 3, 12, 2, 30, tzinfo=NYC)))
+        2017-03-12 03:30:00-04:00
+
+        >>> KIR = tz.gettz('Pacific/Kiritimati')
+        >>> print(tz.resolve_imaginary(datetime(1995, 1, 1, 12, 30, tzinfo=KIR)))
+        1995-01-02 12:30:00+14:00
+
+    As a note, :func:`datetime.astimezone` is guaranteed to produce a valid,
+    existing datetime, so a round-trip to and from UTC is sufficient to get
+    an extant datetime, however, this generally "falls back" to an earlier time
+    rather than falling forward to the STD side (though no guarantees are made
+    about this behavior).
+
+    :param dt:
+        A :class:`datetime.datetime` which may or may not exist.
+
+    :return:
+        Returns an existing :class:`datetime.datetime`. If ``dt`` was not
+        imaginary, the datetime returned is guaranteed to be the same object
+        passed to the function.
+
+    .. versionadded:: 2.7.0
+    """
+    if dt.tzinfo is not None and not datetime_exists(dt):
+
+        curr_offset = (dt + datetime.timedelta(hours=24)).utcoffset()
+        old_offset = (dt - datetime.timedelta(hours=24)).utcoffset()
+
+        dt += curr_offset - old_offset
+
+    return dt
+
+
+def _datetime_to_timestamp(dt):
+    """
+    Convert a :class:`datetime.datetime` object to an epoch timestamp in
+    seconds since January 1, 1970, ignoring the time zone.
+    """
+    return (dt.replace(tzinfo=None) - EPOCH).total_seconds()
+
+
+if sys.version_info >= (3, 6):
+    def _get_supported_offset(second_offset):
+        return second_offset
+else:
+    def _get_supported_offset(second_offset):
+        # For python pre-3.6, round to full-minutes if that's not the case.
+        # Python's datetime doesn't accept sub-minute timezones. Check
+        # http://python.org/sf/1447945 or https://bugs.python.org/issue5288
+        # for some information.
+        old_offset = second_offset
+        calculated_offset = 60 * ((second_offset + 30) // 60)
+        return calculated_offset
+
+
+try:
+    # Python 3.7 feature
+    from contextlib import nullcontext as _nullcontext
+except ImportError:
+    class _nullcontext(object):
+        """
+        Class for wrapping contexts so that they are passed through in a
+        with statement.
+        """
+        def __init__(self, context):
+            self.context = context
+
+        def __enter__(self):
+            return self.context
+
+        def __exit__(*args, **kwargs):
+            pass
+
+# vim:ts=4:sw=4:et
diff --git a/dateutil/tz/win.py b/dateutil/tz/win.py
new file mode 100644
index 0000000..cde07ba
--- /dev/null
+++ b/dateutil/tz/win.py
@@ -0,0 +1,370 @@
+# -*- coding: utf-8 -*-
+"""
+This module provides an interface to the native time zone data on Windows,
+including :py:class:`datetime.tzinfo` implementations.
+
+Attempting to import this module on a non-Windows platform will raise an
+:py:obj:`ImportError`.
+"""
+# This code was originally contributed by Jeffrey Harris.
+import datetime
+import struct
+
+from six.moves import winreg
+from six import text_type
+
+try:
+    import ctypes
+    from ctypes import wintypes
+except ValueError:
+    # ValueError is raised on non-Windows systems for some horrible reason.
+    raise ImportError("Running tzwin on non-Windows system")
+
+from ._common import tzrangebase
+
+__all__ = ["tzwin", "tzwinlocal", "tzres"]
+
+ONEWEEK = datetime.timedelta(7)
+
+TZKEYNAMENT = r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones"
+TZKEYNAME9X = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Time Zones"
+TZLOCALKEYNAME = r"SYSTEM\CurrentControlSet\Control\TimeZoneInformation"
+
+
+def _settzkeyname():
+    handle = winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE)
+    try:
+        winreg.OpenKey(handle, TZKEYNAMENT).Close()
+        TZKEYNAME = TZKEYNAMENT
+    except WindowsError:
+        TZKEYNAME = TZKEYNAME9X
+    handle.Close()
+    return TZKEYNAME
+
+
+TZKEYNAME = _settzkeyname()
+
+
+class tzres(object):
+    """
+    Class for accessing ``tzres.dll``, which contains timezone name related
+    resources.
+
+    .. versionadded:: 2.5.0
+    """
+    p_wchar = ctypes.POINTER(wintypes.WCHAR)        # Pointer to a wide char
+
+    def __init__(self, tzres_loc='tzres.dll'):
+        # Load the user32 DLL so we can load strings from tzres
+        user32 = ctypes.WinDLL('user32')
+
+        # Specify the LoadStringW function
+        user32.LoadStringW.argtypes = (wintypes.HINSTANCE,
+                                       wintypes.UINT,
+                                       wintypes.LPWSTR,
+                                       ctypes.c_int)
+
+        self.LoadStringW = user32.LoadStringW
+        self._tzres = ctypes.WinDLL(tzres_loc)
+        self.tzres_loc = tzres_loc
+
+    def load_name(self, offset):
+        """
+        Load a timezone name from a DLL offset (integer).
+
+        >>> from dateutil.tzwin import tzres
+        >>> tzr = tzres()
+        >>> print(tzr.load_name(112))
+        'Eastern Standard Time'
+
+        :param offset:
+            A positive integer value referring to a string from the tzres dll.
+
+        .. note::
+
+            Offsets found in the registry are generally of the form
+            ``@tzres.dll,-114``. The offset in this case is 114, not -114.
+
+        """
+        resource = self.p_wchar()
+        lpBuffer = ctypes.cast(ctypes.byref(resource), wintypes.LPWSTR)
+        nchar = self.LoadStringW(self._tzres._handle, offset, lpBuffer, 0)
+        return resource[:nchar]
+
+    def name_from_string(self, tzname_str):
+        """
+        Parse strings as returned from the Windows registry into the time zone
+        name as defined in the registry.
+
+        >>> from dateutil.tzwin import tzres
+        >>> tzr = tzres()
+        >>> print(tzr.name_from_string('@tzres.dll,-251'))
+        'Dateline Daylight Time'
+        >>> print(tzr.name_from_string('Eastern Standard Time'))
+        'Eastern Standard Time'
+
+        :param tzname_str:
+            A timezone name string as returned from a Windows registry key.
+
+        :return:
+            Returns the localized timezone string from tzres.dll if the string
+            is of the form `@tzres.dll,-offset`, else returns the input string.
+        """
+        if not tzname_str.startswith('@'):
+            return tzname_str
+
+        name_splt = tzname_str.split(',-')
+        try:
+            offset = int(name_splt[1])
+        except:
+            raise ValueError("Malformed timezone string.")
+
+        return self.load_name(offset)
+
+
+class tzwinbase(tzrangebase):
+    """tzinfo class based on win32's timezones available in the registry."""
+    def __init__(self):
+        raise NotImplementedError('tzwinbase is an abstract base class')
+
+    def __eq__(self, other):
+        # Compare on all relevant dimensions, including name.
+        if not isinstance(other, tzwinbase):
+            return NotImplemented
+
+        return  (self._std_offset == other._std_offset and
+                 self._dst_offset == other._dst_offset and
+                 self._stddayofweek == other._stddayofweek and
+                 self._dstdayofweek == other._dstdayofweek and
+                 self._stdweeknumber == other._stdweeknumber and
+                 self._dstweeknumber == other._dstweeknumber and
+                 self._stdhour == other._stdhour and
+                 self._dsthour == other._dsthour and
+                 self._stdminute == other._stdminute and
+                 self._dstminute == other._dstminute and
+                 self._std_abbr == other._std_abbr and
+                 self._dst_abbr == other._dst_abbr)
+
+    @staticmethod
+    def list():
+        """Return a list of all time zones known to the system."""
+        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
+            with winreg.OpenKey(handle, TZKEYNAME) as tzkey:
+                result = [winreg.EnumKey(tzkey, i)
+                          for i in range(winreg.QueryInfoKey(tzkey)[0])]
+        return result
+
+    def display(self):
+        """
+        Return the display name of the time zone.
+        """
+        return self._display
+
+    def transitions(self, year):
+        """
+        For a given year, get the DST on and off transition times, expressed
+        always on the standard time side. For zones with no transitions, this
+        function returns ``None``.
+
+        :param year:
+            The year whose transitions you would like to query.
+
+        :return:
+            Returns a :class:`tuple` of :class:`datetime.datetime` objects,
+            ``(dston, dstoff)`` for zones with an annual DST transition, or
+            ``None`` for fixed offset zones.
+        """
+
+        if not self.hasdst:
+            return None
+
+        dston = picknthweekday(year, self._dstmonth, self._dstdayofweek,
+                               self._dsthour, self._dstminute,
+                               self._dstweeknumber)
+
+        dstoff = picknthweekday(year, self._stdmonth, self._stddayofweek,
+                                self._stdhour, self._stdminute,
+                                self._stdweeknumber)
+
+        # Ambiguous dates default to the STD side
+        dstoff -= self._dst_base_offset
+
+        return dston, dstoff
+
+    def _get_hasdst(self):
+        return self._dstmonth != 0
+
+    @property
+    def _dst_base_offset(self):
+        return self._dst_base_offset_
+
+
+class tzwin(tzwinbase):
+    """
+    Time zone object created from the zone info in the Windows registry
+
+    These are similar to :py:class:`dateutil.tz.tzrange` objects in that
+    the time zone data is provided in the format of a single offset rule
+    for either 0 or 2 time zone transitions per year.
+
+    :param: name
+        The name of a Windows time zone key, e.g. "Eastern Standard Time".
+        The full list of keys can be retrieved with :func:`tzwin.list`.
+    """
+
+    def __init__(self, name):
+        self._name = name
+
+        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
+            tzkeyname = text_type("{kn}\\{name}").format(kn=TZKEYNAME, name=name)
+            with winreg.OpenKey(handle, tzkeyname) as tzkey:
+                keydict = valuestodict(tzkey)
+
+        self._std_abbr = keydict["Std"]
+        self._dst_abbr = keydict["Dlt"]
+
+        self._display = keydict["Display"]
+
+        # See http://ww_winreg.jsiinc.com/SUBA/tip0300/rh0398.htm
+        tup = struct.unpack("=3l16h", keydict["TZI"])
+        stdoffset = -tup[0]-tup[1]          # Bias + StandardBias * -1
+        dstoffset = stdoffset-tup[2]        # + DaylightBias * -1
+        self._std_offset = datetime.timedelta(minutes=stdoffset)
+        self._dst_offset = datetime.timedelta(minutes=dstoffset)
+
+        # for the meaning see the win32 TIME_ZONE_INFORMATION structure docs
+        # http://msdn.microsoft.com/en-us/library/windows/desktop/ms725481(v=vs.85).aspx
+        (self._stdmonth,
+         self._stddayofweek,   # Sunday = 0
+         self._stdweeknumber,  # Last = 5
+         self._stdhour,
+         self._stdminute) = tup[4:9]
+
+        (self._dstmonth,
+         self._dstdayofweek,   # Sunday = 0
+         self._dstweeknumber,  # Last = 5
+         self._dsthour,
+         self._dstminute) = tup[12:17]
+
+        self._dst_base_offset_ = self._dst_offset - self._std_offset
+        self.hasdst = self._get_hasdst()
+
+    def __repr__(self):
+        return "tzwin(%s)" % repr(self._name)
+
+    def __reduce__(self):
+        return (self.__class__, (self._name,))
+
+
+class tzwinlocal(tzwinbase):
+    """
+    Class representing the local time zone information in the Windows registry
+
+    While :class:`dateutil.tz.tzlocal` makes system calls (via the :mod:`time`
+    module) to retrieve time zone information, ``tzwinlocal`` retrieves the
+    rules directly from the Windows registry and creates an object like
+    :class:`dateutil.tz.tzwin`.
+
+    Because Windows does not have an equivalent of :func:`time.tzset`, on
+    Windows, :class:`dateutil.tz.tzlocal` instances will always reflect the
+    time zone settings *at the time that the process was started*, meaning
+    changes to the machine's time zone settings during the run of a program
+    on Windows will **not** be reflected by :class:`dateutil.tz.tzlocal`.
+    Because ``tzwinlocal`` reads the registry directly, it is unaffected by
+    this issue.
+    """
+    def __init__(self):
+        with winreg.ConnectRegistry(None, winreg.HKEY_LOCAL_MACHINE) as handle:
+            with winreg.OpenKey(handle, TZLOCALKEYNAME) as tzlocalkey:
+                keydict = valuestodict(tzlocalkey)
+
+            self._std_abbr = keydict["StandardName"]
+            self._dst_abbr = keydict["DaylightName"]
+
+            try:
+                tzkeyname = text_type('{kn}\\{sn}').format(kn=TZKEYNAME,
+                                                          sn=self._std_abbr)
+                with winreg.OpenKey(handle, tzkeyname) as tzkey:
+                    _keydict = valuestodict(tzkey)
+                    self._display = _keydict["Display"]
+            except OSError:
+                self._display = None
+
+        stdoffset = -keydict["Bias"]-keydict["StandardBias"]
+        dstoffset = stdoffset-keydict["DaylightBias"]
+
+        self._std_offset = datetime.timedelta(minutes=stdoffset)
+        self._dst_offset = datetime.timedelta(minutes=dstoffset)
+
+        # For reasons unclear, in this particular key, the day of week has been
+        # moved to the END of the SYSTEMTIME structure.
+        tup = struct.unpack("=8h", keydict["StandardStart"])
+
+        (self._stdmonth,
+         self._stdweeknumber,  # Last = 5
+         self._stdhour,
+         self._stdminute) = tup[1:5]
+
+        self._stddayofweek = tup[7]
+
+        tup = struct.unpack("=8h", keydict["DaylightStart"])
+
+        (self._dstmonth,
+         self._dstweeknumber,  # Last = 5
+         self._dsthour,
+         self._dstminute) = tup[1:5]
+
+        self._dstdayofweek = tup[7]
+
+        self._dst_base_offset_ = self._dst_offset - self._std_offset
+        self.hasdst = self._get_hasdst()
+
+    def __repr__(self):
+        return "tzwinlocal()"
+
+    def __str__(self):
+        # str will return the standard name, not the daylight name.
+        return "tzwinlocal(%s)" % repr(self._std_abbr)
+
+    def __reduce__(self):
+        return (self.__class__, ())
+
+
+def picknthweekday(year, month, dayofweek, hour, minute, whichweek):
+    """ dayofweek == 0 means Sunday, whichweek 5 means last instance """
+    first = datetime.datetime(year, month, 1, hour, minute)
+
+    # This will work if dayofweek is ISO weekday (1-7) or Microsoft-style (0-6),
+    # Because 7 % 7 = 0
+    weekdayone = first.replace(day=((dayofweek - first.isoweekday()) % 7) + 1)
+    wd = weekdayone + ((whichweek - 1) * ONEWEEK)
+    if (wd.month != month):
+        wd -= ONEWEEK
+
+    return wd
+
+
+def valuestodict(key):
+    """Convert a registry key's values to a dictionary."""
+    dout = {}
+    size = winreg.QueryInfoKey(key)[1]
+    tz_res = None
+
+    for i in range(size):
+        key_name, value, dtype = winreg.EnumValue(key, i)
+        if dtype == winreg.REG_DWORD or dtype == winreg.REG_DWORD_LITTLE_ENDIAN:
+            # If it's a DWORD (32-bit integer), it's stored as unsigned - convert
+            # that to a proper signed integer
+            if value & (1 << 31):
+                value = value - (1 << 32)
+        elif dtype == winreg.REG_SZ:
+            # If it's a reference to the tzres DLL, load the actual string
+            if value.startswith('@tzres'):
+                tz_res = tz_res or tzres()
+                value = tz_res.name_from_string(value)
+
+            value = value.rstrip('\x00')    # Remove trailing nulls
+
+        dout[key_name] = value
+
+    return dout
diff --git a/dateutil/tzwin.py b/dateutil/tzwin.py
new file mode 100644
index 0000000..cebc673
--- /dev/null
+++ b/dateutil/tzwin.py
@@ -0,0 +1,2 @@
+# tzwin has moved to dateutil.tz.win
+from .tz.win import *
diff --git a/dateutil/utils.py b/dateutil/utils.py
new file mode 100644
index 0000000..dd2d245
--- /dev/null
+++ b/dateutil/utils.py
@@ -0,0 +1,71 @@
+# -*- coding: utf-8 -*-
+"""
+This module offers general convenience and utility functions for dealing with
+datetimes.
+
+.. versionadded:: 2.7.0
+"""
+from __future__ import unicode_literals
+
+from datetime import datetime, time
+
+
+def today(tzinfo=None):
+    """
+    Returns a :py:class:`datetime` representing the current day at midnight
+
+    :param tzinfo:
+        The time zone to attach (also used to determine the current day).
+
+    :return:
+        A :py:class:`datetime.datetime` object representing the current day
+        at midnight.
+    """
+
+    dt = datetime.now(tzinfo)
+    return datetime.combine(dt.date(), time(0, tzinfo=tzinfo))
+
+
+def default_tzinfo(dt, tzinfo):
+    """
+    Sets the ``tzinfo`` parameter on naive datetimes only
+
+    This is useful for example when you are provided a datetime that may have
+    either an implicit or explicit time zone, such as when parsing a time zone
+    string.
+
+    .. doctest::
+
+        >>> from dateutil.tz import tzoffset
+        >>> from dateutil.parser import parse
+        >>> from dateutil.utils import default_tzinfo
+        >>> dflt_tz = tzoffset("EST", -18000)
+        >>> print(default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz))
+        2014-01-01 12:30:00+00:00
+        >>> print(default_tzinfo(parse('2014-01-01 12:30'), dflt_tz))
+        2014-01-01 12:30:00-05:00
+
+    :param dt:
+        The datetime on which to replace the time zone
+
+    :param tzinfo:
+        The :py:class:`datetime.tzinfo` subclass instance to assign to
+        ``dt`` if (and only if) it is naive.
+
+    :return:
+        Returns an aware :py:class:`datetime.datetime`.
+    """
+    if dt.tzinfo is not None:
+        return dt
+    else:
+        return dt.replace(tzinfo=tzinfo)
+
+
+def within_delta(dt1, dt2, delta):
+    """
+    Useful for comparing two datetimes that may have a negligible difference
+    to be considered equal.
+    """
+    delta = abs(delta)
+    difference = dt1 - dt2
+    return -delta <= difference <= delta
diff --git a/dateutil/zoneinfo/__init__.py b/dateutil/zoneinfo/__init__.py
new file mode 100644
index 0000000..34f11ad
--- /dev/null
+++ b/dateutil/zoneinfo/__init__.py
@@ -0,0 +1,167 @@
+# -*- coding: utf-8 -*-
+import warnings
+import json
+
+from tarfile import TarFile
+from pkgutil import get_data
+from io import BytesIO
+
+from dateutil.tz import tzfile as _tzfile
+
+__all__ = ["get_zonefile_instance", "gettz", "gettz_db_metadata"]
+
+ZONEFILENAME = "dateutil-zoneinfo.tar.gz"
+METADATA_FN = 'METADATA'
+
+
+class tzfile(_tzfile):
+    def __reduce__(self):
+        return (gettz, (self._filename,))
+
+
+def getzoneinfofile_stream():
+    try:
+        return BytesIO(get_data(__name__, ZONEFILENAME))
+    except IOError as e:  # TODO  switch to FileNotFoundError?
+        warnings.warn("I/O error({0}): {1}".format(e.errno, e.strerror))
+        return None
+
+
+class ZoneInfoFile(object):
+    def __init__(self, zonefile_stream=None):
+        if zonefile_stream is not None:
+            with TarFile.open(fileobj=zonefile_stream) as tf:
+                self.zones = {zf.name: tzfile(tf.extractfile(zf), filename=zf.name)
+                              for zf in tf.getmembers()
+                              if zf.isfile() and zf.name != METADATA_FN}
+                # deal with links: They'll point to their parent object. Less
+                # waste of memory
+                links = {zl.name: self.zones[zl.linkname]
+                         for zl in tf.getmembers() if
+                         zl.islnk() or zl.issym()}
+                self.zones.update(links)
+                try:
+                    metadata_json = tf.extractfile(tf.getmember(METADATA_FN))
+                    metadata_str = metadata_json.read().decode('UTF-8')
+                    self.metadata = json.loads(metadata_str)
+                except KeyError:
+                    # no metadata in tar file
+                    self.metadata = None
+        else:
+            self.zones = {}
+            self.metadata = None
+
+    def get(self, name, default=None):
+        """
+        Wrapper for :func:`ZoneInfoFile.zones.get`. This is a convenience method
+        for retrieving zones from the zone dictionary.
+
+        :param name:
+            The name of the zone to retrieve. (Generally IANA zone names)
+
+        :param default:
+            The value to return in the event of a missing key.
+
+        .. versionadded:: 2.6.0
+
+        """
+        return self.zones.get(name, default)
+
+
+# The current API has gettz as a module function, although in fact it taps into
+# a stateful class. So as a workaround for now, without changing the API, we
+# will create a new "global" class instance the first time a user requests a
+# timezone. Ugly, but adheres to the api.
+#
+# TODO: Remove after deprecation period.
+_CLASS_ZONE_INSTANCE = []
+
+
+def get_zonefile_instance(new_instance=False):
+    """
+    This is a convenience function which provides a :class:`ZoneInfoFile`
+    instance using the data provided by the ``dateutil`` package. By default, it
+    caches a single instance of the ZoneInfoFile object and returns that.
+
+    :param new_instance:
+        If ``True``, a new instance of :class:`ZoneInfoFile` is instantiated and
+        used as the cached instance for the next call. Otherwise, new instances
+        are created only as necessary.
+
+    :return:
+        Returns a :class:`ZoneInfoFile` object.
+
+    .. versionadded:: 2.6
+    """
+    if new_instance:
+        zif = None
+    else:
+        zif = getattr(get_zonefile_instance, '_cached_instance', None)
+
+    if zif is None:
+        zif = ZoneInfoFile(getzoneinfofile_stream())
+
+        get_zonefile_instance._cached_instance = zif
+
+    return zif
+
+
+def gettz(name):
+    """
+    This retrieves a time zone from the local zoneinfo tarball that is packaged
+    with dateutil.
+
+    :param name:
+        An IANA-style time zone name, as found in the zoneinfo file.
+
+    :return:
+        Returns a :class:`dateutil.tz.tzfile` time zone object.
+
+    .. warning::
+        It is generally inadvisable to use this function, and it is only
+        provided for API compatibility with earlier versions. This is *not*
+        equivalent to ``dateutil.tz.gettz()``, which selects an appropriate
+        time zone based on the inputs, favoring system zoneinfo. This is ONLY
+        for accessing the dateutil-specific zoneinfo (which may be out of
+        date compared to the system zoneinfo).
+
+    .. deprecated:: 2.6
+        If you need to use a specific zoneinfofile over the system zoneinfo,
+        instantiate a :class:`dateutil.zoneinfo.ZoneInfoFile` object and call
+        :func:`dateutil.zoneinfo.ZoneInfoFile.get(name)` instead.
+
+        Use :func:`get_zonefile_instance` to retrieve an instance of the
+        dateutil-provided zoneinfo.
+    """
+    warnings.warn("zoneinfo.gettz() will be removed in future versions, "
+                  "to use the dateutil-provided zoneinfo files, instantiate a "
+                  "ZoneInfoFile object and use ZoneInfoFile.zones.get() "
+                  "instead. See the documentation for details.",
+                  DeprecationWarning)
+
+    if len(_CLASS_ZONE_INSTANCE) == 0:
+        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))
+    return _CLASS_ZONE_INSTANCE[0].zones.get(name)
+
+
+def gettz_db_metadata():
+    """ Get the zonefile metadata
+
+    See `zonefile_metadata`_
+
+    :returns:
+        A dictionary with the database metadata
+
+    .. deprecated:: 2.6
+        See deprecation warning in :func:`zoneinfo.gettz`. To get metadata,
+        query the attribute ``zoneinfo.ZoneInfoFile.metadata``.
+    """
+    warnings.warn("zoneinfo.gettz_db_metadata() will be removed in future "
+                  "versions, to use the dateutil-provided zoneinfo files, "
+                  "ZoneInfoFile object and query the 'metadata' attribute "
+                  "instead. See the documentation for details.",
+                  DeprecationWarning)
+
+    if len(_CLASS_ZONE_INSTANCE) == 0:
+        _CLASS_ZONE_INSTANCE.append(ZoneInfoFile(getzoneinfofile_stream()))
+    return _CLASS_ZONE_INSTANCE[0].metadata
diff --git a/dateutil/zoneinfo/__pycache__/__init__.cpython-312.pyc b/dateutil/zoneinfo/__pycache__/__init__.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..880621fc1d13c41439a5df6012c0578108ca5249
GIT binary patch
literal 7430
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
YC)KO2dZyxDXCrf9wV$bG^c(bl06NDfSpWb4

literal 0
HcmV?d00001

diff --git a/dateutil/zoneinfo/__pycache__/rebuild.cpython-312.pyc b/dateutil/zoneinfo/__pycache__/rebuild.cpython-312.pyc
new file mode 100644
index 0000000000000000000000000000000000000000..20d2153349bce5a17ea0b6988bd8cf0fc721a62e
GIT binary patch
literal 3956
zcmbVPZ)_9E6`%d*wH-TuAS5INSOPg>ngq&0KoNJ98-fps%W>DV*Rz7`wRdf=WACnJ
z#~537MbSw|RHP(Qr39%euG9~y-~;L>q^eT6yOt0AawtcOmQ+2dNEP35geq<BOW&-$
zIOV8lZ!FKenR)Ncn>W9C^Y)LypdUe5H^x&x^da;&+HnitAl3;Gi%3BVlS9#Z%S0Kc
z&qi6N<)WO^@=+dIHYemgQBPisiVWrFa^Acz>T_s5=g+r9Tk?Tu0Q!s~q@hmniswTn
z8dSs&QM6U@LfuwkLcS-|gvk(V`;!?pITK6DxttxS(?)@q1rlOxaZ1K#w44fTEpJau
zg-?g4!m%@xb|CuB<iwe?=O!k@Z%^24x||dmJEDyj{v7<*1F+9UL>M|qOO~y-TkD&R
zPE{bTS5Vfom7`8)!G|xFil8tz8#=3=SID=#D2)&axMMdPHdaL+B5m$yw%w(gZ3Vf!
z$5GW=;ZCCqod{KZ6>oNXlgp(lzKY;l$e?RoJfaeF{v?}5N%lfNNcvx4_e=L(@w-|V
z*lP!PRBZu0JD#uVskFHBfCQHQntjsY@_mDqJ*3N(b~P%TOMyoMq{p4l_PSKFt?-qA
z!Yjfp&&|eZzr?=(9|t1obJuWfsRmzhj&LI?Y#ET|O3?Ep&vBgH<7#ZS6_0!NaO%h4
z>{`Ex2P>`aiq$qi&Az67m#VZic>pz|Jo0`06!*K_*#j=sYyou*L^G(wCRqm1R`nOr
ze)Mf*F-7QqfEf7AGuOPAxDQZ~d2#02r~hUA4R@UU&lVI>T_)r$|KvS2QP6UVL^7(R
z=|si4oRf%_SIdS@M^Xk<k|GneK(yRpI!Xth6NiY55BdEPloUiJUCx7)<*0kE1y~Xg
z&ZHDJ@=`pWBIbxD>+*<!(}zhp9v`X8+g?}uq|FqcP}ogDr1NOHqUyx<Sq3Jt8MS1U
z`Qq4s720lliJCX*vbLC?QE10z4a??DnPhA}YiPPHDjIAluiD;NjB>_em}1K24O4|#
z^%B8ylE5r3=&`bv#5C4{tYzpnuN3ko7U_VP(<}n2Y))1b+hb*@H*62i6RfJCcH8T2
z-sXs$wmm5W=VfC1>5kIaD43S*&8tKPN6NN`<V~teq_dRp<qf5fb4Zq?Y~C@L(QO~q
zN;hNKObWzgoK}e~fH!c-_Bo9+OXDIvfvsip!uZ(q_bnA$({ia`Wv0WXc^X!qK4-w&
zGCc*(nl?3axUO{g(uvU{Cr_F)(>X0MZI(#J(5JtC>bQ=U5wm2A4H_ST#cANSJ_3ke
zM$ZDMwd>Ep-S>mLSAu&lpIL2fpG(iC=W?^TrP12hO6$nw$ZGqxMR7q~Y+GpirFW%0
zbouNW+ac^(4R+2=&rUB5t_1h5A;A}_;fFi>pCTq0n&%&ajDNwubgb6(pnY(SgTXJx
zPXB4=#O-%~w(Umu_3j&e*ZXRzW%)tRk<WHcTs;fb<3Q*9`%BvAfx(RyQ1`4IwQl=q
z|Kh=ggNs88LrcY5Ei2oO-A=9q$JP+zd*hD08fc$8J9~CMQ)8C*-6jtLr#3j4c-*ml
zv3sF=v2USoNxRjz(lL6~;~M)~?X~66UmRWu9$iD6FLXPx+Oz9M@AckVWTj{5DPqBP
zVYP41jmY)LjdRz}EqC7@Sm`@C@1y(iEO_QiwE@`AmjW<uaG>CsANktmg0sQ-)C2GC
ze?8rWdd@H#BAEXrb;;&NI~e4cySd>3erMIM{!?nx%D{o#?b#6-LU%{@L`3f6z`+RX
z`S|r#pg&<oVf>R5y^&7t(~htJo!@tbgAs}Q!vQaJ?y&-J-4lgKhj=gGjC2Z--Qv9-
zk<Lm&BqZJ&aOk1#w>U1jHI1N`%SkqV4#Xk^%4WI&DG-}x-9T7n6~4k=L|9M+#gk^M
zybh0Wl_&JRIYnX8OocB44Nn6~vy`eZw03nsFy;0m@_hXR2zOMu=A%*Jnw(c4IjeF%
z;)+Z&{K>xs$c{s3st2ri90EW*E+vh;2^SC3$R|5JnP`ceDi!6DL<|WoA&mE@WYRAs
zG+oA}Mg)6LO~R#=F2beL4Be896ok9FPDM@0g&d*c@%V5;vT|BJ9v_m58CXd&atbWx
z$~n<gG4z8(QZK5yl#ws0PDG`WV4q<UP%jN83PjqXcZ)%qYK2Cmsf_BVN)|BQViz^b
zz1osusFtJ~M6wE|2?196LEU)i=(nV)sFre~y5-oJ%+$5X1q)<MY=BGh7VH2_gdv5x
zD{1K2f}V8jD{3So_0x?u+yqt)NtOXy(JV(*%4LNY!_ffVQFW_;>2_rz6;(;jfzz#*
zx|~Kkn*;ZjJ;TEpHD^v*6nWs>GCQ2GIXE96ln{^UQ(}wnd~X6{1KXW36T?#%GxV5l
zScPPUMp;ZnLjoRv1|OpQKB_WC;DxXm)%GWHhD>4*fh~(-+zGY#Fy-FqRv{pqn|B$l
zb@D>%YNu2iSl;>BzN0IhuV3}8`H{DEzURK!`>?BbX=47utpAH0-B<mO`PO;iYH_Le
ze%t;US$@A}+;2O6$9KOi{DA-NKc8(!f$b1SK%KX5>D|x0dmnm(U#$r+uxUZ6i>?HZ
zqF?*M0q!?}u*lsN1t61+Yy+n2*OBgSeG;lgR6$uf`a)5dnL*e~7onU^$x^SqP#|w@
z<}qA}3-M*;Jawi-os}v;>Hv=&;KIrn2GR7ilvgcFPOJ47-boE)T~aS4)jEc;tWo47
zN`SuvKq?9BBh4?M!BAcB3BBUw^0-leRE4571xbMfM?WH+S8+x*EvaM_BwYnvfFVt{
z2u(QPElUo=4V4TGxP#2ZfHVh7rktDso9Y;YMK5X!09qqMlusiE>lXsVKqr>Yho|29
z&SZ##cNb&bfK<Rpr(tVO-@qXTp8(@5>KCaFh~q$FT7~HZMHB!cfV{qsia##S@4Hf2
z^*RxLjb(#_|DZvCjYHnfbznrHc6<sNOg{=R{qn)PX+^Vm+u!t&1J?$w;RSaPOkrtv
zxHo&mO{ScT#>rxwr@9VTYTd68ev|5^Al~$zs^=hY;&JHG%~&U)f_Ii-9--Dp$oB}f
vJwm}psO7Kd@L$lbzoQdt9<*z3joe{>H?@v>nLSU(b}-}2`Vl`9ay0)N73Hhb

literal 0
HcmV?d00001

diff --git a/dateutil/zoneinfo/dateutil-zoneinfo.tar.gz b/dateutil/zoneinfo/dateutil-zoneinfo.tar.gz
new file mode 100644
index 0000000000000000000000000000000000000000..524c48e12db7dfe159f282e4664f71ce249e1970
GIT binary patch
literal 174394
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

literal 0
HcmV?d00001

diff --git a/dateutil/zoneinfo/rebuild.py b/dateutil/zoneinfo/rebuild.py
new file mode 100644
index 0000000..684c658
--- /dev/null
+++ b/dateutil/zoneinfo/rebuild.py
@@ -0,0 +1,75 @@
+import logging
+import os
+import tempfile
+import shutil
+import json
+from subprocess import check_call, check_output
+from tarfile import TarFile
+
+from dateutil.zoneinfo import METADATA_FN, ZONEFILENAME
+
+
+def rebuild(filename, tag=None, format="gz", zonegroups=[], metadata=None):
+    """Rebuild the internal timezone info in dateutil/zoneinfo/zoneinfo*tar*
+
+    filename is the timezone tarball from ``ftp.iana.org/tz``.
+
+    """
+    tmpdir = tempfile.mkdtemp()
+    zonedir = os.path.join(tmpdir, "zoneinfo")
+    moduledir = os.path.dirname(__file__)
+    try:
+        with TarFile.open(filename) as tf:
+            for name in zonegroups:
+                tf.extract(name, tmpdir)
+            filepaths = [os.path.join(tmpdir, n) for n in zonegroups]
+
+            _run_zic(zonedir, filepaths)
+
+        # write metadata file
+        with open(os.path.join(zonedir, METADATA_FN), 'w') as f:
+            json.dump(metadata, f, indent=4, sort_keys=True)
+        target = os.path.join(moduledir, ZONEFILENAME)
+        with TarFile.open(target, "w:%s" % format) as tf:
+            for entry in os.listdir(zonedir):
+                entrypath = os.path.join(zonedir, entry)
+                tf.add(entrypath, entry)
+    finally:
+        shutil.rmtree(tmpdir)
+
+
+def _run_zic(zonedir, filepaths):
+    """Calls the ``zic`` compiler in a compatible way to get a "fat" binary.
+
+    Recent versions of ``zic`` default to ``-b slim``, while older versions
+    don't even have the ``-b`` option (but default to "fat" binaries). The
+    current version of dateutil does not support Version 2+ TZif files, which
+    causes problems when used in conjunction with "slim" binaries, so this
+    function is used to ensure that we always get a "fat" binary.
+    """
+
+    try:
+        help_text = check_output(["zic", "--help"])
+    except OSError as e:
+        _print_on_nosuchfile(e)
+        raise
+
+    if b"-b " in help_text:
+        bloat_args = ["-b", "fat"]
+    else:
+        bloat_args = []
+
+    check_call(["zic"] + bloat_args + ["-d", zonedir] + filepaths)
+
+
+def _print_on_nosuchfile(e):
+    """Print helpful troubleshooting message
+
+    e is an exception raised by subprocess.check_call()
+
+    """
+    if e.errno == 2:
+        logging.error(
+            "Could not find zic. Perhaps you need to install "
+            "libc-bin or some other package that provides it, "
+            "or it's not in your PATH?")
diff --git a/python_dateutil-2.8.2.dist-info/INSTALLER b/python_dateutil-2.8.2.dist-info/INSTALLER
new file mode 100644
index 0000000..a1b589e
--- /dev/null
+++ b/python_dateutil-2.8.2.dist-info/INSTALLER
@@ -0,0 +1 @@
+pip
diff --git a/python_dateutil-2.8.2.dist-info/LICENSE b/python_dateutil-2.8.2.dist-info/LICENSE
new file mode 100644
index 0000000..1e65815
--- /dev/null
+++ b/python_dateutil-2.8.2.dist-info/LICENSE
@@ -0,0 +1,54 @@
+Copyright 2017- Paul Ganssle <paul@ganssle.io>
+Copyright 2017- dateutil contributors (see AUTHORS file)
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+The above license applies to all contributions after 2017-12-01, as well as
+all contributions that have been re-licensed (see AUTHORS file for the list of
+contributors who have re-licensed their code).
+--------------------------------------------------------------------------------
+dateutil - Extensions to the standard Python datetime module.
+
+Copyright (c) 2003-2011 - Gustavo Niemeyer <gustavo@niemeyer.net>
+Copyright (c) 2012-2014 - Tomi Pieviläinen <tomi.pievilainen@iki.fi>
+Copyright (c) 2014-2016 - Yaron de Leeuw <me@jarondl.net>
+Copyright (c) 2015-     - Paul Ganssle <paul@ganssle.io>
+Copyright (c) 2015-     - dateutil contributors (see AUTHORS file)
+
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright notice,
+      this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright notice,
+      this list of conditions and the following disclaimer in the documentation
+      and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the names of its
+      contributors may be used to endorse or promote products derived from
+      this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+The above BSD License Applies to all code, even that also covered by Apache 2.0.
\ No newline at end of file
diff --git a/python_dateutil-2.8.2.dist-info/METADATA b/python_dateutil-2.8.2.dist-info/METADATA
new file mode 100644
index 0000000..1e46c96
--- /dev/null
+++ b/python_dateutil-2.8.2.dist-info/METADATA
@@ -0,0 +1,204 @@
+Metadata-Version: 2.1
+Name: python-dateutil
+Version: 2.8.2
+Summary: Extensions to the standard Python datetime module
+Home-page: https://github.com/dateutil/dateutil
+Author: Gustavo Niemeyer
+Author-email: gustavo@niemeyer.net
+Maintainer: Paul Ganssle
+Maintainer-email: dateutil@python.org
+License: Dual License
+Project-URL: Documentation, https://dateutil.readthedocs.io/en/stable/
+Project-URL: Source, https://github.com/dateutil/dateutil
+Platform: UNKNOWN
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: BSD License
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 2.7
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.3
+Classifier: Programming Language :: Python :: 3.4
+Classifier: Programming Language :: Python :: 3.5
+Classifier: Programming Language :: Python :: 3.6
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Topic :: Software Development :: Libraries
+Requires-Python: !=3.0.*,!=3.1.*,!=3.2.*,>=2.7
+Description-Content-Type: text/x-rst
+License-File: LICENSE
+Requires-Dist: six (>=1.5)
+
+dateutil - powerful extensions to datetime
+==========================================
+
+|pypi| |support| |licence|
+
+|gitter| |readthedocs|
+
+|travis| |appveyor| |pipelines| |coverage|
+
+.. |pypi| image:: https://img.shields.io/pypi/v/python-dateutil.svg?style=flat-square
+    :target: https://pypi.org/project/python-dateutil/
+    :alt: pypi version
+
+.. |support| image:: https://img.shields.io/pypi/pyversions/python-dateutil.svg?style=flat-square
+    :target: https://pypi.org/project/python-dateutil/
+    :alt: supported Python version
+
+.. |travis| image:: https://img.shields.io/travis/dateutil/dateutil/master.svg?style=flat-square&label=Travis%20Build
+    :target: https://travis-ci.org/dateutil/dateutil
+    :alt: travis build status
+
+.. |appveyor| image:: https://img.shields.io/appveyor/ci/dateutil/dateutil/master.svg?style=flat-square&logo=appveyor
+    :target: https://ci.appveyor.com/project/dateutil/dateutil
+    :alt: appveyor build status
+
+.. |pipelines| image:: https://dev.azure.com/pythondateutilazure/dateutil/_apis/build/status/dateutil.dateutil?branchName=master
+    :target: https://dev.azure.com/pythondateutilazure/dateutil/_build/latest?definitionId=1&branchName=master
+    :alt: azure pipelines build status
+
+.. |coverage| image:: https://codecov.io/gh/dateutil/dateutil/branch/master/graphs/badge.svg?branch=master
+    :target: https://codecov.io/gh/dateutil/dateutil?branch=master
+    :alt: Code coverage
+
+.. |gitter| image:: https://badges.gitter.im/dateutil/dateutil.svg
+   :alt: Join the chat at https://gitter.im/dateutil/dateutil
+   :target: https://gitter.im/dateutil/dateutil
+
+.. |licence| image:: https://img.shields.io/pypi/l/python-dateutil.svg?style=flat-square
+    :target: https://pypi.org/project/python-dateutil/
+    :alt: licence
+
+.. |readthedocs| image:: https://img.shields.io/readthedocs/dateutil/latest.svg?style=flat-square&label=Read%20the%20Docs
+   :alt: Read the documentation at https://dateutil.readthedocs.io/en/latest/
+   :target: https://dateutil.readthedocs.io/en/latest/
+
+The `dateutil` module provides powerful extensions to
+the standard `datetime` module, available in Python.
+
+Installation
+============
+`dateutil` can be installed from PyPI using `pip` (note that the package name is
+different from the importable name)::
+
+    pip install python-dateutil
+
+Download
+========
+dateutil is available on PyPI
+https://pypi.org/project/python-dateutil/
+
+The documentation is hosted at:
+https://dateutil.readthedocs.io/en/stable/
+
+Code
+====
+The code and issue tracker are hosted on GitHub:
+https://github.com/dateutil/dateutil/
+
+Features
+========
+
+* Computing of relative deltas (next month, next year,
+  next Monday, last week of month, etc);
+* Computing of relative deltas between two given
+  date and/or datetime objects;
+* Computing of dates based on very flexible recurrence rules,
+  using a superset of the `iCalendar <https://www.ietf.org/rfc/rfc2445.txt>`_
+  specification. Parsing of RFC strings is supported as well.
+* Generic parsing of dates in almost any string format;
+* Timezone (tzinfo) implementations for tzfile(5) format
+  files (/etc/localtime, /usr/share/zoneinfo, etc), TZ
+  environment string (in all known formats), iCalendar
+  format files, given ranges (with help from relative deltas),
+  local machine timezone, fixed offset timezone, UTC timezone,
+  and Windows registry-based time zones.
+* Internal up-to-date world timezone information based on
+  Olson's database.
+* Computing of Easter Sunday dates for any given year,
+  using Western, Orthodox or Julian algorithms;
+* A comprehensive test suite.
+
+Quick example
+=============
+Here's a snapshot, just to give an idea about the power of the
+package. For more examples, look at the documentation.
+
+Suppose you want to know how much time is left, in
+years/months/days/etc, before the next easter happening on a
+year with a Friday 13th in August, and you want to get today's
+date out of the "date" unix system command. Here is the code:
+
+.. code-block:: python3
+
+    >>> from dateutil.relativedelta import *
+    >>> from dateutil.easter import *
+    >>> from dateutil.rrule import *
+    >>> from dateutil.parser import *
+    >>> from datetime import *
+    >>> now = parse("Sat Oct 11 17:13:46 UTC 2003")
+    >>> today = now.date()
+    >>> year = rrule(YEARLY,dtstart=now,bymonth=8,bymonthday=13,byweekday=FR)[0].year
+    >>> rdelta = relativedelta(easter(year), today)
+    >>> print("Today is: %s" % today)
+    Today is: 2003-10-11
+    >>> print("Year with next Aug 13th on a Friday is: %s" % year)
+    Year with next Aug 13th on a Friday is: 2004
+    >>> print("How far is the Easter of that year: %s" % rdelta)
+    How far is the Easter of that year: relativedelta(months=+6)
+    >>> print("And the Easter of that year is: %s" % (today+rdelta))
+    And the Easter of that year is: 2004-04-11
+
+Being exactly 6 months ahead was **really** a coincidence :)
+
+Contributing
+============
+
+We welcome many types of contributions - bug reports, pull requests (code, infrastructure or documentation fixes). For more information about how to contribute to the project, see the ``CONTRIBUTING.md`` file in the repository.
+
+
+Author
+======
+The dateutil module was written by Gustavo Niemeyer <gustavo@niemeyer.net>
+in 2003.
+
+It is maintained by:
+
+* Gustavo Niemeyer <gustavo@niemeyer.net> 2003-2011
+* Tomi Pieviläinen <tomi.pievilainen@iki.fi> 2012-2014
+* Yaron de Leeuw <me@jarondl.net> 2014-2016
+* Paul Ganssle <paul@ganssle.io> 2015-
+
+Starting with version 2.4.1 and running until 2.8.2, all source and binary
+distributions will be signed by a PGP key that has, at the very least, been
+signed by the key which made the previous release. A table of release signing
+keys can be found below:
+
+===========  ============================
+Releases     Signing key fingerprint
+===========  ============================
+2.4.1-2.8.2  `6B49 ACBA DCF6 BD1C A206 67AB CD54 FCE3 D964 BEFB`_ 
+===========  ============================
+
+New releases *may* have signed tags, but binary and source distributions
+uploaded to PyPI will no longer have GPG signatures attached.
+
+Contact
+=======
+Our mailing list is available at `dateutil@python.org <https://mail.python.org/mailman/listinfo/dateutil>`_. As it is hosted by the PSF, it is subject to the `PSF code of
+conduct <https://www.python.org/psf/conduct/>`_.
+
+License
+=======
+
+All contributions after December 1, 2017 released under dual license - either `Apache 2.0 License <https://www.apache.org/licenses/LICENSE-2.0>`_ or the `BSD 3-Clause License <https://opensource.org/licenses/BSD-3-Clause>`_. Contributions before December 1, 2017 - except those those explicitly relicensed - are released only under the BSD 3-Clause License.
+
+
+.. _6B49 ACBA DCF6 BD1C A206 67AB CD54 FCE3 D964 BEFB:
+   https://pgp.mit.edu/pks/lookup?op=vindex&search=0xCD54FCE3D964BEFB
+
+
diff --git a/python_dateutil-2.8.2.dist-info/RECORD b/python_dateutil-2.8.2.dist-info/RECORD
new file mode 100644
index 0000000..e7d2f8d
--- /dev/null
+++ b/python_dateutil-2.8.2.dist-info/RECORD
@@ -0,0 +1,45 @@
+dateutil/__init__.py,sha256=lXElASqwYGwqlrSWSeX19JwF5Be9tNecDa9ebk-0gmk,222
+dateutil/__pycache__/__init__.cpython-312.pyc,,
+dateutil/__pycache__/_common.cpython-312.pyc,,
+dateutil/__pycache__/_version.cpython-312.pyc,,
+dateutil/__pycache__/easter.cpython-312.pyc,,
+dateutil/__pycache__/relativedelta.cpython-312.pyc,,
+dateutil/__pycache__/rrule.cpython-312.pyc,,
+dateutil/__pycache__/tzwin.cpython-312.pyc,,
+dateutil/__pycache__/utils.cpython-312.pyc,,
+dateutil/_common.py,sha256=77w0yytkrxlYbSn--lDVPUMabUXRR9I3lBv_vQRUqUY,932
+dateutil/_version.py,sha256=awyHv2PYvDR84dxjrHyzmm8nieFwMjcuuShPh-QNkM4,142
+dateutil/easter.py,sha256=dyBi-lKvimH1u_k6p7Z0JJK72QhqVtVBsqByvpEPKvc,2678
+dateutil/parser/__init__.py,sha256=wWk6GFuxTpjoggCGtgkceJoti4pVjl4_fHQXpNOaSYg,1766
+dateutil/parser/__pycache__/__init__.cpython-312.pyc,,
+dateutil/parser/__pycache__/_parser.cpython-312.pyc,,
+dateutil/parser/__pycache__/isoparser.cpython-312.pyc,,
+dateutil/parser/_parser.py,sha256=7klDdyicksQB_Xgl-3UAmBwzCYor1AIZqklIcT6dH_8,58796
+dateutil/parser/isoparser.py,sha256=EtLY7w22HWx-XJpTWxJD3XNs6LBHRCps77tCdLnYad8,13247
+dateutil/relativedelta.py,sha256=GjVxqpAVWnG67rdbf7pkoIlJvQqmju9NSfGCcqblc7U,24904
+dateutil/rrule.py,sha256=b6GVV4MpZDbBhJ5qitQKRyx8-_OKyeAbk57or2A8AYU,66556
+dateutil/tz/__init__.py,sha256=F-Mz13v6jYseklQf9Te9J6nzcLDmq47gORa61K35_FA,444
+dateutil/tz/__pycache__/__init__.cpython-312.pyc,,
+dateutil/tz/__pycache__/_common.cpython-312.pyc,,
+dateutil/tz/__pycache__/_factories.cpython-312.pyc,,
+dateutil/tz/__pycache__/tz.cpython-312.pyc,,
+dateutil/tz/__pycache__/win.cpython-312.pyc,,
+dateutil/tz/_common.py,sha256=cgzDTANsOXvEc86cYF77EsliuSab8Puwpsl5-bX3_S4,12977
+dateutil/tz/_factories.py,sha256=unb6XQNXrPMveksTCU-Ag8jmVZs4SojoPUcAHpWnrvU,2569
+dateutil/tz/tz.py,sha256=JotVjDcF16hzoouQ0kZW-5mCYu7Xj67NI-VQgnWapKE,62857
+dateutil/tz/win.py,sha256=xJszWgSwE1xPx_HJj4ZkepyukC_hNy016WMcXhbRaB8,12935
+dateutil/tzwin.py,sha256=7Ar4vdQCnnM0mKR3MUjbIKsZrBVfHgdwsJZc_mGYRew,59
+dateutil/utils.py,sha256=dKCchEw8eObi0loGTx91unBxm_7UGlU3v_FjFMdqwYM,1965
+dateutil/zoneinfo/__init__.py,sha256=KYg0pthCMjcp5MXSEiBJn3nMjZeNZav7rlJw5-tz1S4,5889
+dateutil/zoneinfo/__pycache__/__init__.cpython-312.pyc,,
+dateutil/zoneinfo/__pycache__/rebuild.cpython-312.pyc,,
+dateutil/zoneinfo/dateutil-zoneinfo.tar.gz,sha256=AkcdBx3XkEZwMSpS_TmOEfrEFHLvgxPNDVIwGVxTVaI,174394
+dateutil/zoneinfo/rebuild.py,sha256=MiqYzCIHvNbMH-LdRYLv-4T0EIA7hDKt5GLR0IRTLdI,2392
+python_dateutil-2.8.2.dist-info/INSTALLER,sha256=zuuue4knoyJ-UwPPXg8fezS7VCrXJQrAP7zeNuwvFQg,4
+python_dateutil-2.8.2.dist-info/LICENSE,sha256=ugD1Gg2SgjtaHN4n2LW50jIeZ-2NqbwWPv-W1eF-V34,2889
+python_dateutil-2.8.2.dist-info/METADATA,sha256=RDHtGo7BnYRjmYxot_wlu_W3N2CyvPtvchbtyIlKKPA,8218
+python_dateutil-2.8.2.dist-info/RECORD,,
+python_dateutil-2.8.2.dist-info/REQUESTED,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+python_dateutil-2.8.2.dist-info/WHEEL,sha256=Z-nyYpwrcSqxfdux5Mbn_DQ525iP7J2DG3JgGvOYyTQ,110
+python_dateutil-2.8.2.dist-info/top_level.txt,sha256=4tjdWkhRZvF7LA_BYe_L9gB2w_p2a-z5y6ArjaRkot8,9
+python_dateutil-2.8.2.dist-info/zip-safe,sha256=AbpHGcgLb-kRsJGnwFEktk7uzpZOCcBY74-YBdrKVGs,1
diff --git a/python_dateutil-2.8.2.dist-info/REQUESTED b/python_dateutil-2.8.2.dist-info/REQUESTED
new file mode 100644
index 0000000..e69de29
diff --git a/python_dateutil-2.8.2.dist-info/WHEEL b/python_dateutil-2.8.2.dist-info/WHEEL
new file mode 100644
index 0000000..01b8fc7
--- /dev/null
+++ b/python_dateutil-2.8.2.dist-info/WHEEL
@@ -0,0 +1,6 @@
+Wheel-Version: 1.0
+Generator: bdist_wheel (0.36.2)
+Root-Is-Purelib: true
+Tag: py2-none-any
+Tag: py3-none-any
+
diff --git a/python_dateutil-2.8.2.dist-info/top_level.txt b/python_dateutil-2.8.2.dist-info/top_level.txt
new file mode 100644
index 0000000..6650148
--- /dev/null
+++ b/python_dateutil-2.8.2.dist-info/top_level.txt
@@ -0,0 +1 @@
+dateutil
diff --git a/python_dateutil-2.8.2.dist-info/zip-safe b/python_dateutil-2.8.2.dist-info/zip-safe
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/python_dateutil-2.8.2.dist-info/zip-safe
@@ -0,0 +1 @@
+
diff --git a/six-1.16.0.dist-info/INSTALLER b/six-1.16.0.dist-info/INSTALLER
new file mode 100644
index 0000000..a1b589e
--- /dev/null
+++ b/six-1.16.0.dist-info/INSTALLER
@@ -0,0 +1 @@
+pip
diff --git a/six-1.16.0.dist-info/LICENSE b/six-1.16.0.dist-info/LICENSE
new file mode 100644
index 0000000..de66331
--- /dev/null
+++ b/six-1.16.0.dist-info/LICENSE
@@ -0,0 +1,18 @@
+Copyright (c) 2010-2020 Benjamin Peterson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/six-1.16.0.dist-info/METADATA b/six-1.16.0.dist-info/METADATA
new file mode 100644
index 0000000..6d7525c
--- /dev/null
+++ b/six-1.16.0.dist-info/METADATA
@@ -0,0 +1,49 @@
+Metadata-Version: 2.1
+Name: six
+Version: 1.16.0
+Summary: Python 2 and 3 compatibility utilities
+Home-page: https://github.com/benjaminp/six
+Author: Benjamin Peterson
+Author-email: benjamin@python.org
+License: MIT
+Platform: UNKNOWN
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Programming Language :: Python :: 2
+Classifier: Programming Language :: Python :: 3
+Classifier: Intended Audience :: Developers
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Topic :: Software Development :: Libraries
+Classifier: Topic :: Utilities
+Requires-Python: >=2.7, !=3.0.*, !=3.1.*, !=3.2.*
+
+.. image:: https://img.shields.io/pypi/v/six.svg
+   :target: https://pypi.org/project/six/
+   :alt: six on PyPI
+
+.. image:: https://travis-ci.org/benjaminp/six.svg?branch=master
+   :target: https://travis-ci.org/benjaminp/six
+   :alt: six on TravisCI
+
+.. image:: https://readthedocs.org/projects/six/badge/?version=latest
+   :target: https://six.readthedocs.io/
+   :alt: six's documentation on Read the Docs
+
+.. image:: https://img.shields.io/badge/license-MIT-green.svg
+   :target: https://github.com/benjaminp/six/blob/master/LICENSE
+   :alt: MIT License badge
+
+Six is a Python 2 and 3 compatibility library.  It provides utility functions
+for smoothing over the differences between the Python versions with the goal of
+writing Python code that is compatible on both Python versions.  See the
+documentation for more information on what is provided.
+
+Six supports Python 2.7 and 3.3+.  It is contained in only one Python
+file, so it can be easily copied into your project. (The copyright and license
+notice must be retained.)
+
+Online documentation is at https://six.readthedocs.io/.
+
+Bugs can be reported to https://github.com/benjaminp/six.  The code can also
+be found there.
+
+
diff --git a/six-1.16.0.dist-info/RECORD b/six-1.16.0.dist-info/RECORD
new file mode 100644
index 0000000..2209ab3
--- /dev/null
+++ b/six-1.16.0.dist-info/RECORD
@@ -0,0 +1,8 @@
+__pycache__/six.cpython-312.pyc,,
+six-1.16.0.dist-info/INSTALLER,sha256=zuuue4knoyJ-UwPPXg8fezS7VCrXJQrAP7zeNuwvFQg,4
+six-1.16.0.dist-info/LICENSE,sha256=i7hQxWWqOJ_cFvOkaWWtI9gq3_YPI5P8J2K2MYXo5sk,1066
+six-1.16.0.dist-info/METADATA,sha256=VQcGIFCAEmfZcl77E5riPCN4v2TIsc_qtacnjxKHJoI,1795
+six-1.16.0.dist-info/RECORD,,
+six-1.16.0.dist-info/WHEEL,sha256=Z-nyYpwrcSqxfdux5Mbn_DQ525iP7J2DG3JgGvOYyTQ,110
+six-1.16.0.dist-info/top_level.txt,sha256=_iVH_iYEtEXnD8nYGQYpYFUvkUW9sEO1GYbkeKSAais,4
+six.py,sha256=TOOfQi7nFGfMrIvtdr6wX4wyHH8M7aknmuLfo2cBBrM,34549
diff --git a/six-1.16.0.dist-info/WHEEL b/six-1.16.0.dist-info/WHEEL
new file mode 100644
index 0000000..01b8fc7
--- /dev/null
+++ b/six-1.16.0.dist-info/WHEEL
@@ -0,0 +1,6 @@
+Wheel-Version: 1.0
+Generator: bdist_wheel (0.36.2)
+Root-Is-Purelib: true
+Tag: py2-none-any
+Tag: py3-none-any
+
diff --git a/six-1.16.0.dist-info/top_level.txt b/six-1.16.0.dist-info/top_level.txt
new file mode 100644
index 0000000..ffe2fce
--- /dev/null
+++ b/six-1.16.0.dist-info/top_level.txt
@@ -0,0 +1 @@
+six
diff --git a/six.py b/six.py
new file mode 100644
index 0000000..4e15675
--- /dev/null
+++ b/six.py
@@ -0,0 +1,998 @@
+# Copyright (c) 2010-2020 Benjamin Peterson
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in all
+# copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+
+"""Utilities for writing code that runs on Python 2 and 3"""
+
+from __future__ import absolute_import
+
+import functools
+import itertools
+import operator
+import sys
+import types
+
+__author__ = "Benjamin Peterson <benjamin@python.org>"
+__version__ = "1.16.0"
+
+
+# Useful for very coarse version differentiation.
+PY2 = sys.version_info[0] == 2
+PY3 = sys.version_info[0] == 3
+PY34 = sys.version_info[0:2] >= (3, 4)
+
+if PY3:
+    string_types = str,
+    integer_types = int,
+    class_types = type,
+    text_type = str
+    binary_type = bytes
+
+    MAXSIZE = sys.maxsize
+else:
+    string_types = basestring,
+    integer_types = (int, long)
+    class_types = (type, types.ClassType)
+    text_type = unicode
+    binary_type = str
+
+    if sys.platform.startswith("java"):
+        # Jython always uses 32 bits.
+        MAXSIZE = int((1 << 31) - 1)
+    else:
+        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
+        class X(object):
+
+            def __len__(self):
+                return 1 << 31
+        try:
+            len(X())
+        except OverflowError:
+            # 32-bit
+            MAXSIZE = int((1 << 31) - 1)
+        else:
+            # 64-bit
+            MAXSIZE = int((1 << 63) - 1)
+        del X
+
+if PY34:
+    from importlib.util import spec_from_loader
+else:
+    spec_from_loader = None
+
+
+def _add_doc(func, doc):
+    """Add documentation to a function."""
+    func.__doc__ = doc
+
+
+def _import_module(name):
+    """Import module, returning the module after the last dot."""
+    __import__(name)
+    return sys.modules[name]
+
+
+class _LazyDescr(object):
+
+    def __init__(self, name):
+        self.name = name
+
+    def __get__(self, obj, tp):
+        result = self._resolve()
+        setattr(obj, self.name, result)  # Invokes __set__.
+        try:
+            # This is a bit ugly, but it avoids running this again by
+            # removing this descriptor.
+            delattr(obj.__class__, self.name)
+        except AttributeError:
+            pass
+        return result
+
+
+class MovedModule(_LazyDescr):
+
+    def __init__(self, name, old, new=None):
+        super(MovedModule, self).__init__(name)
+        if PY3:
+            if new is None:
+                new = name
+            self.mod = new
+        else:
+            self.mod = old
+
+    def _resolve(self):
+        return _import_module(self.mod)
+
+    def __getattr__(self, attr):
+        _module = self._resolve()
+        value = getattr(_module, attr)
+        setattr(self, attr, value)
+        return value
+
+
+class _LazyModule(types.ModuleType):
+
+    def __init__(self, name):
+        super(_LazyModule, self).__init__(name)
+        self.__doc__ = self.__class__.__doc__
+
+    def __dir__(self):
+        attrs = ["__doc__", "__name__"]
+        attrs += [attr.name for attr in self._moved_attributes]
+        return attrs
+
+    # Subclasses should override this
+    _moved_attributes = []
+
+
+class MovedAttribute(_LazyDescr):
+
+    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
+        super(MovedAttribute, self).__init__(name)
+        if PY3:
+            if new_mod is None:
+                new_mod = name
+            self.mod = new_mod
+            if new_attr is None:
+                if old_attr is None:
+                    new_attr = name
+                else:
+                    new_attr = old_attr
+            self.attr = new_attr
+        else:
+            self.mod = old_mod
+            if old_attr is None:
+                old_attr = name
+            self.attr = old_attr
+
+    def _resolve(self):
+        module = _import_module(self.mod)
+        return getattr(module, self.attr)
+
+
+class _SixMetaPathImporter(object):
+
+    """
+    A meta path importer to import six.moves and its submodules.
+
+    This class implements a PEP302 finder and loader. It should be compatible
+    with Python 2.5 and all existing versions of Python3
+    """
+
+    def __init__(self, six_module_name):
+        self.name = six_module_name
+        self.known_modules = {}
+
+    def _add_module(self, mod, *fullnames):
+        for fullname in fullnames:
+            self.known_modules[self.name + "." + fullname] = mod
+
+    def _get_module(self, fullname):
+        return self.known_modules[self.name + "." + fullname]
+
+    def find_module(self, fullname, path=None):
+        if fullname in self.known_modules:
+            return self
+        return None
+
+    def find_spec(self, fullname, path, target=None):
+        if fullname in self.known_modules:
+            return spec_from_loader(fullname, self)
+        return None
+
+    def __get_module(self, fullname):
+        try:
+            return self.known_modules[fullname]
+        except KeyError:
+            raise ImportError("This loader does not know module " + fullname)
+
+    def load_module(self, fullname):
+        try:
+            # in case of a reload
+            return sys.modules[fullname]
+        except KeyError:
+            pass
+        mod = self.__get_module(fullname)
+        if isinstance(mod, MovedModule):
+            mod = mod._resolve()
+        else:
+            mod.__loader__ = self
+        sys.modules[fullname] = mod
+        return mod
+
+    def is_package(self, fullname):
+        """
+        Return true, if the named module is a package.
+
+        We need this method to get correct spec objects with
+        Python 3.4 (see PEP451)
+        """
+        return hasattr(self.__get_module(fullname), "__path__")
+
+    def get_code(self, fullname):
+        """Return None
+
+        Required, if is_package is implemented"""
+        self.__get_module(fullname)  # eventually raises ImportError
+        return None
+    get_source = get_code  # same as get_code
+
+    def create_module(self, spec):
+        return self.load_module(spec.name)
+
+    def exec_module(self, module):
+        pass
+
+_importer = _SixMetaPathImporter(__name__)
+
+
+class _MovedItems(_LazyModule):
+
+    """Lazy loading of moved objects"""
+    __path__ = []  # mark as package
+
+
+_moved_attributes = [
+    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
+    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
+    MovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"),
+    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
+    MovedAttribute("intern", "__builtin__", "sys"),
+    MovedAttribute("map", "itertools", "builtins", "imap", "map"),
+    MovedAttribute("getcwd", "os", "os", "getcwdu", "getcwd"),
+    MovedAttribute("getcwdb", "os", "os", "getcwd", "getcwdb"),
+    MovedAttribute("getoutput", "commands", "subprocess"),
+    MovedAttribute("range", "__builtin__", "builtins", "xrange", "range"),
+    MovedAttribute("reload_module", "__builtin__", "importlib" if PY34 else "imp", "reload"),
+    MovedAttribute("reduce", "__builtin__", "functools"),
+    MovedAttribute("shlex_quote", "pipes", "shlex", "quote"),
+    MovedAttribute("StringIO", "StringIO", "io"),
+    MovedAttribute("UserDict", "UserDict", "collections"),
+    MovedAttribute("UserList", "UserList", "collections"),
+    MovedAttribute("UserString", "UserString", "collections"),
+    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
+    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),
+    MovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"),
+    MovedModule("builtins", "__builtin__"),
+    MovedModule("configparser", "ConfigParser"),
+    MovedModule("collections_abc", "collections", "collections.abc" if sys.version_info >= (3, 3) else "collections"),
+    MovedModule("copyreg", "copy_reg"),
+    MovedModule("dbm_gnu", "gdbm", "dbm.gnu"),
+    MovedModule("dbm_ndbm", "dbm", "dbm.ndbm"),
+    MovedModule("_dummy_thread", "dummy_thread", "_dummy_thread" if sys.version_info < (3, 9) else "_thread"),
+    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
+    MovedModule("http_cookies", "Cookie", "http.cookies"),
+    MovedModule("html_entities", "htmlentitydefs", "html.entities"),
+    MovedModule("html_parser", "HTMLParser", "html.parser"),
+    MovedModule("http_client", "httplib", "http.client"),
+    MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
+    MovedModule("email_mime_image", "email.MIMEImage", "email.mime.image"),
+    MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
+    MovedModule("email_mime_nonmultipart", "email.MIMENonMultipart", "email.mime.nonmultipart"),
+    MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
+    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
+    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
+    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
+    MovedModule("cPickle", "cPickle", "pickle"),
+    MovedModule("queue", "Queue"),
+    MovedModule("reprlib", "repr"),
+    MovedModule("socketserver", "SocketServer"),
+    MovedModule("_thread", "thread", "_thread"),
+    MovedModule("tkinter", "Tkinter"),
+    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
+    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
+    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
+    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
+    MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
+    MovedModule("tkinter_ttk", "ttk", "tkinter.ttk"),
+    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
+    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
+    MovedModule("tkinter_colorchooser", "tkColorChooser",
+                "tkinter.colorchooser"),
+    MovedModule("tkinter_commondialog", "tkCommonDialog",
+                "tkinter.commondialog"),
+    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
+    MovedModule("tkinter_font", "tkFont", "tkinter.font"),
+    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
+    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
+                "tkinter.simpledialog"),
+    MovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"),
+    MovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"),
+    MovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"),
+    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
+    MovedModule("xmlrpc_client", "xmlrpclib", "xmlrpc.client"),
+    MovedModule("xmlrpc_server", "SimpleXMLRPCServer", "xmlrpc.server"),
+]
+# Add windows specific modules.
+if sys.platform == "win32":
+    _moved_attributes += [
+        MovedModule("winreg", "_winreg"),
+    ]
+
+for attr in _moved_attributes:
+    setattr(_MovedItems, attr.name, attr)
+    if isinstance(attr, MovedModule):
+        _importer._add_module(attr, "moves." + attr.name)
+del attr
+
+_MovedItems._moved_attributes = _moved_attributes
+
+moves = _MovedItems(__name__ + ".moves")
+_importer._add_module(moves, "moves")
+
+
+class Module_six_moves_urllib_parse(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_parse"""
+
+
+_urllib_parse_moved_attributes = [
+    MovedAttribute("ParseResult", "urlparse", "urllib.parse"),
+    MovedAttribute("SplitResult", "urlparse", "urllib.parse"),
+    MovedAttribute("parse_qs", "urlparse", "urllib.parse"),
+    MovedAttribute("parse_qsl", "urlparse", "urllib.parse"),
+    MovedAttribute("urldefrag", "urlparse", "urllib.parse"),
+    MovedAttribute("urljoin", "urlparse", "urllib.parse"),
+    MovedAttribute("urlparse", "urlparse", "urllib.parse"),
+    MovedAttribute("urlsplit", "urlparse", "urllib.parse"),
+    MovedAttribute("urlunparse", "urlparse", "urllib.parse"),
+    MovedAttribute("urlunsplit", "urlparse", "urllib.parse"),
+    MovedAttribute("quote", "urllib", "urllib.parse"),
+    MovedAttribute("quote_plus", "urllib", "urllib.parse"),
+    MovedAttribute("unquote", "urllib", "urllib.parse"),
+    MovedAttribute("unquote_plus", "urllib", "urllib.parse"),
+    MovedAttribute("unquote_to_bytes", "urllib", "urllib.parse", "unquote", "unquote_to_bytes"),
+    MovedAttribute("urlencode", "urllib", "urllib.parse"),
+    MovedAttribute("splitquery", "urllib", "urllib.parse"),
+    MovedAttribute("splittag", "urllib", "urllib.parse"),
+    MovedAttribute("splituser", "urllib", "urllib.parse"),
+    MovedAttribute("splitvalue", "urllib", "urllib.parse"),
+    MovedAttribute("uses_fragment", "urlparse", "urllib.parse"),
+    MovedAttribute("uses_netloc", "urlparse", "urllib.parse"),
+    MovedAttribute("uses_params", "urlparse", "urllib.parse"),
+    MovedAttribute("uses_query", "urlparse", "urllib.parse"),
+    MovedAttribute("uses_relative", "urlparse", "urllib.parse"),
+]
+for attr in _urllib_parse_moved_attributes:
+    setattr(Module_six_moves_urllib_parse, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse"),
+                      "moves.urllib_parse", "moves.urllib.parse")
+
+
+class Module_six_moves_urllib_error(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_error"""
+
+
+_urllib_error_moved_attributes = [
+    MovedAttribute("URLError", "urllib2", "urllib.error"),
+    MovedAttribute("HTTPError", "urllib2", "urllib.error"),
+    MovedAttribute("ContentTooShortError", "urllib", "urllib.error"),
+]
+for attr in _urllib_error_moved_attributes:
+    setattr(Module_six_moves_urllib_error, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_error(__name__ + ".moves.urllib.error"),
+                      "moves.urllib_error", "moves.urllib.error")
+
+
+class Module_six_moves_urllib_request(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_request"""
+
+
+_urllib_request_moved_attributes = [
+    MovedAttribute("urlopen", "urllib2", "urllib.request"),
+    MovedAttribute("install_opener", "urllib2", "urllib.request"),
+    MovedAttribute("build_opener", "urllib2", "urllib.request"),
+    MovedAttribute("pathname2url", "urllib", "urllib.request"),
+    MovedAttribute("url2pathname", "urllib", "urllib.request"),
+    MovedAttribute("getproxies", "urllib", "urllib.request"),
+    MovedAttribute("Request", "urllib2", "urllib.request"),
+    MovedAttribute("OpenerDirector", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"),
+    MovedAttribute("ProxyHandler", "urllib2", "urllib.request"),
+    MovedAttribute("BaseHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"),
+    MovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPSHandler", "urllib2", "urllib.request"),
+    MovedAttribute("FileHandler", "urllib2", "urllib.request"),
+    MovedAttribute("FTPHandler", "urllib2", "urllib.request"),
+    MovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"),
+    MovedAttribute("UnknownHandler", "urllib2", "urllib.request"),
+    MovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"),
+    MovedAttribute("urlretrieve", "urllib", "urllib.request"),
+    MovedAttribute("urlcleanup", "urllib", "urllib.request"),
+    MovedAttribute("URLopener", "urllib", "urllib.request"),
+    MovedAttribute("FancyURLopener", "urllib", "urllib.request"),
+    MovedAttribute("proxy_bypass", "urllib", "urllib.request"),
+    MovedAttribute("parse_http_list", "urllib2", "urllib.request"),
+    MovedAttribute("parse_keqv_list", "urllib2", "urllib.request"),
+]
+for attr in _urllib_request_moved_attributes:
+    setattr(Module_six_moves_urllib_request, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_request(__name__ + ".moves.urllib.request"),
+                      "moves.urllib_request", "moves.urllib.request")
+
+
+class Module_six_moves_urllib_response(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_response"""
+
+
+_urllib_response_moved_attributes = [
+    MovedAttribute("addbase", "urllib", "urllib.response"),
+    MovedAttribute("addclosehook", "urllib", "urllib.response"),
+    MovedAttribute("addinfo", "urllib", "urllib.response"),
+    MovedAttribute("addinfourl", "urllib", "urllib.response"),
+]
+for attr in _urllib_response_moved_attributes:
+    setattr(Module_six_moves_urllib_response, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_response(__name__ + ".moves.urllib.response"),
+                      "moves.urllib_response", "moves.urllib.response")
+
+
+class Module_six_moves_urllib_robotparser(_LazyModule):
+
+    """Lazy loading of moved objects in six.moves.urllib_robotparser"""
+
+
+_urllib_robotparser_moved_attributes = [
+    MovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"),
+]
+for attr in _urllib_robotparser_moved_attributes:
+    setattr(Module_six_moves_urllib_robotparser, attr.name, attr)
+del attr
+
+Module_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes
+
+_importer._add_module(Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser"),
+                      "moves.urllib_robotparser", "moves.urllib.robotparser")
+
+
+class Module_six_moves_urllib(types.ModuleType):
+
+    """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
+    __path__ = []  # mark as package
+    parse = _importer._get_module("moves.urllib_parse")
+    error = _importer._get_module("moves.urllib_error")
+    request = _importer._get_module("moves.urllib_request")
+    response = _importer._get_module("moves.urllib_response")
+    robotparser = _importer._get_module("moves.urllib_robotparser")
+
+    def __dir__(self):
+        return ['parse', 'error', 'request', 'response', 'robotparser']
+
+_importer._add_module(Module_six_moves_urllib(__name__ + ".moves.urllib"),
+                      "moves.urllib")
+
+
+def add_move(move):
+    """Add an item to six.moves."""
+    setattr(_MovedItems, move.name, move)
+
+
+def remove_move(name):
+    """Remove item from six.moves."""
+    try:
+        delattr(_MovedItems, name)
+    except AttributeError:
+        try:
+            del moves.__dict__[name]
+        except KeyError:
+            raise AttributeError("no such move, %r" % (name,))
+
+
+if PY3:
+    _meth_func = "__func__"
+    _meth_self = "__self__"
+
+    _func_closure = "__closure__"
+    _func_code = "__code__"
+    _func_defaults = "__defaults__"
+    _func_globals = "__globals__"
+else:
+    _meth_func = "im_func"
+    _meth_self = "im_self"
+
+    _func_closure = "func_closure"
+    _func_code = "func_code"
+    _func_defaults = "func_defaults"
+    _func_globals = "func_globals"
+
+
+try:
+    advance_iterator = next
+except NameError:
+    def advance_iterator(it):
+        return it.next()
+next = advance_iterator
+
+
+try:
+    callable = callable
+except NameError:
+    def callable(obj):
+        return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)
+
+
+if PY3:
+    def get_unbound_function(unbound):
+        return unbound
+
+    create_bound_method = types.MethodType
+
+    def create_unbound_method(func, cls):
+        return func
+
+    Iterator = object
+else:
+    def get_unbound_function(unbound):
+        return unbound.im_func
+
+    def create_bound_method(func, obj):
+        return types.MethodType(func, obj, obj.__class__)
+
+    def create_unbound_method(func, cls):
+        return types.MethodType(func, None, cls)
+
+    class Iterator(object):
+
+        def next(self):
+            return type(self).__next__(self)
+
+    callable = callable
+_add_doc(get_unbound_function,
+         """Get the function out of a possibly unbound function""")
+
+
+get_method_function = operator.attrgetter(_meth_func)
+get_method_self = operator.attrgetter(_meth_self)
+get_function_closure = operator.attrgetter(_func_closure)
+get_function_code = operator.attrgetter(_func_code)
+get_function_defaults = operator.attrgetter(_func_defaults)
+get_function_globals = operator.attrgetter(_func_globals)
+
+
+if PY3:
+    def iterkeys(d, **kw):
+        return iter(d.keys(**kw))
+
+    def itervalues(d, **kw):
+        return iter(d.values(**kw))
+
+    def iteritems(d, **kw):
+        return iter(d.items(**kw))
+
+    def iterlists(d, **kw):
+        return iter(d.lists(**kw))
+
+    viewkeys = operator.methodcaller("keys")
+
+    viewvalues = operator.methodcaller("values")
+
+    viewitems = operator.methodcaller("items")
+else:
+    def iterkeys(d, **kw):
+        return d.iterkeys(**kw)
+
+    def itervalues(d, **kw):
+        return d.itervalues(**kw)
+
+    def iteritems(d, **kw):
+        return d.iteritems(**kw)
+
+    def iterlists(d, **kw):
+        return d.iterlists(**kw)
+
+    viewkeys = operator.methodcaller("viewkeys")
+
+    viewvalues = operator.methodcaller("viewvalues")
+
+    viewitems = operator.methodcaller("viewitems")
+
+_add_doc(iterkeys, "Return an iterator over the keys of a dictionary.")
+_add_doc(itervalues, "Return an iterator over the values of a dictionary.")
+_add_doc(iteritems,
+         "Return an iterator over the (key, value) pairs of a dictionary.")
+_add_doc(iterlists,
+         "Return an iterator over the (key, [values]) pairs of a dictionary.")
+
+
+if PY3:
+    def b(s):
+        return s.encode("latin-1")
+
+    def u(s):
+        return s
+    unichr = chr
+    import struct
+    int2byte = struct.Struct(">B").pack
+    del struct
+    byte2int = operator.itemgetter(0)
+    indexbytes = operator.getitem
+    iterbytes = iter
+    import io
+    StringIO = io.StringIO
+    BytesIO = io.BytesIO
+    del io
+    _assertCountEqual = "assertCountEqual"
+    if sys.version_info[1] <= 1:
+        _assertRaisesRegex = "assertRaisesRegexp"
+        _assertRegex = "assertRegexpMatches"
+        _assertNotRegex = "assertNotRegexpMatches"
+    else:
+        _assertRaisesRegex = "assertRaisesRegex"
+        _assertRegex = "assertRegex"
+        _assertNotRegex = "assertNotRegex"
+else:
+    def b(s):
+        return s
+    # Workaround for standalone backslash
+
+    def u(s):
+        return unicode(s.replace(r'\\', r'\\\\'), "unicode_escape")
+    unichr = unichr
+    int2byte = chr
+
+    def byte2int(bs):
+        return ord(bs[0])
+
+    def indexbytes(buf, i):
+        return ord(buf[i])
+    iterbytes = functools.partial(itertools.imap, ord)
+    import StringIO
+    StringIO = BytesIO = StringIO.StringIO
+    _assertCountEqual = "assertItemsEqual"
+    _assertRaisesRegex = "assertRaisesRegexp"
+    _assertRegex = "assertRegexpMatches"
+    _assertNotRegex = "assertNotRegexpMatches"
+_add_doc(b, """Byte literal""")
+_add_doc(u, """Text literal""")
+
+
+def assertCountEqual(self, *args, **kwargs):
+    return getattr(self, _assertCountEqual)(*args, **kwargs)
+
+
+def assertRaisesRegex(self, *args, **kwargs):
+    return getattr(self, _assertRaisesRegex)(*args, **kwargs)
+
+
+def assertRegex(self, *args, **kwargs):
+    return getattr(self, _assertRegex)(*args, **kwargs)
+
+
+def assertNotRegex(self, *args, **kwargs):
+    return getattr(self, _assertNotRegex)(*args, **kwargs)
+
+
+if PY3:
+    exec_ = getattr(moves.builtins, "exec")
+
+    def reraise(tp, value, tb=None):
+        try:
+            if value is None:
+                value = tp()
+            if value.__traceback__ is not tb:
+                raise value.with_traceback(tb)
+            raise value
+        finally:
+            value = None
+            tb = None
+
+else:
+    def exec_(_code_, _globs_=None, _locs_=None):
+        """Execute code in a namespace."""
+        if _globs_ is None:
+            frame = sys._getframe(1)
+            _globs_ = frame.f_globals
+            if _locs_ is None:
+                _locs_ = frame.f_locals
+            del frame
+        elif _locs_ is None:
+            _locs_ = _globs_
+        exec("""exec _code_ in _globs_, _locs_""")
+
+    exec_("""def reraise(tp, value, tb=None):
+    try:
+        raise tp, value, tb
+    finally:
+        tb = None
+""")
+
+
+if sys.version_info[:2] > (3,):
+    exec_("""def raise_from(value, from_value):
+    try:
+        raise value from from_value
+    finally:
+        value = None
+""")
+else:
+    def raise_from(value, from_value):
+        raise value
+
+
+print_ = getattr(moves.builtins, "print", None)
+if print_ is None:
+    def print_(*args, **kwargs):
+        """The new-style print function for Python 2.4 and 2.5."""
+        fp = kwargs.pop("file", sys.stdout)
+        if fp is None:
+            return
+
+        def write(data):
+            if not isinstance(data, basestring):
+                data = str(data)
+            # If the file has an encoding, encode unicode with it.
+            if (isinstance(fp, file) and
+                    isinstance(data, unicode) and
+                    fp.encoding is not None):
+                errors = getattr(fp, "errors", None)
+                if errors is None:
+                    errors = "strict"
+                data = data.encode(fp.encoding, errors)
+            fp.write(data)
+        want_unicode = False
+        sep = kwargs.pop("sep", None)
+        if sep is not None:
+            if isinstance(sep, unicode):
+                want_unicode = True
+            elif not isinstance(sep, str):
+                raise TypeError("sep must be None or a string")
+        end = kwargs.pop("end", None)
+        if end is not None:
+            if isinstance(end, unicode):
+                want_unicode = True
+            elif not isinstance(end, str):
+                raise TypeError("end must be None or a string")
+        if kwargs:
+            raise TypeError("invalid keyword arguments to print()")
+        if not want_unicode:
+            for arg in args:
+                if isinstance(arg, unicode):
+                    want_unicode = True
+                    break
+        if want_unicode:
+            newline = unicode("\n")
+            space = unicode(" ")
+        else:
+            newline = "\n"
+            space = " "
+        if sep is None:
+            sep = space
+        if end is None:
+            end = newline
+        for i, arg in enumerate(args):
+            if i:
+                write(sep)
+            write(arg)
+        write(end)
+if sys.version_info[:2] < (3, 3):
+    _print = print_
+
+    def print_(*args, **kwargs):
+        fp = kwargs.get("file", sys.stdout)
+        flush = kwargs.pop("flush", False)
+        _print(*args, **kwargs)
+        if flush and fp is not None:
+            fp.flush()
+
+_add_doc(reraise, """Reraise an exception.""")
+
+if sys.version_info[0:2] < (3, 4):
+    # This does exactly the same what the :func:`py3:functools.update_wrapper`
+    # function does on Python versions after 3.2. It sets the ``__wrapped__``
+    # attribute on ``wrapper`` object and it doesn't raise an error if any of
+    # the attributes mentioned in ``assigned`` and ``updated`` are missing on
+    # ``wrapped`` object.
+    def _update_wrapper(wrapper, wrapped,
+                        assigned=functools.WRAPPER_ASSIGNMENTS,
+                        updated=functools.WRAPPER_UPDATES):
+        for attr in assigned:
+            try:
+                value = getattr(wrapped, attr)
+            except AttributeError:
+                continue
+            else:
+                setattr(wrapper, attr, value)
+        for attr in updated:
+            getattr(wrapper, attr).update(getattr(wrapped, attr, {}))
+        wrapper.__wrapped__ = wrapped
+        return wrapper
+    _update_wrapper.__doc__ = functools.update_wrapper.__doc__
+
+    def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,
+              updated=functools.WRAPPER_UPDATES):
+        return functools.partial(_update_wrapper, wrapped=wrapped,
+                                 assigned=assigned, updated=updated)
+    wraps.__doc__ = functools.wraps.__doc__
+
+else:
+    wraps = functools.wraps
+
+
+def with_metaclass(meta, *bases):
+    """Create a base class with a metaclass."""
+    # This requires a bit of explanation: the basic idea is to make a dummy
+    # metaclass for one level of class instantiation that replaces itself with
+    # the actual metaclass.
+    class metaclass(type):
+
+        def __new__(cls, name, this_bases, d):
+            if sys.version_info[:2] >= (3, 7):
+                # This version introduced PEP 560 that requires a bit
+                # of extra care (we mimic what is done by __build_class__).
+                resolved_bases = types.resolve_bases(bases)
+                if resolved_bases is not bases:
+                    d['__orig_bases__'] = bases
+            else:
+                resolved_bases = bases
+            return meta(name, resolved_bases, d)
+
+        @classmethod
+        def __prepare__(cls, name, this_bases):
+            return meta.__prepare__(name, bases)
+    return type.__new__(metaclass, 'temporary_class', (), {})
+
+
+def add_metaclass(metaclass):
+    """Class decorator for creating a class with a metaclass."""
+    def wrapper(cls):
+        orig_vars = cls.__dict__.copy()
+        slots = orig_vars.get('__slots__')
+        if slots is not None:
+            if isinstance(slots, str):
+                slots = [slots]
+            for slots_var in slots:
+                orig_vars.pop(slots_var)
+        orig_vars.pop('__dict__', None)
+        orig_vars.pop('__weakref__', None)
+        if hasattr(cls, '__qualname__'):
+            orig_vars['__qualname__'] = cls.__qualname__
+        return metaclass(cls.__name__, cls.__bases__, orig_vars)
+    return wrapper
+
+
+def ensure_binary(s, encoding='utf-8', errors='strict'):
+    """Coerce **s** to six.binary_type.
+
+    For Python 2:
+      - `unicode` -> encoded to `str`
+      - `str` -> `str`
+
+    For Python 3:
+      - `str` -> encoded to `bytes`
+      - `bytes` -> `bytes`
+    """
+    if isinstance(s, binary_type):
+        return s
+    if isinstance(s, text_type):
+        return s.encode(encoding, errors)
+    raise TypeError("not expecting type '%s'" % type(s))
+
+
+def ensure_str(s, encoding='utf-8', errors='strict'):
+    """Coerce *s* to `str`.
+
+    For Python 2:
+      - `unicode` -> encoded to `str`
+      - `str` -> `str`
+
+    For Python 3:
+      - `str` -> `str`
+      - `bytes` -> decoded to `str`
+    """
+    # Optimization: Fast return for the common case.
+    if type(s) is str:
+        return s
+    if PY2 and isinstance(s, text_type):
+        return s.encode(encoding, errors)
+    elif PY3 and isinstance(s, binary_type):
+        return s.decode(encoding, errors)
+    elif not isinstance(s, (text_type, binary_type)):
+        raise TypeError("not expecting type '%s'" % type(s))
+    return s
+
+
+def ensure_text(s, encoding='utf-8', errors='strict'):
+    """Coerce *s* to six.text_type.
+
+    For Python 2:
+      - `unicode` -> `unicode`
+      - `str` -> `unicode`
+
+    For Python 3:
+      - `str` -> `str`
+      - `bytes` -> decoded to `str`
+    """
+    if isinstance(s, binary_type):
+        return s.decode(encoding, errors)
+    elif isinstance(s, text_type):
+        return s
+    else:
+        raise TypeError("not expecting type '%s'" % type(s))
+
+
+def python_2_unicode_compatible(klass):
+    """
+    A class decorator that defines __unicode__ and __str__ methods under Python 2.
+    Under Python 3 it does nothing.
+
+    To support Python 2 and 3 with a single code base, define a __str__ method
+    returning text and apply this decorator to the class.
+    """
+    if PY2:
+        if '__str__' not in klass.__dict__:
+            raise ValueError("@python_2_unicode_compatible cannot be applied "
+                             "to %s because it doesn't define __str__()." %
+                             klass.__name__)
+        klass.__unicode__ = klass.__str__
+        klass.__str__ = lambda self: self.__unicode__().encode('utf-8')
+    return klass
+
+
+# Complete the moves implementation.
+# This code is at the end of this module to speed up module loading.
+# Turn this module into a package.
+__path__ = []  # required for PEP 302 and PEP 451
+__package__ = __name__  # see PEP 366 @ReservedAssignment
+if globals().get("__spec__") is not None:
+    __spec__.submodule_search_locations = []  # PEP 451 @UndefinedVariable
+# Remove other six meta path importers, since they cause problems. This can
+# happen if six is removed from sys.modules and then reloaded. (Setuptools does
+# this for some reason.)
+if sys.meta_path:
+    for i, importer in enumerate(sys.meta_path):
+        # Here's some real nastiness: Another "instance" of the six module might
+        # be floating around. Therefore, we can't use isinstance() to check for
+        # the six meta path importer, since the other six instance will have
+        # inserted an importer with different class.
+        if (type(importer).__name__ == "_SixMetaPathImporter" and
+                importer.name == __name__):
+            del sys.meta_path[i]
+            break
+    del i, importer
+# Finally, add the importer to the meta path import hook.
+sys.meta_path.append(_importer)
diff --git a/src/App.tsx b/src/App.tsx
index 0728518..b83f979 100755
--- a/src/App.tsx
+++ b/src/App.tsx
@@ -8,6 +8,7 @@ import './App.css';
  */
 interface IState {
   data: ServerRespond[],
+  showGraph: boolean,
 }
 
 /**
@@ -22,6 +23,7 @@ class App extends Component<{}, IState> {
       // data saves the server responds.
       // We use this state to parse data down to the child element (Graph) as element property
       data: [],
+      showGraph: false,
     };
   }
 
@@ -29,18 +31,28 @@ class App extends Component<{}, IState> {
    * Render Graph react component with state.data parse as property data
    */
   renderGraph() {
-    return (<Graph data={this.state.data}/>)
+    if (this.state.showGraph) {
+      return (<Graph data={this.state.data}/>)
+    }
   }
 
   /**
    * Get new data from server and update the state with the new data
    */
   getDataFromServer() {
-    DataStreamer.getData((serverResponds: ServerRespond[]) => {
-      // Update the state by creating a new array of data that consists of
-      // Previous data in the state and the new data from server
-      this.setState({ data: [...this.state.data, ...serverResponds] });
-    });
+    let x = 0;
+    const interval = setInterval(() => {
+      DataStreamer.getData((serverResponds: ServerRespond[]) => {
+        this.setState({
+          data: serverResponds,
+          showGraph: true,
+        });
+      });
+      x++;
+      if (x > 1000) {
+        clearInterval(interval);
+      }
+    }, 100);
   }
 
   /**
diff --git a/src/Graph.tsx b/src/Graph.tsx
index 3b2a7da..da2582e 100644
--- a/src/Graph.tsx
+++ b/src/Graph.tsx
@@ -14,7 +14,7 @@ interface IProps {
  * Perspective library adds load to HTMLElement prototype.
  * This interface acts as a wrapper for Typescript compiler.
  */
-interface PerspectiveViewerElement {
+interface PerspectiveViewerElement extends HTMLElement {
   load: (table: Table) => void,
 }
 
@@ -32,7 +32,7 @@ class Graph extends Component<IProps, {}> {
 
   componentDidMount() {
     // Get element to attach the table from the DOM.
-    const elem: PerspectiveViewerElement = document.getElementsByTagName('perspective-viewer')[0] as unknown as PerspectiveViewerElement;
+    const elem = document.getElementsByTagName('perspective-viewer')[0] as unknown as PerspectiveViewerElement;
 
     const schema = {
       stock: 'string',
@@ -49,6 +49,11 @@ class Graph extends Component<IProps, {}> {
 
       // Add more Perspective configurations here.
       elem.load(this.table);
+      elem.setAttribute('view', 'y_line');
+      elem.setAttribute('column-pivots', '["stock"]');
+      elem.setAttribute('row-pivots', '["timestamp"]');
+      elem.setAttribute('columns', '["top_ask_price"]');
+      elem.setAttribute('aggregates', '{"stock":"distinct count", "top_ask_price":"avg", "top_bid_price":"avg", "timestamp":"distinct count"}');
     }
   }
 
-- 
2.43.0.windows.1

